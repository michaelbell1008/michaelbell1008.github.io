<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PMP Resource</title>
      <link href="/Book/2023/07/18/resource/"/>
      <url>/Book/2023/07/18/resource/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Plan-Resource-Management">1. Plan Resource Management</h2><h3 id="a-Inputs">a. Inputs</h3><ul><li>Enterprise Environmental Factors</li><li>Organizational Process Assets</li></ul><h3 id="b-Plan-Resource-Management">b. Plan Resource Management</h3><h3 id="c-Tools-Techniques">c. Tools &amp; Techniques</h3><h3 id="d-Outputs">d. Outputs</h3><h2 id="2-Estimate-Activity-Resources">2. Estimate Activity Resources</h2><h3 id="a-Inputs-v2">a. Inputs</h3><ul><li>Project management plan<ul><li>Resource management plan</li><li>Scope baseline</li></ul></li><li>Project documents<ul><li>Activity list</li><li>Activity attributes</li><li>Cost estimates</li><li>Resource calendars</li><li>Assumption log</li><li>Risk register</li></ul></li><li>Enterprise Environmental Factors</li><li>Organizational Process Assets</li></ul><h3 id="b-Estimate-Activity-Resources">b. Estimate Activity Resources</h3><ul><li>Process of estimating team resources and the type and quantities of materials, equipment, and supplies necessary to perform project work</li><li>Làm định kỳ trong suốt dự án. Và được phối hợp với quy trình Estimate Actitivity Duration và Estimate Costs processes.</li><li>Bằng cách:<ul><li>Determine resource type and estimate the quantity of resources to complete the activities.</li><li>Re-evaluate and decide the optimal way to complete the activity within the given assumptions and constraints (technical aspects, schedule, budget, …) if needed.</li><li>Finalize and document the Resource requirements</li></ul></li></ul><h3 id="c-Tools-Techniques-v2">c. Tools &amp; Techniques</h3><ul><li>Analogous estimating</li><li>Parametric estimating</li><li>Bottom-up estimating</li><li>Alternative Analysis</li></ul><h3 id="d-Outputs-v2">d. Outputs</h3><ul><li>Resource requirements</li><li>Basis of estimates</li><li>Resource Breakdown Structure (RBS)</li><li>Project documents updates<ul><li>Activity attributes</li><li>Assumption log</li><li>Lessons learned register</li></ul></li></ul><h2 id="3-Acquire-Resources">3. Acquire Resources</h2><h3 id="a-Inputs-v3">a. Inputs</h3><ul><li><p>Project Management Plan</p></li><li><p>Project documents</p></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Acquire-Resources">b. Acquire Resources</h3><ul><li><p>The process of obtaining team members, facilities, equipment, materials, supplies, and other resources necessary to complete project work.</p></li><li><p>Failure to acquire the necessary resources or insufficient resources decrease the probability of success and,in a worst-case scenario, could result in project cancellation.</p></li><li><p>Các resources được lấy từ external hoặc internal:</p><ul><li>Internal resources được lấy từ functional managers hoăc resources managers</li><li>External resources được lấy từ procurement processes</li><li>Nếu resources của nhóm không có sẵn thì PM hoặc Project team có thể yêu cầu thay thế bằng resources khác (có thể competencies và cost khác nhau).</li></ul></li></ul><h3 id="c-Tools-Techniques-v3">c. Tools &amp; Techniques</h3><ul><li><p>Multi-criteria decision analysis</p><ul><li>ASK/ASKE model for team resources:<ul><li>Attitude</li><li>Skills</li><li>Knowledge</li><li>Experience</li></ul></li><li>Tránh lỗi Halo effect (Vì A làm tốt công việc hiện tại nên nghĩ nếu A ở vị trí PM cũng sẽ tốt)</li></ul></li><li><p>Pre-Assignment</p></li><li><p>Negotiation</p></li><li><p>Virtual Teams</p></li></ul><h3 id="d-Outputs-v3">d. Outputs</h3><ul><li>Team Resource Assignments</li><li>Physical Resource Assignments</li><li>Resource Calendar<ul><li>Miêu tả khi nào cần và dùng resource trong bao lâu</li><li>Holidays thường không được ddauw vào resource calendar</li></ul></li><li>Change Request</li><li>Project management plan updates:<ul><li>Resource management plan.</li><li>Cost baseline.</li></ul></li><li>Project documents updates</li></ul><h2 id="4-Develop-Team">4. Develop Team</h2><h3 id="a-Inputs-v4">a. Inputs</h3><ul><li>Project management plan</li><li>Project documents<ul><li>Team charter</li><li>Project team assignments</li><li>Resource calendars</li><li>Lessons learned register</li><li>Project schedule</li></ul></li><li>Enterprise Environmental Factors</li><li>Organizational Process Assets</li></ul><h3 id="b-Develop-Team">b. Develop Team</h3><ul><li>The process of improving competencies (năng lực), team member interaction, and the overall team environment to enhance project performance.</li><li>Việc này được làm trong suốt dự án</li><li>5 giai đoạn phát triển nhóm theo Tuckman:<ul><li>Forming (hình thành): Gặp gỡ, tìm hiểu về dự án. Mọi người thường độc lập và không cởi mở</li><li>Storming (bão tố): Bắt đầu giải quyết công việc dự án. Dễ xảy ra mâu thuẫn, thống nhất trong các quyết định của nhóm</li><li>Norming (tiêu chuẩn): Các thành viên bắt đầu làm việc cùng nhau và điều chỉnh bản thân để hỗ trợ cho nhóm. Các thành viên học cách tin tưởng lẫn nhau.</li><li>Performing (thực hiện): Cả đội như 1 thể thống nhất. Các thành viên trong nhóm phụ thuộc lẫn nhau, giải quyết vấn đề hiệu quả</li><li>Adjourning (Ngừng): Nhóm hoàn thành công việc và chuyển khỏi dự án</li></ul></li></ul><h3 id="c-Tools-Techniques-v4">c. Tools &amp; Techniques</h3><ul><li>Co-Location</li><li>Virtual Teams</li><li>Communication technology<ul><li>Team Charter/Ground Rules: một tài liệu thiết lập các giá trị nhóm, thỏa thuận và hướng dẫn vận hành cho nhóm.</li></ul></li><li>Team Building Activities</li><li>Training</li><li>Recognition and Rewards<ul><li>Win lose (zero sum) rewards</li><li>Win-win rewards</li><li>Maslow’s Theory of Needs</li><li>David McClelland’s Theory of Needs</li><li>Herzberg’s Motivational and Hygiene Factors</li></ul></li><li>Individual and team assessment tools</li><li>Meetings</li></ul><h3 id="d-Outputs-v4">d. Outputs</h3><ul><li>Team performance assessments</li><li>Change requests</li><li>Project management plan updates</li><li>Project documents updates</li><li>Enterprise environmental factors updates</li><li>Organizational process assets updates</li></ul><h2 id="5-Manage-Team">5. Manage Team</h2><h3 id="a-Inputs-v5">a. Inputs</h3><ul><li>Project management plan<ul><li>Resource management plan</li></ul></li><li>Project documents<ul><li>Project team assignments</li><li>Team charter</li><li>Issue log</li><li>Lesson learned register</li></ul></li><li>Work Performance Reports</li><li>Team performance assessments</li><li>Enterprise Environmental Factors</li><li>Organizational Process Assets</li></ul><h3 id="b-Manage-Team">b. Manage Team</h3><ul><li>The process of tracking team member performance, providing feedback, resolving issues, and managing team changes to optimize project performance.\</li><li>Việc này được làm trong suốt dự án</li><li>Bằng cách:<ul><li>Thường xuyên quan sát và trao đổi với các thành viên trong nhóm</li><li>Đánh giá hiệu suất của thành viên trong nhóm và đưa ra phản hồi mang tính xây dựng</li><li>Giúp giải quyết các vấn đề và xung đột, ảnh hưởng đến hành vi của nhóm</li><li>Quản lý các thay đổi của nhóm, giải phóng hoặc tuyển dụng thành viên trong nhóm khi cần thiết</li></ul></li></ul><h3 id="c-Tools-Techniques-v5">c. Tools &amp; Techniques</h3><ul><li>Emotional Intelligence</li><li>Influencing</li><li>Leadership</li><li>Conflict Management (nên tìm hiểu kỹ)</li><li>Decision making</li><li>Project management information system (PMIS)</li></ul><h3 id="d-Outputs-v5">d. Outputs</h3><ul><li>Change requests</li><li>Project management plan updates<ul><li>Resource management plan.</li><li>Schedule baseline.</li><li>Cost baseline.</li></ul></li><li>Project document updates<ul><li>Project team assignments.</li><li>Issue log.</li><li>Lessons learned register</li></ul></li><li>Enterprise environmental factors</li></ul><h2 id="6-Control-Resources">6. Control Resources</h2><h3 id="a-Inputs-v6">a. Inputs</h3><ul><li>Project management plan<ul><li>Resource management plan</li></ul></li><li>Project documents<ul><li>Resource requirements</li><li>Physical resource assignments</li><li>Resource breakdown structure</li></ul></li><li>Project documents<ul><li>Project schedule</li><li>Issue log</li><li>Lessons learned register</li><li>Risk register</li></ul></li><li>Work performance data</li><li>Agreements</li><li>Organizational Process Assets</li></ul><h3 id="b-Control-Resources">b. Control Resources</h3><ul><li>The process of ensuring that the physical resources assigned and allocated to the project are available as planned,as well as monitoring the planned versus actual utilization of resources and taking corrective action as necessary.</li><li>Việc này được làm trong suốt dự án</li><li>Bằng cách:<ul><li>Monitoring resource expenditures</li><li>Ensuring that resources are used and released according to the plan and project needs</li><li>Review actual resources have been used to date and what is still needed.</li><li>Identifying and dealing with resource shortage/surplus in a timely manner,</li><li>Managing the actual changes as they occur.</li><li>Influencing the factors that can create resources utilization change</li><li>Updating resource allocation</li></ul></li></ul><h3 id="c-Tools-Techniques-v6">c. Tools &amp; Techniques</h3><ul><li>Problem solving</li><li>Performance reviews</li><li>Alternatives analysis</li><li>Cost-benefit analysis</li><li>Trend analysis</li><li>Influencing</li><li>Negotiation</li><li>Project management information system (PMIS)</li></ul><h3 id="d-Outputs-v6">d. Outputs</h3><ul><li>Work performance information</li><li>Change requests</li><li>Project management plan updates<ul><li>Resource management plan.</li><li>Schedule baseline.</li><li>Cost baseline.</li></ul></li><li>Project documents updates<ul><li>Physical resource assignments: records the material, equipment, supplies, locations, and other physical resources that will be used during the project.</li><li>Resource breakdown structure.</li><li>Assumption log.</li><li>Issue log.</li><li>Lessons learned register.</li><li>Risk register.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pmp </tag>
            
            <tag> Resource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP Integration</title>
      <link href="/Book/2023/07/06/integration/"/>
      <url>/Book/2023/07/06/integration/</url>
      
        <content type="html"><![CDATA[<ul><li>Project Integration Management là dành riêng cho project managers. Không được ủy quyền hoặc chuyển giao cho ai.</li></ul><h2 id="1-Develop-Project-Charter">1. Develop Project Charter</h2><h3 id="a-Inputs">a. Inputs</h3><ul><li>Business Documents<ul><li>Business Case</li><li>Benefits management plan</li></ul></li><li>Agreements<ul><li>A contract is an input to this process, if the project is being done for an external customer</li><li>Memorandums of understanding (MOUs)</li><li>Service level agreements (SLA)</li><li>Letter of agreements</li><li>Letters of intent,</li><li>Verbal agreements, email, or other written agreements.</li></ul></li><li>Enterprise Environmental Factors</li><li>Organizational Process Assets</li></ul><h3 id="b-Develop-Project-Charter">b. Develop Project Charter</h3><ul><li>Là việc tạo ra tài liệu để chính thức công nhận sự tồn tại của dự án. Đồng thời trao quyền cho PM để sử dụng cácorganizational resources vào các hoạt động dự án</li><li>Diễn ra trong 1 dự án hoặc giai đoạn trước khi nó chính thức</li><li>Do Project Sponsor và PM phối hợp làm. Nhưng sẽ do Project Sponsor phát hành.</li><li>Đánh giá thành công của dự án thông qua việc đáp ứng các project objectives.</li><li>Các project objectives nên được ghi lại và được sự đồng thuận từ các stakeholders</li></ul><h3 id="c-Tools-Techniques">c. Tools &amp; Techniques</h3><ul><li><p>Expert Judgment</p></li><li><p>Meetings</p></li><li><p>Data Gathering</p><ul><li>Interview</li><li>Brainstorming…</li></ul></li><li><p>Interpersonal and team skills</p></li></ul><h3 id="d-Outputs">d. Outputs</h3><ul><li>Project Charter<ul><li>Ghi lại business need và demand</li><li>Mô tả về requirements của product</li><li>Chính thức hóa việc trao quyền cho OM</li><li>Đủ rộng để không cần thay đổi</li></ul></li><li>Assumption log</li></ul><h2 id="2-Develop-Project-Management-Plan">2. Develop Project Management Plan</h2><h3 id="a-Inputs-v2">a. Inputs</h3><ul><li>Project charter</li><li>Outputs from processes: planning processes, other processes…</li><li>Enterprise Environmental Factors</li><li>Organizational Process Assets</li></ul><h3 id="b-Develop-Project-Management-Plan">b. Develop Project Management Plan</h3><ul><li>Là quá trình defining, preparing, coordinating (điều phối) tất cả các plan components và hợp nhất chúng vào integrated project management plan.</li><li>Việc này được làm 1 lần hoặc tại các thời điểm đjowjc xác định trước trong dự án</li><li>Bằng cách:<ul><li>Điều chỉnh các project management process để đáp ứng được project needs (điều chỉnh sự phụ thuộc, tương tác giữa các quy trình)</li><li>Phát triển các technical và management details ddeerr đưa vào project management plan</li><li>Xác định các project documents sẽ phải tuân thủ theo change control process</li><li>Xác định mức độ của configuration management để áp dụng cho project</li></ul></li></ul><h3 id="c-Tools-Techniques-v2">c. Tools &amp; Techniques</h3><ul><li>Meeting Management</li><li>Focus groups</li><li>Conflict management</li><li>Facilitation</li><li>Brainstorming</li><li>Interviews</li><li>Expert Judgment</li><li>Checklists</li><li>Project kick-off meeting:<ul><li>Mục đích của nó truyền đạt các project objectives, đạt được commitment của cả team với project và giải thiwcsh các roles, responsibilities của các stakeholder</li><li>Buổi này thường được tạo khi kết thúc việc lập kế hoạch và bắt đầu executing</li></ul></li></ul><h3 id="d-Outputs-v2">d. Outputs</h3><ul><li>Project Management Plan<ul><li>The project management plan defines how the project is executed, monitored and controlled, and closed.</li><li>Tích hợp và hợp nhất tất cả các subsidiary plans, baselines, Change management plan, Configuration management plan…<ul><li>subsidiary plans bao gồm: Stakeholder management plan, Communications management plan, Scope management plan…</li><li>baselines bao gồm: Scope baseline, Schedule baseline, Cost baseline</li></ul></li><li>Nó được xây dựng dần dần qua những lần updates và sẽ được controlled and approved thông qua Perform Integrated Change Control process.</li></ul></li></ul><h2 id="3-Direct-and-Manage-Project-Work">3. Direct and Manage Project Work</h2><h3 id="a-Inputs-v3">a. Inputs</h3><ul><li>Project Management Plan</li><li>Project documents</li><li>Approved Change Request</li><li>Enterprise Environmental Factors</li><li>Organizational Process Assets</li></ul><h3 id="b-Direct-and-Manage-Project-Work">b. Direct and Manage Project Work</h3><ul><li>Là quá trình leading và performing công việc đã defined trong project management plan và thực hiện các thay đổi đã được approved để đạt được project’s objectives</li><li>Việc này được làm xuyên suốt dự án</li></ul><h3 id="c-Tools-Techniques-v3">c. Tools &amp; Techniques</h3><ul><li><p>Project Management Information System (PMIS): là hệ thống thông tin bao gồm các công cụ và kỹ thuật được sử dụng để thu thập,tích hợp và phổ biến các kết quả đầu ra của các quy trình quản lý dự án. Nó là 1 phần của EEF</p></li><li><p>Expert Judgment</p></li><li><p>Meetings</p></li></ul><h3 id="d-Outputs-v3">d. Outputs</h3><ul><li>Deliverables</li><li>Work Performance Data</li><li>Change Requests<ul><li>Corrective actions là reactive measures. Nó được thực hiện khi dự án đi lệch với những baseline đã đề ra</li><li>Preventive actions là proactive measures. Là hành động để ngăn chặn vấn đề trong tương lai. Theo PMI preventive actions được ưu tiên hơn</li><li>Defect Repair là hành động sửa chữa khi deliverables không đáp ứng được yêu cầu và có thể sửa chữa được. Nếu không thể sửa chữa thì sẽ phải rework</li></ul></li><li>Issue log: là tài liệu ghi lại tất cả các issues để lưu trữ và tracking nó. Nó được cập nhật nhờ các hoạt động monitoring và control</li><li>Project management plan updates</li><li>Project documents updates</li><li>Organizational process assets updates</li></ul><h2 id="4-Manage-Project-Knowledge">4. Manage Project Knowledge</h2><h3 id="a-Inputs-v4">a. Inputs</h3><ul><li>Deliverables</li><li>Project management plan</li><li>Project documents</li><li>Enterprise Environmental Factors</li><li>Organizational Process Assets</li></ul><h3 id="b-Manage-Project-Knowledge">b. Manage Project Knowledge</h3><ul><li>Quá trình này nhằm đảm bảo các kỹ năng, kinh nghiệm và chuyên môn của nhóm dự án và các bên liên quan khác được sử dụng trước, trong và sau dự án.</li><li>Việc này được làm xuyên suốt dự án</li></ul><h3 id="c-Tools-Techniques-v4">c. Tools &amp; Techniques</h3><ul><li><p>Knowledge management:</p><ul><li>The most important part of knowledge management is creating an atmosphere of trust so that people are motivated to share their knowledge</li><li>Face to face là cách hiệu quả để xây dựng mối quan hệ tin cậy để quản lý kiến thức</li></ul></li><li><p>Information management</p></li><li><p>Expert judgment</p></li><li><p>Interpersonal and team skills</p><ul><li>Active listening</li><li>Facilitation</li><li>Networking</li><li>Leadership</li><li>Political awareness:</li></ul></li></ul><h3 id="d-Outputs-v4">d. Outputs</h3><ul><li>Lessons learned register</li><li>Project management plan updates</li><li>Organizational process assets updates</li></ul><h2 id="5-Monitor-and-Control-Project-Work">5. Monitor and Control Project Work</h2><h3 id="a-Inputs-v5">a. Inputs</h3><ul><li><p>Work performance information</p></li><li><p>Project Management Plan</p></li><li><p>Project documents</p><ul><li>Schedule forecasts</li><li>Cost forecasts</li><li>Quality reports</li><li>Risk report</li></ul></li><li><p>Agreements</p></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Monitor-and-Control-Project-Work">b. Monitor and Control Project Work</h3><ul><li>The process of tracking, reviewing, and reporting the overall progress to meet the performance objectives defined in the project management plan.</li><li>Việc này được làm xuyên suốt dự án</li></ul><h3 id="c-Tools-Techniques-v5">c. Tools &amp; Techniques</h3><ul><li><p>Data analysis</p><ul><li>Earned value analysis.</li><li>Variance analysis.</li><li>Root cause analysis.</li><li>Alternatives analysis.</li><li>Cost-benefit analysis.</li><li>Trend analysis.</li></ul></li><li><p>Decision making</p></li><li><p>Expert Judgment</p></li><li><p>Meetings</p></li></ul><h3 id="d-Outputs-v5">d. Outputs</h3><ul><li>Work Performance Reports</li><li>Change Requests</li><li>Project Management Plan updates</li><li>Project documents updates</li></ul><h2 id="6-Perform-Integrated-Change-Control">6. Perform Integrated Change Control</h2><h3 id="a-Inputs-v6">a. Inputs</h3><ul><li><p>Project management plan</p></li><li><p>Project documents</p></li><li><p>Work performance reports</p></li><li><p>Change Request</p></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Perform-Integrated-Change-Control">b. Perform Integrated Change Control</h3><ul><li>The process of reviewing all change • requests; approving changes and managing changes to deliverables,project documents, and the project management plan, and communicating the decisions.</li><li>Việc này được làm xuyên suốt dự án</li><li><a href="/Book/2023/06/25/change-request/" title="change request">Các bước thực hiện change request.</a></li></ul><h3 id="c-Tools-Techniques-v6">c. Tools &amp; Techniques</h3><ul><li>Change control tools</li><li>Alternatives analysis</li><li>Cost-benefit analysis</li><li>Decision making</li><li>Expert Judgment</li><li>Meetings</li></ul><h3 id="d-Outputs-v6">d. Outputs</h3><ul><li>Approved Change Requests</li><li>Project Management Plan Updates</li><li>Project Document Updates</li></ul><h2 id="7-Close-Project-or-Phase">7. Close Project or Phase</h2><h3 id="a-Inputs-v7">a. Inputs</h3><ul><li>Project charter</li><li>Project management plan</li><li>Accepted deliverables</li><li>Project documents</li><li>Business documents</li><li>Agreements</li><li>Procurement documentation</li><li>Organizational Process Assets</li></ul><h3 id="b-Close-Project-or-Phase">b. Close Project or Phase</h3><ul><li>Close project or phase is the process of finalizing all activities for the project, phase, or contract.</li><li>Công việc theo kế hoạch đã hoàn thành</li><li>Thông tin về project và phase được lưu trữ</li><li>Các nguồn lực được release</li><li>Việc này được làm 1 lần hoặc tại 1 thời điểm xác định</li></ul><h3 id="c-Tools-Techniques-v7">c. Tools &amp; Techniques</h3><ul><li>Document analysis</li><li>Variance analysis.</li><li>Trend analysis</li><li>Regression analysis</li><li>Expert judgment</li><li>Meetings</li></ul><h3 id="d-Outputs-v7">d. Outputs</h3><ul><li>Final Product, Service, or Result Transition</li><li>Final report</li><li>Project documents updates</li><li>Organizational Process Assets (Updates)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pmp </tag>
            
            <tag> Integration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP Quality</title>
      <link href="/Book/2023/07/01/quality/"/>
      <url>/Book/2023/07/01/quality/</url>
      
        <content type="html"><![CDATA[<ul><li>product attribute là một characteristic (đặc điểm) xác định 1 sản phẩm cụ thể:<ul><li>Tangible Attributes: Thuộc tính hữu hình như size, color, smell,</li><li>Intangible Attributes: Thuộc tính vô hình như price, beauty, reliability…</li></ul></li></ul><p><img src="/images/pmp/accuracy-precision.png" alt="accuracy-precision"></p><ul><li><p>Accuracy: Là độ chính xác nhưng các giá trị đo gần với giá trị đích</p></li><li><p>Precision: Là độ chính xác mà các giá trị của các phép đo lặp lại được nhóm lại gần nhau và có độ phân tán thấp. HIg Precision không có nghĩalà các phép đo gần với giá trị đích, nó chỉ có nghĩa là các phép đo chỉ gần nhau và chúng có thể gần hoặc không gần giá trị đích</p></li><li><p>Quality: The degree to which a set of inherent characteristics fulfills requirements.(Quality là mức độ mà một tập hợp các đặc điểm vốn có đáp ứng các yêu cầu.). VD: Nokia 110i là điện thoại grade thấp nhưng chất lượng cao vìsử dụng rất bền đủ tính năng nghe gọi theo đúng nhu mô tả, không bị lỗi vặt. Điện thoại thông tin có grade cao nhưng bị lỗicảm ứng, chơi game bị đơ máy, loa bị rè thì là sản phẩm chất lượng kém vì nó không hoạt động tốt như trong mô tả</p></li><li><p>Grade: A category or rank used to distinguish items that have the same functional use but do not share the same requirements for quality. (Grade là một danh mục hoặc xếp hạng được sử dụng để phân biệt các mục có cùng chức năng sử dụng nhưng không chia sẻcùng các yêu cầu về chất lượng.)</p></li><li><p>Low quality luôn là một vấn đề, nhưng low grade thì không là vấn đề.</p></li></ul><p><img src="/images/pmp/qa-qc.png" alt="qa-qc"></p><ul><li><p>Six Sigma:</p><ul><li>1σ = 68.25%</li><li>2σ = 95.46%</li><li>3σ = 99.73%</li><li>6σ = 99.99966%</li></ul></li><li><p>Lean Manufacturing</p></li><li><p>Just In Time (JIT)</p></li><li><p>Kaizen</p></li></ul><h2 id="1-Plan-Quality-Management">1. Plan Quality Management</h2><h3 id="a-Inputs">a. Inputs</h3><ul><li><p>Project charter</p></li><li><p>Project management plan• Stakeholder engagement plan.• Requirements management plan.• Scope baseline.</p></li><li><p>Risk management plan.</p></li><li><p>Project documents</p><ul><li>Stakeholder register.</li><li>Requirements documentation.</li><li>Requirements traceability matrix.</li><li>Assumption log.</li><li>Risk register.</li></ul></li></ul><h3 id="b-Plan-Quality-Management">b. Plan Quality Management</h3><ul><li><p>Là quá trình xác định các yêu cầu, tiêu chuẩn chất lượng cho dự án và các deliverables. Đồng thời tạo tài liệu chỉ ra phương pháp tuân thủ với cácyêu cầu, tiêu chuẩn chất lượng đó</p></li><li><p>Bằng cách:</p><ul><li>Xác định các quality objectives phù hợp với mong đợi của khách hàng</li><li>Xác định các quality standards được áp dụng</li><li>Phân tích cost-benefit để đáp ứng quality standards</li><li>Lập kế hoạch quản lý dự án và project control activities trong planned costs và the stated benefits</li><li>Phân định responsibilities, authority, and resources cho quality management</li><li>Xác định project requirements, project deliverables và acceptance criteria</li><li>Thiết lập quality metrics (các chỉ số chất lượng) và cách đo lường chất lượng</li></ul></li><li><p>Quá trình này được làm 1 lần hoặc tại 1 thời điểm được xác định trước trong dự án. Thường song song với các quá trình lập kế hoạch khác</p></li></ul><h3 id="c-Tools-Techniques">c. Tools &amp; Techniques</h3><ul><li>Cost of Quality (COQ)<ul><li>Cost of conformance: Money spent during the project to avoid failures<ul><li>Prevention costs: build a quality product</li><li>Appraisal costs: assess the quality</li></ul></li><li>Cost of non conformance: Money spent during and after the project because of failures<ul><li>Internal failure costs: failures found by the project</li><li>External failure costs: failures found by the customer</li></ul></li></ul></li><li>Cost Benefits Analysis<ul><li>Marginal analysis</li></ul></li><li>Test and inspection planning</li><li>Flowcharting</li><li>Matrix diagram</li><li>Benchmarking</li><li>Expert judgment</li></ul><h3 id="d-Outputs">d. Outputs</h3><ul><li><p>Quality Management Plan</p></li><li><p>Quality Metrics</p></li><li><p>Project Management Plan Updates</p><ul><li>Scope baseline</li><li>Risk management plan</li></ul></li><li><p>Project Documents Updates</p><ul><li>Stakeholder register.</li><li>Requirements traceability matrix.</li><li>Lessons learned register.</li><li>Risk register.</li></ul></li></ul><h2 id="2-Manage-Quality">2. Manage Quality</h2><h3 id="a-Inputs-v2">a. Inputs</h3><ul><li><p>Project management plan</p><ul><li>Quality management plan</li></ul></li><li><p>Project documents</p><ul><li>Quality control measurements</li><li>Quality metrics</li><li>Risk report</li><li>Lessons learned register</li></ul></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Manage-Quality">b. Manage Quality</h3><ul><li>Là quá trình thực hiện các hoạt động thực thi về chất lượng, tích hợp chính sách chất lượng của tổ chức vào dự án theo như quality management plan.</li><li>Việc này được làm xuyên suốt trong dự án</li></ul><h3 id="c-Tools-Techniques-v2">c. Tools &amp; Techniques</h3><ul><li>Quality Checklists</li><li>Quality Audits</li><li>Quality improvement methods</li><li>Process analysis</li><li>Design For X (DfX)</li><li>Document analysis</li><li>Problem solving</li><li>Decision making</li><li>Root cause analysis (RCA).</li><li>Alternatives analysis.</li></ul><h3 id="d-Outputs-v2">d. Outputs</h3><ul><li><p>Quality reports</p></li><li><p>Test and evaluation documents</p></li><li><p>Change requests</p></li><li><p>Project management plan updates</p><ul><li>Scope baseline.</li><li>Schedule baseline.</li><li>Cost baseline.</li><li>Quality management plan.</li></ul></li><li><p>Project documents updates</p><ul><li>Issue log</li><li>Lessons learned register</li><li>Risk register</li></ul></li></ul><h2 id="3-Control-Quality">3. Control Quality</h2><h3 id="a-Inputs-v3">a. Inputs</h3><ul><li>Project management plan</li><li>Project documents</li><li>Approved change requests</li><li>Deliverables</li><li>Work performance data</li><li>Enterprise Environmental Factors (EEF)</li><li>Organizational Process Assets (OPA)</li></ul><h3 id="b-Control-Quality">b. Control Quality</h3><ul><li><p>Control Quality vs Validate Scope</p></li><li><p>Quy trình giám sát và lưu lại kết quả của việc quality management.</p></li><li><p>Bằng cách:</p><ul><li>Đo lường tính completeness (đầy đủ), compliance (tuần thủ), and fitness (phù hợp) để sử dụng sản phẩm hoặc dịch vụ trước khi người dùng chấp nhận và giao hàng cuối cùng.</li><li>Đo lường tất cả các bước, thuộc tính và biến được sử dụng để xác minh sự phù hợp hoặc tuân thủ các thông số kỹ thuật đã nêu trong giai đoạn lập kế hoạch.</li></ul></li><li><p>Việc này được làm xuyên suốt trong dự án</p></li></ul><h3 id="c-Tools-Techniques-v3">c. Tools &amp; Techniques</h3><ul><li><p>Control Chart<img src="/images/pmp/control-chart.png" alt="control-chart.png"></p></li><li><p>Inspection</p></li><li><p>Testing/product evaluations</p></li><li><p>Statistical Sampling</p><ul><li>Attribute sampling</li><li>Variables sampling</li></ul></li><li><p>Quality Checklists</p></li><li><p>Checksheet</p></li><li><p>Histogram</p></li><li><p>Pareto Chart (80/20 Principles)</p></li><li><p>Root cause analysis</p></li><li><p>Cause and Effect diagram</p></li><li><p>Scatter Diagram</p></li><li><p>Meetings</p><ul><li>Approved change requests review</li><li>Retrospectives/lesson learned</li></ul></li><li><p>Questionnaires and Surveys</p></li></ul><h3 id="d-Outputs-v3">d. Outputs</h3><ul><li>Quality control measurements</li><li>Verified Deliverables</li><li>Work Performance Information</li><li>Change Requests</li><li>Project management plan updates</li><li>Project Document Updates</li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pmp </tag>
            
            <tag> quality </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP Change Request</title>
      <link href="/Book/2023/06/25/change-request/"/>
      <url>/Book/2023/06/25/change-request/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pmp/change-request.png" alt="change-request"></p><ul><li>CCB members may include stakeholders, managers, project team members, and others who may not have any connection to the project at hand.</li></ul><p>Quy trình 9 bước để thực hiện Change Request</p><h3 id="1-Understand-the-change">1. Understand the change</h3><h3 id="2-Prevent-unnecessary-changes">2. Prevent unnecessary changes</h3><ul><li>Nên chủ động loại những CR không cần thiết, không mang lại giá trị, hoặc mang lại giá trị không đáng kể nhưng chi phí phát triển lớn.</li></ul><h3 id="3-Identify-root-cause-of-change">3. Identify root cause of change</h3><ul><li>CR có thể xuất phát từ PM để điều chỉnh tăng hiệu quả sau khi so sánh kết quả thực tế với baseline</li><li>CR xuất phát từ clients, hay các stakeholders khác</li><li>PM cần xác định, tìm kiếm các CR này càng sớm càng tốt vì chi phí thay đổi sẽ giảm đi</li></ul><h3 id="4-Look-at-the-impact-of-the-change">4. Look at the impact of the change</h3><ul><li>Đánh giá về việc nếu thực hiện CR này nó sẽ ảnh hưởng đến scope, schedule của các dự án thế nào?</li></ul><h3 id="5-Perform-Integrated-Change-Control">5. Perform Integrated Change Control</h3><h4 id="a-Assess-the-change">a. Assess the change</h4><p>Đánh giá sự tác động của CR đến tất cả các phần:</p><ul><li>CR có nằm trong Project Charter? Nếu không thì nó không lên là CR mà có thể nằm trong 1 dự án mới</li><li>CR có lợi cho dự án không? Nếu không thì không nên Approve</li></ul><p>Chú ý: Với thay đổi về Risk Responses sẽ được xử lý như Implement Risk Responses chứ không phải Perform Integrated Change Control</p><h4 id="b-Look-for-options">b. Look for options</h4><h4 id="c-Change-is-approved-or-rejected">c. Change is approved or rejected</h4><ul><li>Những thay đổi liên quan đến baseline, project management, project charter… sẽ cần được kiểm soát bởi Change Control Board (CCB) và/hoặc cả sponsor.</li><li>Những CR được approved sẽ được thực hiện trong Direct and Manage Project Work, Control Quality, Control Procurements</li></ul><h3 id="6-Update-the-status-of-the-change-in-the-change-control-system">6. Update the status of the change in the change control system</h3><ul><li>Cần làm điều này để mọi người biết CR đã được approved.</li><li>Nếu CR bị rejected thì cần ghi thêm lý do.</li></ul><h3 id="7-Adjust-the-project-management-plan-and-baseline">7. Adjust the project management plan and baseline</h3><ul><li>Các tài liệu liên quan đến CR cần được cập nhật tương ứng</li></ul><h3 id="8-Notify-stakeholders-affected-by-the-change">8. Notify stakeholders affected by the change</h3><h3 id="9-Manage-the-project-to-the-new-project-management-plan">9. Manage the project to the new project management plan</h3>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pmp </tag>
            
            <tag> Change Request </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP Cost</title>
      <link href="/Book/2023/06/21/cost/"/>
      <url>/Book/2023/06/21/cost/</url>
      
        <content type="html"><![CDATA[<p>Các loại Cost:</p><ul><li>Direct costs</li><li>Indirect costs:</li><li>Variable costs</li><li>Fixed costs</li></ul><h2 id="1-Plan-Cost-Management">1. Plan Cost Management</h2><h3 id="a-Inputs">a. Inputs</h3><ul><li><p>Project charter</p></li><li><p>Project management plan</p><ul><li>Scope and schedule baseline</li><li>Other information: related cost, risk</li></ul></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Plan-Cost-Management">b. Plan Cost Management</h3><ul><li><p>Là quá trình xác định cách estimate, lên ngân sách, managed, monitored và controller</p></li><li><p>Việc này được làm 1 lần hoặc tại 1 thời điểm xác định nào đó</p></li></ul><h3 id="c-Tools-Techniques">c. Tools &amp; Techniques</h3><ul><li>Alternative analysis</li><li>Expert Judgment</li><li>Meetings</li></ul><h3 id="d-Outputs">d. Outputs</h3><ul><li>Cost management plan<ul><li>Level of Accuracy: Rough Order of Magnitude (ROM) thường là -25% to +75%.</li></ul></li></ul><p><img src="/images/pmp/cost-management-plan.png" alt="cost-management-plan"></p><h2 id="2-Estimate-Costs">2. Estimate Costs</h2><h3 id="a-Inputs-v2">a. Inputs</h3><ul><li><p>Project Management Plan</p><ul><li>Scope baseline</li><li>Cost Management Plan: Method and level of accuracy</li><li>Quality Management Plan: Quality objectives</li><li>Resource management plan</li></ul></li><li><p>Project Document</p><ul><li>Project schedule</li><li>Resource requirements.</li><li>Risk register</li><li>Lessons learned register.</li></ul></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Estimate-Costs">b. Estimate Costs</h3><ul><li><p>Là quá trình estimate cost cần thiết để hoàn thành các project activities</p></li><li><p>Actual cost thường sẽ cao hơn plan cost</p></li><li><p>Việc này được làm định kỳ trong suốt dự án</p></li></ul><h3 id="c-Tools-Techniques-v2">c. Tools &amp; Techniques</h3><ul><li><p>Analogous Estimating</p></li><li><p>Parametric Estimating</p></li><li><p>Bottom-up Estimating</p></li><li><p>Three Point Estimates (PERT)</p></li><li><p>Cost of Quality (COQ)</p></li><li><p>Contingency Reserve (dự phòng rủi ro)</p></li><li><p>Alternative analysis: Xem xét việc tự làm so với đi mua, đi mua so với đi thuê, thuê so với dùng chung…</p><ul><li>Value Analysis (Value Engineering)</li><li>Life Cycle Cost: Chú ý việc chọn phương án giảm bớt features để giảm cost nhưng khi sẽ khó khăn trong việc sử dụngcó thể sẽ làm tăng chi phí operations và từ đó tổng chi phí có thể sẽ bị tăng.</li></ul></li><li><p>Project management information system (PMIS)</p></li></ul><h3 id="d-Outputs-v2">d. Outputs</h3><ul><li>Cost Estimates</li><li>Basis of estimates: Chi tiết hỗ trợ để làm rõ việc estimate được tạo ra như thế nào.</li><li>Project Document Updates<ul><li>Assumption log.</li><li>Lessons learned register.</li><li>Risk register.</li></ul></li></ul><h2 id="3-Determine-Budget">3. Determine Budget</h2><h3 id="a-Inputs-v3">a. Inputs</h3><ul><li>Project management plan<ul><li>Cost management plan</li><li>Resource management plan</li><li>Scope baseline</li></ul></li><li>Project documents<ul><li>Project schedule</li><li>Cost estimates</li><li>Basis of estimates</li><li>Risk register</li></ul></li><li>Business documents<ul><li>Business case</li><li>Benefits management plan</li></ul></li><li>Agreements</li><li>Enterprise Environmental Factors (EEF)</li><li>Organizational Process Assets (OPA)</li></ul><h3 id="b-Determine-Budget">b. Determine Budget</h3><ul><li><p>Quá trình tạo ra cost baseline từ việc tổng hợp estimate cost của những activities lại với nhau</p></li><li><p>Việc này được làm 1 lần hoặc tại 1 thời điểm xác định nào đó</p></li></ul><h3 id="c-Tools-Techniques-v3">c. Tools &amp; Techniques</h3><ul><li><p>Historical Relationships</p></li><li><p>Cost Aggregation</p></li><li><p>Management reserves:</p><ul><li>Mục đích để giair quyết những unknown risks có thể ảnh hưởng đến dự án.</li><li>Nó nằm ngoài cost baseline nhưng là 1 phần của project budget<img src="/images/pmp/management-reserves.png" alt="management-reserves"></li></ul></li><li><p>Funding Limit Reconciliation</p></li><li><p>Financing</p></li></ul><h3 id="d-Outputs-v3">d. Outputs</h3><ul><li>Cost Baseline</li><li>Project Funding Requirements:<ul><li>Cấp vốn thường được thực hiện theo từng bước chứ không liên tục</li></ul></li><li>Project Document Updates<ul><li>Cost estimates</li><li>Project schedule</li><li>Risk register</li></ul></li></ul><h2 id="4-Control-Costs">4. Control Costs</h2><h3 id="a-Inputs-v4">a. Inputs</h3><ul><li><p>Work performance data</p></li><li><p>Project management plan</p><ul><li>Cost Management Plan</li><li>Cost Baseline</li><li>Performance measurement baseline</li></ul></li><li><p>Project documents</p><ul><li>Lessons learned register</li></ul></li><li><p>Project funding requirements</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Control-Costs">b. Control Costs</h3><ul><li>Là quá trình monitor dự án dựa vào cost baseline để đảm bảo chi phí không vượt quá budget cho phép</li><li>Việc này được làm trong suốt dự án</li></ul><h3 id="c-Tools-Techniques-v4">c. Tools &amp; Techniques</h3><ul><li><p>Earned Value Analysis</p><ul><li>Planned Value (PV): Ngân sách được chỉ định để hoàn thành công việc vào 1 ngày cụ thể</li><li>Earned Value (EV): Phần công việc thực tế thực hiện được</li><li>Actual Cost (AC): Chi phí thực tế của tất cả công việc được hoàn thành tới một thời điểm, thường là ngày dữ liệu</li><li>Budget at Completion (BAC): Tổng tất cả các ngân sách để thực hiện công việc</li><li>Earning Rules:<ul><li>0/100 method: Hoàn thành sẽ nhận 100%</li><li>50/50 method: Ứng trước 50%, 50% còn lại sẽ nhận khi hoàn thành</li><li>Milestones: Nhận theo các milestone đã định sẵn</li><li>Percent Complete: Nhận theo phần trăm hoàn thành công việc</li></ul></li></ul></li><li><p>Variance Analysis:</p><ul><li><p>SV (Schedule Variance) = EV - PV</p><ul><li>Chênh lệnh về tiến độ</li><li>Thời gian mà dự án sớm hoặc trễ hơn ngày chuyển giao kế hoạch, tại một điểm thời gian</li></ul></li><li><p>SPI (Schedule Performance Index) = EV/PV</p><ul><li>Chỉ số hiệu suất tiến độ</li><li>Một thước đo độ hiệu quả tiến độ</li></ul></li><li><p>CV (Cost Variance) = EV - AC</p><ul><li>Chênh lệch về chi phí.</li><li>Số tiền ngân sách thâm hụt hoặc thặng dư tại một thời điểm nhất định</li></ul></li><li><p>CPI (Cost Performance Index) = EV/AC</p><ul><li>Chỉ số hiệu suất chi phí</li><li>Thước đo độ hiệu quả chi phí của nguồn ngân sách</li></ul></li></ul></li><li><p>Trend analysis and Forecast</p><ul><li><p>Estimate at completion (EAC):</p><ul><li>Tổng chi phí dự kiến để hoàn thành toàn bộ các công việc</li><li>EAC may differ from Budget at Completion (BAC)</li><li>Nếu CPI là không đổi trong thời gian còn lại của dự án:  EAC = BAC/CPI</li><li>Nếu công việc tương lai được thực hiện theo kế hoạch như ban đầu: EAC = AC + BAC – EV</li><li>Nếu kế hoạch ban đầu không còn phù hợp: EAC = AC + ETC từ dưới lên</li><li>Nếu cả CPI và SPI cùng ảnh hưởng đến công việc còn lại: EAC = AC + [(BAC – EV)/(CPI x SPI)]</li></ul></li><li><p>Estimate to complete (ETC):</p><ul><li>Chi phí dự tính để hoàn thành các công việc còn lại của dự án.</li><li>Công việc đang theo kế hoạch: ETC = EAC – AC</li></ul></li><li><p>Variance At Completion (VAC) = BAC – EAC</p><ul><li>Dự báo số tiền thâm hụt ngân sách hoặc thặng dư khi hoàn thành dự án</li><li>Công việc đang theo kế hoạch: ETC = EAC – AC</li><li>Ước lượng lại công việc còn lại từ dưới lên: ETC = Reestimate<img src="/images/pmp/variance-analysis.png" alt="variance-analysis"></li></ul></li></ul></li><li><p>To Complete Performance Index (TCPI): Một thước đo về hiệu quả chi phí cần đạt được với các nguồn lực còn lại để đáp ứng mục tiêu quản lý cụ thể</p><ul><li>Hiểu quả cần được duy trì để hoàn thành kế hoạch TCPI = (BAC – EV) / (BAC – AC)</li><li>Hiệu quả cần được duy trì để hoàn thành EAC hiện tại. TCPI = (BAC – EV) / (EAC – AC)</li><li>TCPI &gt; 1: Khó hơn để hoàn thành</li><li>TCPI &lt; 1: Dễ hơn để hoàn thành<img src="/images/pmp/tcpi.png" alt="tcpi"></li></ul></li><li><p>Reserve analysis</p></li><li><p>Expert Judgment</p></li><li><p>Project management information system (PMIS)</p></li></ul><h3 id="d-Outputs-v4">d. Outputs</h3><ul><li><p>Work performance information</p></li><li><p>Cost forecasts</p><ul><li>EAC, ETC</li></ul></li><li><p>Change requests</p></li><li><p>Project document updates:</p><ul><li>Assumption log</li><li>Basis of estimate</li><li>Cost estimate</li><li>Risk register</li></ul></li><li><p>Project management plan updates</p><ul><li>Cost Baseline</li><li>Cost management plan</li><li>Performance Measurement Baseline (time, cost, scope baseline)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pmp </tag>
            
            <tag> cost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP schedule</title>
      <link href="/Book/2023/06/20/schedule/"/>
      <url>/Book/2023/06/20/schedule/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Milestone: là một thời điểm quan trọng của dự án. Nó chỉ là một moment in time. Nên duration luôn là 0</p></li><li><p>Murphy’s law</p></li><li><p>Padding:</p></li><li><p>Student Syndrome: Chờ đến cuối mới làm</p></li><li><p>Parkinson’s law: Mở rộng công việc để lấp đầy thời gian có sẵn</p></li></ul><h2 id="1-Plan-Schedule-Management">1. Plan Schedule Management</h2><h3 id="a-Inputs">a. Inputs</h3><ul><li><p>Project charter</p></li><li><p>Project management plan</p><ul><li>Scope management plan</li><li>Development approach</li></ul></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Plan-Schedule-Management">b. Plan Schedule Management</h3><ul><li><p>Thiết lập những policies, procedures, documentations để develop, managing, và controlling the project schedule.</p></li><li><p>Để project team và stakeholders biết được cách phát triển và quản lý schedule</p></li><li><p>Việc này được làm 1 lần hoặc tại 1 thời điểm xác định nào đó</p></li></ul><h3 id="c-Tools-Techniques">c. Tools &amp; Techniques</h3><ul><li>Alternatives analysis: Đánh giá các phương pháp khác nhau</li><li>Expert Judgment</li><li>Meetings</li></ul><h3 id="d-Outputs">d. Outputs</h3><ul><li>Schedule management plan<img src="/images/pmp/schedule-management-plan.png" alt="schedule-management-plan"></li></ul><h2 id="2-Define-Activities">2. Define Activities</h2><h3 id="a-Inputs-v2">a. Inputs</h3><ul><li><p>Project Management Plan</p><ul><li>Schedule Management Plan</li><li>Scope Baseline</li></ul></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Define-Activities">b. Define Activities</h3><ul><li><p>Là quá trình identifying và documenting những activities (tasks) để thực hiện việc tạo ra deliverables</p></li><li><p>Giúp cho việc estimate, scheduling, executing, monitoring, and controlling the project work.</p></li><li><p>Việc này được làm trong suốt dự án</p></li></ul><h3 id="c-Tools-Techniques-v2">c. Tools &amp; Techniques</h3><ul><li>Rolling wave planning</li><li>Decomposition: Khi có thể tracking, estimate và có thể giao cho 1 người làm thì có thể dừng việc phân tách</li><li>Expert Judgment</li></ul><h3 id="d-Outputs-v2">d. Outputs</h3><ul><li><p>Milestone List</p></li><li><p>Activity list</p></li><li><p>Activity attributes<img src="/images/pmp/activity-attributes.png" alt="activity-attributes"></p></li><li><p>Chang request</p></li><li><p>Project management plan updates</p><ul><li>Schedule baseline.</li><li>Cost baseline.</li></ul></li></ul><h2 id="3-Sequence-Activities">3. Sequence Activities</h2><h3 id="a-Inputs-v3">a. Inputs</h3><ul><li><p>Project management plan</p><ul><li>Schedule management plan</li><li>Scope baseline</li></ul></li><li><p>Project documents</p><ul><li>Milestone list</li><li>Activity List</li><li>Activity attributes</li><li>Assumption log</li></ul></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Sequence-Activities">b. Sequence Activities</h3><ul><li><p>Quá trình chuyển đổi danh sách các activities thành 1 chuỗi logic. Cụ thể, xác định sự phụ thuộc của các activities với nhau.Sau đó sắp xếp chúng bằng việc dùng diagram để tạo thành 1 realistic and achievable schedule.</p></li><li><p>Việc này được làm xuyên suốt trong dự án</p></li></ul><h3 id="c-Tools-Techniques-v3">c. Tools &amp; Techniques</h3><ul><li><p>Dependency Determination (xác định các phụ thuộc)</p><ul><li>Internal dependencies</li><li>External dependencies</li><li>Mandatory Dependencies (hard logic)</li><li>Discretionary dependencies (soft logic)</li></ul></li><li><p>Precedence Diagramming Method (PDM): 4 logical relationships:</p><ul><li>Finish-to-start (FS): most common type of relationship– Activity A: Predecessor– Activity B: Successor</li><li>Finish-to-finish (FF)</li><li>Start-to-start (SS)</li><li>Start-to-finish (SF): very rarely used</li></ul></li><li><p>Leads and Lags:</p><ul><li>Lead: Số thời gian mà task phía sau có thể thực hiện trước khi mà task phía trước hoàn thành (gối đầu)</li><li>Lag: Số thời gian phải chờ đợi để bắt đầu task phía sau, sau khi task phía trước hoàn thành. VD: Chỉ được sơn sau khi tường đã khô 1 tuần</li></ul></li><li><p>Project management information system (PMIS)</p></li></ul><h3 id="d-Outputs-v3">d. Outputs</h3><ul><li><p>Project Schedule Network Diagrams<img src="/images/pmp/project-schedule-network-diagrams.png" alt="project-schedule-network-diagrams"></p></li><li><p>Project Document Updates:Activity lists, Activity attributes, Milestone list, and Risk register.</p></li></ul><h2 id="4-Estimate-Activity-Duration">4. Estimate Activity Duration</h2><h3 id="a-Inputs-v4">a. Inputs</h3><ul><li><p>Project management plan</p><ul><li>Schedule management plan</li><li>Project scope baseline</li></ul></li><li><p>Project documents</p><ul><li>Milestone list</li><li>Activity list</li><li>Activity attributes</li><li>Assumption logs: assumption and constraints</li><li>Lessons learned register</li></ul></li><li><p>Project documents (cont)</p><ul><li>Project team assignments</li><li>Resource requirements: resource skill influence most activity duration</li><li>Resource breakdown structure</li><li>Resource calendars</li><li>Risk register</li></ul></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Estimate-Activity-Duration">b. Estimate Activity Duration</h3><ul><li><p>Ước tính khoảng thời gian cần để hoàn thành từng activity với số lượng resources được ước tính.</p></li><li><p>Việc này được làm xuyên suốt trong dự án</p></li></ul><h3 id="c-Tools-Techniques-v4">c. Tools &amp; Techniques</h3><ul><li><p>Analogous Estimating (Top-down):</p><ul><li>Sử dụng thông tin của những projects trước đó có các thông tin tương tự nhu new project.</li><li>Phương pháp này sẽ mất ít thời gian và chi phí để estimate hơn nhưng thường ít chính xác hơn.</li></ul></li><li><p>Parametric Estimating:</p><ul><li>Sử dụng dữ liệu lịch sử và các biến khác nên sẽ chính xác hơn Top-down</li><li>VD: 1 người làm 1 module hết 20 hours. Nên 10 modules người đó sẽ làm hết 200 hours.</li></ul></li><li><p>Bottom-up Estimating: Thời gian làm các công việc phía trên sẽ là tổng thời gian các công việc nhỏ phía dưới.</p></li><li><p>Three point estimates (PERT): Có 2 cách:</p><ul><li>Triangular distribution: E = (P + M + O) / 3</li><li>Beta distribution: E = (P + 4M + O) / 6</li></ul></li><li><p>Reserve Analysis (dự trữ dự phòng)</p></li><li><p>Alternatives analysis: Có nhiều cách để hoàn thành công việc. Phương pháp này giúp chọn cách tốt nhất để hoàn thành activity.</p></li></ul><h3 id="d-Outputs-v4">d. Outputs</h3><ul><li>Activity duration estimates</li><li>Basis of estimates</li><li>Project document updates<ul><li>Activity attributes</li><li>Assumptions</li><li>Lessons learned register.</li></ul></li></ul><h2 id="5-Develop-Schedule">5. Develop Schedule</h2><h3 id="a-Inputs-v5">a. Inputs</h3><ul><li><p>Project Management Plan</p><ul><li>Schedule Management Plan</li><li>Scope baseline</li></ul></li><li><p>Project documents</p></li><li><p>Agreement</p></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Develop-Schedule">b. Develop Schedule</h3><ul><li><p>Quá trình phân tích activity sequence, duration, resources requirement and constraints để tạo project schedule model</p></li><li><p>Một schedule có thể nhìn được và được chấp nhận sẽ làm cơ sở để xác định ngày bắt đầu, ngày kết thúc cho các activities, milestones</p></li><li><p>Lặp đi lặp lại trong suốt dự án</p></li><li><p>Critical path (đường găng): The critical path is the one with the longest duration, which is the shortest possible project duration.</p><ul><li>Có thể có nhiều critical path, và critical path có thể được thay đổi. Khi critical path<img src="/images/pmp/critical-path.png" alt="critical-path"></li></ul></li><li><p>Float (total float): the total amount of time that a scheduled activity may be delayed from its early start date without delaying the project finish date, or violation a schedule constraint</p></li><li><p>Free Float: the amount of time that a scheduled activity can be delayed without delaying the early start date of any immediately following scheduled activity.Free float can only occur when two or more activities share a common successor</p></li><li><p>Project Float: project float is the amount of time a project can be delayed without delaying the externally imposed project completion date required by the customer or management,or the date previously committed to by the project manager</p><p><img src="/images/pmp/network-diagram-nodes.png" alt="network-diagram-nodes"></p></li></ul><h3 id="c-Tools-Techniques-v5">c. Tools &amp; Techniques</h3><ul><li><p>Schedule Network Analysis</p></li><li><p>Critical Path Method (CPM)</p></li><li><p>Resource Optimization Techniques</p><ul><li><p>Resource leveling:</p><ul><li>Điều chỉnh activities để cân bằng nhu cầu về resource. Vì không có resource để bổ sung</li><li>Critical path bị thay đổi, thường sẽ tăng lên<img src="/images/pmp/resource-leveling.png" alt="resource-leveling"></li></ul></li><li><p>Resource Smoothing:</p><ul><li>Điều chỉnh các activities để phù hợp với số resources được xác định trước</li><li>Critical path sẽ không thay đổi, complete date có thể cũng không bị delay<img src="/images/pmp/resource-smoothing.png" alt="resource-smoothing"></li></ul></li></ul></li><li><p>Schedule Compression</p><ul><li>Crashing: Thêm resources vào để giải quyết các activities</li><li>Fast Tracking: Các activities được thực hiện parallel hoặc overlap</li></ul></li><li><p>What-If Scenario Analysis:</p><ul><li>Monte Carlo Simulation: Sử dụng máy tính để dự đoán</li></ul></li><li><p>Leads and Lags: Thay đổi thời gian bắt đầu của successor activities</p></li><li><p>Project management information systems</p></li></ul><h3 id="d-Outputs-v5">d. Outputs</h3><ul><li><p>Project Schedule: được trực quan hóa bằng:</p><ul><li><p>Milestone Charts (or Master schedule): Thường để report cho Senior Manager</p><p><img src="/images/pmp/milestone-chart.png" alt="milestone-chart"></p></li><li><p>Project Schedule Network Diagram (PDM)</p><p><img src="/images/pmp/network-diagram.png" alt="network-diagram"></p></li><li><p>Gantt Charts/ Bar Charts: Thường dùng report cho project team</p><p><img src="/images/pmp/gant-chart.png" alt="gant-chart"></p></li></ul></li><li><p>Schedule Baseline</p></li><li><p>Schedule Data</p></li><li><p>Project Calendar</p></li><li><p>Change request</p></li><li><p>Project management plan updates</p><ul><li>Schedule management plan</li><li>Cost Baseline</li></ul></li><li><p>Project document updates</p><ul><li>Resource requirements: resource leveling has significant effect on project resource requirement</li><li>Activity attributes</li><li>Calendar</li><li>Risk register</li></ul></li></ul><h2 id="6-Control-Schedule">6. Control Schedule</h2><h3 id="a-Inputs-v6">a. Inputs</h3><ul><li><p>Work performance data</p></li><li><p>Project management plan</p><ul><li>Scope baseline</li><li>Schedule baseline</li><li>Schedule management plan</li><li>Performance measurement baseline.</li></ul></li><li><p>Project documents</p><ul><li>Project schedule</li><li>Project calendar: allow different work periods for some activities</li><li>Schedule data</li><li>Resource calendar</li><li>Lessons learned register.</li></ul></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Control-Schedule">b. Control Schedule</h3><ul><li><p>Monitor status của dự án để có thể bám sát với schedule baseline</p></li><li><p>Việc này được thực hiện trong suốt dự án</p></li></ul><h3 id="c-Tools-Techniques-v6">c. Tools &amp; Techniques</h3><ul><li>Critical path method</li><li>Leads and lags</li><li>Resource optimization</li><li>Schedule compression</li><li>What-if scenario analysis</li><li>Project management information system (PMIS)</li><li>Earned Value Analysis</li><li>Performance Reviews</li><li>Variance analysis</li><li>Trend analysis</li></ul><h3 id="d-Outputs-v6">d. Outputs</h3><ul><li><p>Work Performance Information</p></li><li><p>Schedule Forecasts</p></li><li><p>Change Requests</p></li><li><p>Project Management Plan Update</p><ul><li>Schedule Management Plan</li><li>Schedule baseline</li><li>Cost baseline</li></ul></li><li><p>Project Document Updates</p><ul><li>Schedule data</li><li>Project schedule</li><li>Risk register</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pmp </tag>
            
            <tag> schedule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP Scope</title>
      <link href="/Book/2023/06/18/scope/"/>
      <url>/Book/2023/06/18/scope/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Constraint là những ràng buộc đã xảy ra và cần phải tính đến khi lên kế hoạch quản lý. Các constraint chủ yếu là những hạn chế của dự án.</p></li><li><p>Có 6 constraints trong dự án:</p><ul><li>Schedule</li><li>Scope</li><li>Cost</li><li>Quality</li><li>Resource</li><li>Risk</li></ul></li><li><p>Trong đó: Scope, Schedule, Cost được gọi là <strong>Project Triple Constraint.</strong> Tất cả các constraint này liên quan đến nhau. Nếu thay đổi 1 constraint,những constraints khác cũng sẽ ảnh hưởng</p></li><li><p>Product scope:</p><ul><li>Là chi tiết, tính năng, chức năng của sản phẩm.</li><li>Được xác định thông qua product requirements</li></ul></li><li><p>Project scope:</p><ul><li>Là tất cả các công việc cần làm trong dự án để có thể tạo ra được sản phẩm.</li><li>Được xác định thông qua project management plan</li><li>Project scope đôi khi được xem như là bao gồm cả Product scope.</li></ul></li><li><p>Scope Creep:</p><ul><li>Xảy ra khi thêm các yêu cầu của dự án, thay đổi mục tiêu vượt ngoài thỏa thuận ban đầu.</li><li>Những thay đổi này thường không chính thức.</li></ul></li><li><p>Gold plating:</p><ul><li>Xảy ra khi team thêm các tính năng mà team cho rằng sẽ giúp ích cho Users, thay vì tuân theo những gì được xác định trong scope baseline</li></ul></li></ul><h2 id="1-Plan-Scope-Management">1. Plan Scope Management</h2><h3 id="a-Inputs">a. Inputs</h3><ul><li><p>Project charter</p></li><li><p>Project management plan</p><ul><li>Project life cycle description.</li><li>Development approach.</li><li>Quality management plan.</li></ul></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Plan-Scope-Management">b. Plan Scope Management</h3><ul><li><p>Là quá trình cung cấp guidance và định hướng để manage scope trong suốt dự án</p></li><li><p>Stakeholders và project team cần biết được cách manage scope để tránh scope creep</p></li><li><p>Việc này được làm 1 lần hoặc tại 1 thời điểm xác định nào đó</p></li></ul><h3 id="c-Tools-Techniques">c. Tools &amp; Techniques</h3><ul><li><p>Alternatives analysis</p></li><li><p>Expert Judgment: Bất kỳ ai hay nhóm người có chuyên môn trong việc phát triển scope management plan</p></li><li><p>Meetings</p></li></ul><h3 id="d-Outputs">d. Outputs</h3><p><img src="/images/pmp/scope-management-plan.png" alt="scope-management-plan"></p><ul><li>Scope Management Plan:<ul><li>Describes how the scope will be defined, developed, monitored, controlled, and validated.</li></ul></li></ul><p><img src="/images/pmp/requirement-management-plan.png" alt="requirement-management-plan"></p><ul><li>Requirement Management Plan<ul><li>Describes how project and product requirements will be analyzed, documented, and managed</li></ul></li></ul><h2 id="2-Collect-Requirements">2. Collect Requirements</h2><h3 id="a-Inputs-v2">a. Inputs</h3><ul><li><p>Project charter</p></li><li><p>Project management plan</p><ul><li>Stakeholder engagement plan</li><li>Scope management plan</li><li>Requirements management plan</li></ul></li><li><p>Project documents</p><ul><li>Stakeholder Register</li><li>Assumption Log.</li><li>Lessons learned register</li></ul></li><li><p>Business documents</p></li><li><p>Agreements</p></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Requirement-Management-Processes">b. Requirement Management Processes</h3><ul><li><p>Thu thập thông tin yêu cầu của các stakeholders để làm cơ sở để define ra product scope và project scope</p></li><li><p>Việc này được làm 1 lần hoặc tại 1 thời điểm xác định nào đó</p></li><li><p>Các bước:</p><ul><li>Requirement elicitation (requirements gathering): là quá trình làm việc với stakeholder để khai thác yêu cầu của họ</li><li>Requirement analysis: Xác định xem các yêu cầu có rõ ràng, đầy đủ, có mâu thuẫn không để giải quyết chúng</li><li>Requirements specification/modeling: đặc tả những yêu cầu dưới những hình thức khác nhau: ngôn ngữ tự nhiên, use case, user stories…</li><li>Requirement Validation: Đảm bảo các yêu cầu có thể đáp ứng được các nhu cầu của stakeholders</li><li>Requirement Verification: Xác nhận Requirements specification dáp ứng tiêu chuẩn của tổ chức</li><li>Requirement Categorization: Phân loại các yêu cầu theo các quan điểm, nhu cầu của các đối tượng khác nhau</li><li>Requirement Prioritization: Xác định các yêu cầu nào của sản phẩm sẽ được đưa vào bản release nào.</li></ul></li></ul><h3 id="c-Tools-Techniques-v2">c. Tools &amp; Techniques</h3><ul><li><p>Document analysis</p></li><li><p>Interviews: lấy ý kiến về các yêu cầu sản phẩm, dự án, hoặc yêu cầu chung. Có thể thực hiện bằng cách phỏng vấn trực tiếp,thông qua email, điện thoại, thư từ.</p></li><li><p>Facilitated workshops: Tổ chức cuộc hội thảo gồm những người có quan điểm khác nhau, thảo luận và thống nhất về yêu cầu.</p></li><li><p>Focus Groups:Tổ chức cuộc họp nhóm từ 6 – 12 người tham gia để lấy những ý kiến và yêu cầu về sản phẩm và dự án.Người điều hành cuộc họp (moderator) sẽ điều khiển cuộc họp thảo luận về các ý tưởng trong nhóm</p></li><li><p>Brainstorming: Thu thập ý tưởng của mn tham gia. Chị tập trung vào số lượng, k phán xét các ý kiến. Để tránh việc bị ảnh hưởng bởi những ý kiến củanhững người có vị trí, trình độ cao hơn thì có thể sử dụng brainstorm writing.</p></li><li><p>Questionnaires and Surveys: Thường dùng với nhóm lớn bằng cách dùng các câu hỏi và hay survey để thu thập ý kiến</p></li><li><p>Benchmarking: Đưa ra điểm so sánh giữa các ý tưởng, việc này được thực hiện trong nội bộ hoặc công cụ bên ngoài.</p></li><li><p>Prototypes: Tạo bản prototypes về sản phẩm và nhận phản hồi của khách hàng về nó. Tiến hành cập nhật cho đến khi xác định yêu cầu rõ ràng</p></li><li><p>Context diagrams: trực quan mô tả phạm vi sản phẩm của một hệ thống kinh doanh (quy trình, thiết bị, hệ thống máy tính, vv), và làm thế nào người dùng và các hệ thống khác tương tác với nó.</p></li><li><p>Decision Making</p><ul><li>Voting - Majority (quá bán): trên 50% số người đồng ý sẽ được chọn</li><li>Voting - Plurality: Đa số lớn nhất. Thường được sử dụng khi số lượng options lớn hơn 2</li><li>Voting - Unanimity: Nhất trí toàn thể 100%<ul><li>Delphi Technique: Bỏ phiếu ẩn danh</li></ul></li><li>Autocratic: Cả nhóm người thảo luận nhưng quyết định sẽ do 1 cá nhân</li><li>Multi-criteria decision analysis: Phân tích quyết định dựa trên nhiều tiêu chí</li></ul></li><li><p>Observation/conversation: Quan sát thực tế những người sử dụng sản phẩm tiềm năng hoặc tham gia trực tiếp vào công việc để xác định yêu cầu.</p></li></ul><h3 id="d-Outputs-v2">d. Outputs</h3><ul><li>Requirements Documentation</li></ul><p><img src="/images/pmp/requirements-traceability-matrix.png" alt="requirements-traceability-matrix"></p><ul><li>Requirements Traceability Matrix: Là mạng lưới liên kết nguồn gốc của product requirement tới deliverables. Nó đảm bảo mỗiyêu cầu đều mang lại một giá trị cho product</li></ul><h2 id="3-Define-Scope">3. Define Scope</h2><h3 id="a-Inputs-v3">a. Inputs</h3><ul><li><p>Project charter</p></li><li><p>Project management plan</p><ul><li>Scope management plan</li></ul></li><li><p>Project documents</p><ul><li>Requirements documentation</li><li>Assumption Log.</li><li>Risk register</li></ul></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Define-Scope">b. Define Scope</h3><ul><li><p>Là quá trình phát triển mô tả chi tiết về project scope và product scope</p></li><li><p>Project team và stakeholders cần có sự hiểu chung về những gì có và không có trong dự án</p></li><li><p>Tùy vào project lifecycle mà quá trình này được xác định 1 lần hay lặp lại nhiều lần</p></li><li><p>Các bước:</p><ul><li>Chọn final project requirements từ requirements documentation</li><li>Tạo bản mô tả chi tiết về project và product.</li><li>Xác định cách tốt nhất để hoàn thành</li><li>Phân tích risks, assumptions, constraints để đảm bảo nó đẩy đủ hoạch thay đổi khi cần</li><li>Đạt được agreement và acceptance criteria</li></ul></li></ul><h3 id="c-Tools-Techniques-v3">c. Tools &amp; Techniques</h3><ul><li>Product Analysis</li><li>Alternative analysis: Tạo và phân tích các cách tiếp cận khác nhau</li><li>Multi-criteria decision analysis</li><li>Facilitation</li></ul><h3 id="d-Outputs-v3">d. Outputs</h3><ul><li><p>Project Scope Statement:</p><ul><li>Bao gổm toàn bộ scope, bao gồm cả project scope và product scope</li><li>It helps to create a common understanding among stakeholders (avoid scope creep).</li><li>It may contain explicit scope exclusions that can assist in managing stakeholder expectations.</li><li>The project team and the project stakeholders need to agree to the scope statement before the project execution.</li></ul></li><li><p>Project Document Updates</p><ul><li>Assumption log.</li><li>Stakeholder register</li><li>Requirements documentation</li><li>Requirements traceability matrix</li></ul></li></ul><h2 id="4-Create-WBS">4. Create WBS</h2><h3 id="a-Inputs-v4">a. Inputs</h3><ul><li><p>Project management plan</p><ul><li>Scope management plan</li></ul></li><li><p>Project documents</p><ul><li>Requirements documentation</li><li>Project scope statement</li></ul></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Create-WBS">b. Create WBS</h3><ul><li><p>Là quá trình decomposing công việc dự án thành các công việc nhỏ hơn, dễ quản lý hơn</p></li><li><p>Dễ dàng cho việc estimate, allocate resources, tracking performance</p></li><li><p>Dễ nhìn một cách trực quan để stakeholders dễ hiểu hơn</p></li><li><p>WBS xác định nhưng việc gì sẽ được thực hiện chứ không phải làm như nào, hay khi nào.</p></li><li><p>WBS có thể được sử dụng để assigning responsibilities</p></li><li><p>Việc này được làm 1 lần hoặc tại 1 thời điểm xác định nào đó</p></li><li><p>Work package là một tập hợp các activities để tạo ra deliverables.</p></li></ul><h3 id="c-Tools-Techniques-v4">c. Tools &amp; Techniques</h3><ul><li>Decomposition<ul><li><p>WBS can be organized by:– Project phases– Major deliverables and subprojects– Combination approach</p></li><li><p>WBS may be created through:– Top-down: use WBS templates ororganization-specific guidelines.– Bottom-up: constructed from the inputs of project team members who actually do the work (team buy-in)</p></li><li><p>The lowest level of WBS components always are deliverables</p></li><li><p>Rolling wave planning: Những việc cần hoàn thành trong thời gian tới sẽ được lên kế hoạch chi tiết, việc xa hơn thì sẽ lên kế hoạch ở cấp cao hơn</p><ul><li>Work packages:<ul><li>Những deliverables được bàn giao trong thời gian ngắn tiếp theo.</li><li>Lowest level element of WBS và sẽ không thể phân rã được thêm nữa.</li></ul></li><li>Planning packages:<ul><li>Những sản phẩm được bàn giao trong thời gian dài tiếp theo.</li><li>Sẽ được phân rã ra thành work packages trong giai đoạn sau.</li><li>Planning package will not have activities under them</li></ul></li></ul></li><li><p>Rule of 100%</p></li><li><p>Rule of thumb:</p><ul><li>Công việc k được ngắn hơn 8h và dài hơn 80h</li></ul></li></ul></li></ul><h3 id="d-Outputs-v4">d. Outputs</h3><ul><li><p>Scope Baseline:</p><ul><li>Là phiên bản đã được approved về scope statement, WBS, WBS dictionary</li><li>Scope baseline là 1 thành phần của project management plan.</li><li>Nó chỉ được thay đổi thông qua formal change control procedures</li><li>Được dùng làm cơ sở so sánh với kết quả thực tế trong monitor, control dự án</li><li>Gồm các thành phần:<ul><li>Scope statement</li><li>WBS</li><li>WBS dictionary</li><li>Work packages</li><li>Planning packages</li></ul></li></ul></li><li><p>Project Documents Updates</p><ul><li>Assumption log: additional assumptions or constraints</li><li>Requirements documentation.</li></ul></li><li><p>WBS dictionary</p></li></ul><h2 id="5-Validate-Scope">5. Validate Scope</h2><h3 id="a-Inputs-v5">a. Inputs</h3><ul><li><p>Verified deliverables</p></li><li><p>Project Management Plan</p><ul><li>Scope management plan</li><li>Requirements management plan</li><li>Scope baseline</li></ul></li><li><p>Project documents</p><ul><li>Requirements Documentation</li><li>Requirements Traceability Matrix</li><li>Quality Reports</li><li>Lessons learned register</li></ul></li><li><p>Work performance data</p></li></ul><h3 id="b-Validate-Scope">b. Validate Scope</h3><ul><li>Là quá trình xác nhận các deliverables đã hoàn thành và chính thức được chấp nhận bởi các stakeholders</li><li>Mục đích để giảm số lần làm lại và tăng khả năng đóng dự án</li><li>Việc này được làm định kỳ trong suốt dự án. Thường sẽ được thực hiện sau Control Quality, và trước Close Project/Phase.</li><li>Khi project team show project deliverables cho customer sẽ có 3 trường hợp:<ul><li>Khách hàng chấp nhận phần deliverables</li><li>Khách hàng không chấp nhận do bị lỗi hoặc không đúng yêu cầu =&gt; project team phải sửa lại</li><li>Nếu phát sinh change request thì được change control board đánh giá. Chỉ khi nào CCB approved thì mới được thực hiện</li></ul></li></ul><h3 id="c-Tools-Techniques-v5">c. Tools &amp; Techniques</h3><ul><li>Inspection</li><li>Decision Making<ul><li>Vote</li></ul></li></ul><h3 id="d-Outputs-v5">d. Outputs</h3><ul><li>Work Performance Information</li><li>Accepted deliverables</li><li>Change requests</li><li>Project documents updates</li><li>Requirements documentation.</li><li>Requirements traceability matrix.</li><li>Lessons learned register.</li></ul><h2 id="6-Control-Scope">6. Control Scope</h2><h3 id="a-Inputs-v6">a. Inputs</h3><ul><li><p>Work Performance Data</p></li><li><p>Project Management Plan</p><ul><li>Scope Management Plan</li><li>Requirements Management Plan</li><li>Change Management Plan</li><li>Configuration Management Plan</li><li>Scope Baseline</li><li>Performance measurement baseline.</li></ul></li><li><p>Project documents</p><ul><li>Requirements documentation</li><li>Requirements traceability matrix</li><li>Lessons learned register</li></ul></li><li><p>Organizational process assets</p></li></ul><h3 id="b-Control-Scope">b. Control Scope</h3><ul><li><p>Là quá trình monitor trạng thái của project scope và product scope. Đồng thời quản lý sự thay đổi của scope baseline</p></li><li><p>Xác định nguyên nhân và sự khác biệt với scope baseline và quyết định có thực hiện khắc phục hay phòng ngừa hay không</p></li><li><p>Được thực hiện trong suốt dự án</p></li><li><p>Quy trình tạo một change request tại <a href="/Book/2023/06/25/change-request">đây.</a></p></li></ul><h3 id="c-Tools-Techniques-v6">c. Tools &amp; Techniques</h3><ul><li>Variance Analysis: So sánh mức độ thay đổi với scope baseline ban đầu</li><li>Trend analysis.</li></ul><h3 id="d-Outputs-v6">d. Outputs</h3><ul><li><p>Work Performance Information</p></li><li><p>Change requests</p></li><li><p>Project management plan updates</p><ul><li>Scope management plan</li><li>Scope baseline</li><li>Other baselines (schedule, cost, performance measurement …)</li></ul></li><li><p>Project document updates</p><ul><li>Requirements documentation</li><li>Requirements traceability matrix</li><li>Lessons learned register</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pmp </tag>
            
            <tag> Scope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP Communication</title>
      <link href="/Book/2023/06/17/communication/"/>
      <url>/Book/2023/06/17/communication/</url>
      
        <content type="html"><![CDATA[<p>Nhu cầu  giao tiếp của dự án là rất quan trọng. Nó là sự trao đổi thông tin có chủ đích hoặc không chủ đích</p><p>Việc quản lý Communication gồm 2 phần:</p><ul><li><p>Lên Plan để đảm bảo giao tiếp hiệu quả</p></li><li><p>Thực thi các hoạt động theo Plan</p></li><li><p>PM có thể dành đến 90% thời gian để communication với project team và stakeholders.</p></li><li><p>Chất lượng dự án là chất lượng của communication</p></li></ul><h2 id="1-Plan-Communication-Management">1. Plan Communication Management</h2><h3 id="a-Inputs">a. Inputs</h3><ul><li><p>Project charter</p></li><li><p>Project Management Plan</p><ul><li>Resource management plan</li><li>Stakeholder engagement plan</li></ul></li><li><p>Project documents</p><ul><li>Stakeholder Register</li><li>Requirements documentation</li></ul></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Plan-Communication-Management">b. Plan Communication Management</h3><ul><li><p>Là quá trình xác định đối tượng, cách thức, thời điểm thông tin dự án sẽ được truyền tải.</p></li><li><p>Việc lên kế hoạch này cần được làm ASAP.</p></li><li><p>Nên được reviewed định kỳ trong suốt dự án.</p></li><li><p>Nó được thay đổi khi có thêm hoặc mất đi 1 stakeholder hoặc có 1 stakeholder nào đó muốn thay đổi.</p></li><li><p>Cần lên plan for cultural diversity của các stakeholders: về tuổi tác, dân tộc, quốc tịch, chủng tộc, giới tính…</p></li><li><p>Cần xác định những constraint từ các specific regulation, technologies, organization policies</p></li><li><p>Political awareness?</p></li></ul><h3 id="c-Tools-Techniques">c. Tools &amp; Techniques</h3><ul><li>Communication Requirement Analysis: Xác định thông tin mà các stakeholders cần thông qua interview, workshop, lesson learnt từ project trước.</li><li>Communication styles assessment</li><li>Communication Complexity<ul><li>channels of communications = N(N-1)/2</li></ul></li><li>Communication Technology</li><li>Communication Model</li><li>Communication Methods<ul><li>Push communication: Gửi thông tin cho những người cụ thể. Nó đảm bảo thông tin đã được gửi đi.Nhưng không đảm bảo người nhận có thể nhận hoặc hiểu nội dung. VD: letter, email…</li><li>Pull communication: Sử dụng khi có nhiều thông tin cần gửi và gửi cho 1 số lượng người lớn.</li><li>Interactive communication: Thông tin được trao đổi trực tiếp giữa 2 hoặc 1 nhóm người. Đây là cách trao đổi hiệu quả nhất</li></ul></li></ul><h3 id="d-Outputs">d. Outputs</h3><p><img src="/images/pmp/communication-management-plan.png" alt="communication-management-plan"></p><ul><li><p>Communications Management Plan</p></li><li><p>Project Management Plan Updates</p><ul><li>Stakeholder engagement plan</li></ul></li><li><p>Project Document Updates</p><ul><li>Project schedule</li><li>Stakeholder register: Stakeholder management strategy</li></ul></li></ul><h2 id="2-Manage-Communications">2. Manage Communications</h2><h3 id="a-Inputs-v2">a. Inputs</h3><ul><li><p>Work Performance Reports</p></li><li><p>Project management plan</p><ul><li>Stakeholder engagement plan</li><li>Communications management</li><li>Resource management plan</li></ul></li><li><p>Project documents</p><ul><li>Stakeholder register</li><li>Issue log</li><li>Change log</li><li>Risk report</li><li>Quality report</li><li>Lessons learned register</li></ul></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Manage-Communications">b. Manage Communications</h3><ul><li><p>Là quá trình đảm bảo kịp thời việc thu thập, lưu trữ, phân phối, xử lý thông tin theo đúng communications management plan</p></li><li><p>Lợi ích của process này là cho phép luồng thông tin hiệu quả giữa project team và stakeholders</p></li><li><p>Việc này được làm trong suốt dự án</p></li></ul><h3 id="c-Tools-Techniques-v2">c. Tools &amp; Techniques</h3><ul><li><p>Information Management Systems</p></li><li><p>Communication skills</p><ul><li>Meeting management</li><li>Active listening</li><li>Feedback</li><li>Nonverbal</li><li>Presentations</li><li>Conflict management</li></ul></li><li><p>Meeting Management</p></li><li><p>Effective communication</p><ul><li>Eye contact</li><li>Mirroring: Bắt chước</li><li>Written communication: 5Cs<ul><li>Clear</li><li>Concise</li><li>Correct</li><li>Coherent (mạch lạc)</li><li>Controlling</li></ul></li></ul></li><li><p>Performance reporting</p><ul><li>Status reports: describe where the project stands at a specific point in time</li><li>Variance report: Earned value report integrates scope, time, cost measures to assess project performance (EV, SV, CV, …)</li><li>Progress reports: describe what the project team has accomplished during a certain period of time</li><li>Trend reports: Examine project results over time to see if performance is improving or deteriorating</li><li>Forecasts: predict future project status and performance based on past information and trends</li></ul></li></ul><h3 id="d-Outputs-v2">d. Outputs</h3><ul><li><p>Project Communications</p></li><li><p>Project management plan updates</p><ul><li>Communications management plan.</li><li>Stakeholder engagement plan.</li></ul></li><li><p>Project documents updates</p><ul><li>Stakeholder register</li><li>Issue log,</li><li>Risk register</li><li>Project schedule,</li><li>Lessons learned register</li></ul></li><li><p>Organizational process assets updates</p><ul><li>Stakeholder notifications.</li><li>Project reports.</li><li>Project presentations.</li><li>Project records.</li><li>Feedback from stakeholders.</li><li>Lessons learned documentation.</li></ul></li></ul><h2 id="3-Control-Communications">3. Control Communications</h2><h3 id="a-Inputs-v3">a. Inputs</h3><ul><li><p>Work Performance Data</p></li><li><p>Project Management Plan</p><ul><li>Stakeholder Engagement Plan</li><li>Communication management Plan</li><li>Resource Management Plan</li></ul></li><li><p>Project Documents</p><ul><li>Project communications: Deliverables status, Schedule progress, and Costs incurred</li><li>Issue Log</li></ul></li><li><p>Enterprise Environmental Factors</p></li><li><p>Organizational Process Assets</p></li></ul><h3 id="b-Control-Communications">b. Control Communications</h3><ul><li><p>Là quá trình đánh giá communication có như plan hay không? Có đúng người, đúng cách và đúng thời điểm hay không</p></li><li><p>Việc này cần được review định kỳ và nếu cần thiết thì sẽ thay đổi. Việc thay đổi sẽ diễn ra khi bắt đầu 1 phase mới hoặc khi stakeholder thay đổi cách liên lạc.</p></li></ul><h3 id="c-Tools-Techniques-v3">c. Tools &amp; Techniques</h3><ul><li><p>Observation/conversation</p></li><li><p>Stakeholder engagement assessment matrix</p></li><li><p>Information Management Systems</p></li></ul><h3 id="d-Outputs-v3">d. Outputs</h3><ul><li><p>Work Performance Information</p></li><li><p>Change requests</p></li><li><p>Project Management Plan updates</p><ul><li>Stakeholder Engagement Plan</li><li>Communication Management Plan</li></ul></li><li><p>Project documents updates</p><ul><li>Stakeholder register.</li><li>Issue log.</li><li>Lessons learned register.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pmp </tag>
            
            <tag> Communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP stakeholder</title>
      <link href="/Book/2023/06/14/stakeholder/"/>
      <url>/Book/2023/06/14/stakeholder/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pmp/stakeholder.png" alt="stakeholder"></p><h2 id="1-Identify-stakeholder">1. Identify stakeholder</h2><ul><li>Stakeholder là những người bị ảnh hưởng, có thể bị ảnh hưởng, hoặc họ nghĩ rằng họ cũng bị tác động với hoạt động, kết quả của dự án</li><li>PM và team ngồi cùng nhau để định danh ra stakeholders. Vì Stakeholder có thể ảnh hưởng tốt hoặc xấu đến dự án nên nếu nếu định danh thiếu có thể làmảnh hưởng đến dự án. Và mục tiêu quan trọng của dự án là stakeholder satisfaction</li><li>Nên làm ASAP, tốt nhất được thực hiện trong khi initiation, trước planning. Và việc này nên được làm định kỳ trong suốt dự án để  nhữngStakeholder mới hoặc thay đổi thông tin stakeholder .</li></ul><h3 id="a-Inputs">a. Inputs</h3><ul><li>Project charter</li><li>Project management plan: Lúc đầu khi định danh stakeholders chưa có tài liệu này, Nhưng khi tài liệu này được phát triển thì nó sẽ bao gồm cả:<ul><li>Stakeholder Engagement Plan</li><li>Communication Management Plan</li></ul></li><li>Project documents<ul><li>Change log</li><li>Requirement documentation</li><li>Groups, organizations, etc</li></ul></li><li>Business Documents: Những người hưởng lợi tự dự</li><li>Agreement: Supplier, subcontractor…</li><li>Enterprise Environmental Factors (EEF)</li><li>Organizational Process Assets (OPA)</li></ul><h3 id="b-Stakeholder-analysis">b. Stakeholder analysis</h3><p>B1: Xác định những stakeholders.</p><ul><li>Directions of influence :<ul><li>Upward: Sponsor, senior management…</li><li>Downward: Project team, consultant…</li><li>Outward: Supplier, Vendors, government…</li><li>Sideward: Others PM…</li></ul></li></ul><p>B2:  Analyze Stakeholder</p><ul><li>Xác định những key stakeholders và những expectations, needs, influences của họ</li></ul><p>B3: Classify Stakeholders. Có thể dùng tool Power/Interest Grid</p><p><img src="/images/pmp/power-interest-grid.png" alt="power-interest-grid"></p><p>B4: Define Management Strategy</p><h3 id="c-Tools-Techniques">c. Tools &amp; Techniques</h3><ul><li>Power/Interest Grid</li><li>Salience Model</li><li>Stakeholder Cube</li><li>Expert Judgment</li><li>Meeting</li><li>Brainstorming</li><li>Questionaire and Survey</li><li>Document analysis</li></ul><h3 id="d-Outputs">d. Outputs</h3><ul><li><p>Stakeholder Register<img src="/images/pmp/stakehoder-register.png" alt="stakehoder-register"></p></li><li><p>Change requests: Vì trong suốt dự án việc sẽ phát sinh việc các stakeholder mới có thể dẫn đến việc yêu cầu thay đổi:</p><ul><li>Project management plan:<ul><li>Stakeholder engagement plan.</li><li>Communications management plan.</li><li>Requirements management plan.</li><li>Risk management plan.</li></ul></li><li>Project documents:<ul><li>Assumption log</li><li>Issue log</li><li>Risk register</li></ul></li></ul></li></ul><h2 id="2-Plan-Stakeholder-Engagement">2. Plan Stakeholder Engagement</h2><ul><li><p>Sự tham gia và tương tác của các stakeholders vào dự án là rất quan trọng. Ở mỗi giai đoạn khác nhau thì mức độ tham gia của các stakeholder cũng khácnhau</p></li><li><p>Việc tạo Plan Stakeholder Engagement diễn ra trong suốt dự án</p></li></ul><h3 id="a-Inputs-v2">a. Inputs</h3><ul><li><p>Project charter</p></li><li><p>Project management plan:</p><ul><li>Resource management plan: roles and responsibilities</li><li>Communications management plan.</li><li>Risk management plan.</li></ul></li><li><p>Project documents:</p><ul><li>Stakeholder register</li><li>Project schedule</li><li>Risk register</li><li>Issue log</li><li>Change log</li><li>Assumption log</li></ul></li><li><p>Agreement: Supplier, subcontractor…</p></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Plan-Stakeholder-Engagement">b. Plan Stakeholder Engagement</h3><ul><li>5 cấp độ tham gia của các stakeholders:<ul><li>Unaware: Không nhận thức về dự án</li><li>Resistant: Chống đối dự án</li><li>Neutral: Có nhận thức về dự án nhưng không chống đối cũng không giúp đỡ</li><li>Supportive: Hỗ trợ dự án</li><li>Leading: Tích cực tham gia vào dự án để đảm bảo dự án thành công.</li></ul></li></ul><h3 id="c-Tools-Techniques-v2">c. Tools &amp; Techniques</h3><ul><li><p>Stakeholder Engagement Assessment Matrix<img src="/images/pmp/stakeholder-engagement-assessment-matrix.png" alt="stakeholder-engagement-assessment-matrix"></p></li><li><p>Benchmarking</p></li><li><p>Root cause analysis</p></li><li><p>Assumption and constraint analysis</p></li><li><p>Mind mapping</p></li><li><p>Decision making</p></li></ul><h3 id="d-Outputs-v2">d. Outputs</h3><ul><li>Stakeholder Engagement Plan</li></ul><p><img src="/images/pmp/stakeholder-engagement-plan.png" alt="stakehoder-engagement-plan"></p><h2 id="3-Manage-Stakeholder-Engagement">3. Manage Stakeholder Engagement</h2><ul><li><p>Là quá trình làm việc và giao tiếp với stakeholders để nhận được sự giúp đỡ, tránh việc bị phản đối hoặc ảnh hưởng tiêu cực từ họ.</p></li><li><p>Việc quản lý này cần thực hiện trong suốt dự án vì thái độ và cam kết của stakeholders có thể sẽ thay đổi khi có các events xảy ra</p></li></ul><h3 id="a-Inputs-v3">a. Inputs</h3><ul><li><p>Project management plan:</p><ul><li>Stakeholder engagement plan</li><li>Communications management plan: Stakeholder communications requirements; escalation process</li><li>Risk management plan.</li><li>Change the management plan</li></ul></li><li><p>Project documents:</p><ul><li>Stakeholder register</li><li>Risk register</li><li>Issue log</li><li>Change log</li><li>Assumption log</li></ul></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Manage-Stakeholder-Engagement">b. Manage Stakeholder Engagement</h3><ul><li><p>Đáp ứng những needs, expectations của stakeholders, và thúc đẩy họ tham gia vào dự án.</p></li><li><p>Giải quyết, làm rõ những sự changes, issues, risks mà stakeholders quan tâm thông qua communication, negotiation và conflict resolution</p></li></ul><h3 id="c-Tools-Techniques-v3">c. Tools &amp; Techniques</h3><ul><li>Ground rules</li><li>Communication skills</li><li>Interpersonal and team skills</li><li>Interpersonal and team skills</li></ul><h3 id="d-Outputs-v3">d. Outputs</h3><ul><li><p>Change requests:</p><ul><li>Change requirement and scope</li></ul></li><li><p>Project Management Plan Updates</p></li><li><p>Project Documents updates:</p><ul><li>Stakeholder register.</li><li>Issue log: Là tài liệu để PM document issues, define the impact, priority and urgency of the issues, assignownership of those issues, and established due dates for resolution</li><li>Change log</li><li>Risk register</li><li>Lessons learned register</li></ul></li></ul><h2 id="4-Monitor-Stakeholder-Engagement">4. Monitor Stakeholder Engagement</h2><ul><li><p>Là quá trình giám sát mối quan hệ với stakeholders và điều chỉnh plan, strategy cho Stakeholder Engagement.</p></li><li><p>Trong suốt dự án cần thực hiện việc monitor vì có thể có plan, strategy không hiệu quả hoặc có thể stakeholder đã thay đổi theo sự phát triển của dự án</p></li></ul><h3 id="a-Inputs-v4">a. Inputs</h3><ul><li><p>Project management plan:</p><ul><li>Stakeholder engagement plan</li><li>Communications management plan</li><li>Resource management plan.</li></ul></li><li><p>Project documents:</p><ul><li>Stakeholder register</li><li>Risk register</li><li>Issue log</li><li>Change log</li><li>Lessons learned register</li><li>Project communications</li></ul></li><li><p>Work performance data: dữ liệu của dự án về việc tham gia dự án của các stakeholders</p></li><li><p>Enterprise Environmental Factors (EEF)</p></li><li><p>Organizational Process Assets (OPA)</p></li></ul><h3 id="b-Monitor-Stakeholder-Engagement">b. Monitor Stakeholder Engagement</h3><p>4 bước để monitor:</p><ul><li>So sánh kết quả hiện tại với kết quả trong plan</li><li>Xác định và định lượng kết quả</li><li>Đề xuất các phương án tương ứng: duy trì, tăng hoặc giảm</li><li>Sắp xếp ưu tiên các phương án trên và chọn phương án tốt nhất.</li></ul><h3 id="c-Tools-Techniques-v4">c. Tools &amp; Techniques</h3><ul><li>Stakeholder analysis</li><li>Stakeholder engagement assessment matrix</li><li>Root cause analysis.</li><li>Alternatives analysis</li><li>Decision making</li><li>Meetings</li><li>Communication skills</li><li>Interpersonal and team skills</li></ul><h3 id="d-Outputs-v4">d. Outputs</h3><ul><li><p>Work performance information: status của Stakeholder Engagement</p></li><li><p>Change requests</p><ul><li>Corrective actions</li><li>Preventive actions</li></ul></li><li><p>Project Management Plan Updates</p><ul><li>Stakeholder Engagement Plan</li><li>Resource management plan</li><li>Communications management plan</li></ul></li><li><p>Project documents updates</p><ul><li>Stakeholder register</li><li>Issue log</li><li>Change log</li><li>Risk register</li><li>Lessons learned register</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pmp </tag>
            
            <tag> stakeholder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS Phần 2</title>
      <link href="/Technology/common/2022/07/05/aws-2/"/>
      <url>/Technology/common/2022/07/05/aws-2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-AWS-EC2-Elastic-Compute-Cloud-Infrastructure-as-a-Service">1. AWS EC2 (Elastic Compute Cloud - Infrastructure as a Service)</h2><p>Những khả năng chính:</p><ul><li>Renting virtual machines (EC2)</li><li>Storing data on virtual drives (EBS)</li><li>Distributing load across machines (ELB)</li><li>Scaling the services using an auto-scaling group (ASG)</li></ul><h3 id="a-EC2-User-Data-Bootstrap-script">a. EC2 User Data (Bootstrap script)</h3><ul><li>Bootstraping là việc thực hiện các commands 1 lần duy nhất khi mà machine start</li><li>EC2 User Data Script run với root user</li><li>Public IPv4 sẽ bị thay đổi khi stop và start lại EC2 instant, nhưng private IPv4 thì không thay đổi</li></ul><h3 id="b-EC2-instance-Types">b. EC2 instance Types</h3><p>Naming convention.VD: m5.2xlargeTrong đó:</p><ul><li>m là instance class</li><li>5 generation</li><li>2xlarge: size in instance class</li></ul><p>Các loại của EC2:</p><ul><li><p>General Purpose:</p><ul><li>Dùng làm web servers hoặc code repositories</li><li>Cân bằng giữa 3 yếu tố: Compute, Memory, Networking</li></ul></li><li><p>Compute Optimized: Phù hợp với những tasks yêu cầu high performance processors.</p><ul><li>Batch processing workload</li><li>Media transcoding</li><li>High performance web servers</li><li>High performance computing (HPC)</li><li>Scientific modeling &amp; machine learning</li><li>Dedicated gaming servers</li></ul></li><li><p>Memory Optimized:</p><ul><li>Cần hiệu năng cao với dữ liệu lớn được lưu trên memory</li></ul></li><li><p>Accelerated Computing</p></li><li><p>Storage Optimized</p></li><li><p>Instance Features</p></li><li><p>Measuring Instance Performance</p></li></ul><p>Note: fvaof trang <a href="http://ec2instances.info">ec2instances.info</a> để xem so sánh giữa các instances EC2 của AWS</p><h3 id="c-Security-Groups">c. Security Groups</h3><ul><li>They control how traffic is allowed into or out of our EC2 Instances</li><li>Security groups only contain rules</li><li>Security groups rules can reference by IP or by security group</li></ul><p>Khi có lỗi timeout khi connect với EC2 thì khả năng rất lớn là do Security Group</p><h3 id="d-Classic-Port">d. Classic Port</h3><p>22 = SSH (Secure Shell) - Log into a Linux Instance21 = FTP (File transfer Protocall) - Upload files into a file share22 = SFTP (Secure File Transfer Protocol) – upload files using SSH80 = HTTP – access unsecured websites443 = HTTPS – access secured websites3389 = RDP (Remote Desktop Protocol) – log into a Windows instance</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> common </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS Phần 1</title>
      <link href="/Technology/common/2022/07/01/aws-1/"/>
      <url>/Technology/common/2022/07/01/aws-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-AWS-Infrastructure">1. AWS Infrastructure</h2><h3 id="a-Regions">a. Regions</h3><ul><li>AWS có các Regions ở rải rác trên toàn thế giới. VD: ap-northeast-1, us, eu-west-3…</li><li>1 Region là 1 cụm các data centers</li><li>Hầu hết các AWS services có scope là Region.</li></ul><p>Các tiêu chí khi chọn AWS Region:</p><ul><li>Compliance with data governance and legal requirements: Thỉnh thoảng các chính quyền yêu cầu ứng dụng, data nhạy cảm cần được lưu trữ ở trong nước nơi mà ứng dụng được hoạt động.</li><li>Proximity to customers: reduced latency</li><li>Available services within a Region: Mỗi region khác nhau sẽ được cung cấp các services, feature khác nhau</li><li>Pricing: Các region khác nhau sẽ có giá khác nhau</li></ul><h3 id="b-Availability-Zones-AZ">b. Availability Zones (AZ)</h3><ul><li>Mỗi Region có nhiều AZ (ít nhất là 2, nhiều nhất là 6, thông thường là 3). VD: ap-southeast-2a, ap-southeast-2b, ap-southeast-2c</li><li>Mỗi AZ có một hoặc nhiều các data centers (nơi lưu trữ vật lý) rời rạc, tách biệt và chúng được liên kết mới nhau với high bandwidth, ultra-lơ latency networking. Mục đích để tránh các thảm họa gây mất mát dữ liệu</li></ul><h3 id="AWS-Points-of-Presence-PoP-Edge-Locations">AWS Points of Presence (PoP - Edge Locations)</h3><p><img src="/images/aws/edge-location-structure.png" alt="Edge Location"></p><ul><li>Edge Location là những điểm mà các yêu cầu của Users được gửi đến nhanh nhất với mục đích xử lý request của khách hàng nhanh nhất.</li><li>Regional Edge Cache có bộ nhớ cache rất lớn, lưu trữ data được lâu hơn và lớn hơn rất nhiều so với cache của Edge Location. Regional Edge Cache sẽ giúp giảm các yêu cầu đến Origin Server</li><li>AWS có 216 PoP (206 Edge Locations và 11 Regional Edge Caches)</li></ul><h2 id="2-IAM-Identity-and-Access-Management">2. IAM (Identity and Access Management)</h2><ul><li>IAM là Global service. Nó không phụ thuộc, không phải lựa chọns region.</li><li>Root account không nên sử dụng ngoại trừ việc thiết lập các accounts.</li><li>Dùng Root account để tạo ra các User và Groups để grant Permissions cho chúng.</li><li>Một Group chỉ nên chứa các users, không chứa các groups khác</li><li>Một user có thể không thuộc vào 1 group (Đây không phải là best practice) và một user có thể thuộc nhiều Groups</li><li>File JSON doctument dùng để định danh các permissions cho User và Group được gọi là policies<ul><li>Version: policy language version, luôn luôn bao gồm “2012-10-17”</li></ul></li><li>Nguyên tắc là không được cung cấp permissions nhiều hơn cái mà users cần</li><li>Một người dùng vật lý sẽ tương ứng với 1 AWS user. (không chia sẻ thông tin tài khoản cho người khác)</li><li>Chỉ nên assign users vào các groups và assign các permissions cho các groups đó.</li><li>Nên tạo và sử dụng Roles để cấp permissions cho AWS services.</li><li>Sử dụng IAM Credentials Report để audit permissions cho account</li></ul><h3 id="a-IAM-Password-Policy">a. IAM Password Policy</h3><ul><li><p>Cho phép thiết lập policy password: ít nhất bao nhiêu ký tự, chữ hoa, thường…</p></li><li><p>Cho phép các user IAM thay đổi password của họ</p></li><li><p>Cho phép yêu cầu users đổi password sau 1 khoảng thời gian</p></li><li><p>Cho phép yêu cầu không được sử dụng lại pass cũ</p></li><li><p>IAM user thuộc tối đa 10 group</p></li><li><p>1 account có tối đa 5000 IAM user.</p></li></ul><p>Multi Factor Authentication - MFA</p><ul><li>AWS yêu cầu và rất khuyên dùng dịch vụ này</li><li>MFA = password you know + security device you own</li><li>Có thể dùng Vitual MFA device (Google Authenticator, Authy (recommended)), Universal 2nd factor - U2F (Một thiết bị vật lý), Hardware Key fob MFA device để thực hiện MFA</li><li>Có 3 cách để truy cập vào AWS:<ul><li>AWS Management Console (protected by password + MFA)</li><li>AWS Command Line Interface (CLI): protected by access keys (access key được tạo bởi AWS console)</li><li>AWS Software Developer Kit (SDK) - for code: protected by access key</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> common </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 sai lầm lớn nhất của người lãnh đạo</title>
      <link href="/Book/2022/03/31/10-sai-lam-lon-nhat-cua-nguoi-lanh-dao/"/>
      <url>/Book/2022/03/31/10-sai-lam-lon-nhat-cua-nguoi-lanh-dao/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/10-sai-lam-lon-nhat-cua-nguoi-quan-ly.png" alt="10-sai-lam-lon-nhat-cua-nguoi-quan-ly"></p><h2 id="1-Overview">1. Overview</h2><p>Đây là một cuốn sách thực sự hay và đáng đọc đối với tôi (8/10đ). Mặc dù được viết và xuất bản từ thập niên 90 của thế kỷ trước,nhưng tôi vẫn thấy nguyên giá trị kiến thức sâu sắc của cuốn sách. Những lỗi lầm được tác giả nhắc tới tưởng chừng như đơn giản,ai cũng thấy NHƯNG hãy tin tôi bạn sẽ thấy hình bóng của mình trong đó (hơi buồn là tôi cũng vậy).</p><p>Với văn phong gần gũi, dẫn chứng cụ thể, nội dung thực tế, Hans “dẫn đường” cho bạn đọc đến với hình ảnh lãnh đạo mà ông tâm đắc: Lãnh đạo phục vụ</p><h2 id="2-Tom-tat-noi-dung-chinh">2. Tóm tắt nội dung chính</h2><p>Cuốn sách chỉ ra 10 điểm sai lầm của người lãnh đạo :</p><ul><li><p>Thái độ từ trên xuống – Kiểu lãnh đạo gây khó chịu nhất:</p><p>Bản chất con người là ham muốn thống trị người khác. Cách lãnh đạo này tập trung vào mệnh lệnh áp đặt, kiểm soát. Theo tác giả đây cũng chính là sai lầm lớn nhất và cũng là cha đẻ của mọi lỗi lầm trong lãnh đạo</p></li><li><p>Đặt chỉ tiêu công việc lên trên mối bận tâm về nhân sự</p><p>Càng ở vị trí cao, chúng ta càng cần dành nhiều thời gian hơn trong việc tương tác, quản lý nguồn nhân sự.  Hãy nhớ rằng con người tạo ra cơ hội, không phải sự phiền hà.</p></li><li><p>Thiếu sự ghi nhận</p><p>Tất cả mọi người đều khao khát được ghi nhận và tán dương. Chúng ta đã đánh giá quá thấp những cử chỉ tình cảm nhỏ nhất nhưng lại có sức mạnh “chạm tới trái tim”. Hãy cố gắng học hỏi càng nhiều mức độ cử chỉ ghi nhận càng tốt.</p></li><li><p>Không có chỗ nào cho những kẻ nổi loạn</p><p>Những người nổi loại có thể giúp tổ chức thoát khỏi hiểm họa dập khuôn thể chế hóa. Bản chất của họ là tạo ra sự xáo trộng cần thiết cho tổ chức. Nhưng các tổ chức lớn thường triệt tiêu những nhân tố nổi loạn từ trong trứng nước trước khi họ kịp phát huy sức mạn. Vì thế chúng ta cần học cách nhận ra những kẻ nổi loạn chân chính</p></li><li><p>Sự độc tài trong quyết định</p><p>Lãnh đạo độc tài phủ nhận năng lực của cá nhân. Họ sử dụng nhân sự chứ không phát triển họ. Quyết định nên được đưa ra từ chính người chịu trách nhiệm thực thi công việc.</p></li><li><p>Giao việc thiếu minh bạch</p><p>Quản lý vi mô là một dấu hiệu của sự quản lý yếu kém. Cần giao đúng người, đúng việc</p></li><li><p>Nhiễu sóng truyền thông nội bộ</p><p>Đừng bao giờ mặc định là tất cả mọi người đều nắm rõ thông tin. Trong tổ chức càng lớn thì việc truyền thông càng được coi trọng. Việc truyền thông nội bộ là một trong những ưu tiên hàng đầu của nhà lãnh đạo hiệu quả.</p></li><li><p>Lỗ hổng văn hóa doanh nghiệp</p><p>Văn hóa tổ chức doanh nghiệp là rất quan trọng. Chúng ta cần học cách tôn trọng sự đa dạng của các giá trị cá nhân và những giá trị khác biệt. Việc phát triển văn hóa doanh nghiệp cũng là một trong những ưu tiên hàng đầu của nhà lãnh đạo.</p></li><li><p>Sẽ không có thành công nếu thiếu người kế nhiệm</p><p>Để trở thành nhà lãnh đạo thành công, bạn buộc phải có khả năng dẫn dắt những thế hệ đi sau.</p></li><li><p>Thất bại trong việc tập trung cho tương lai</p><p>Mối bận tâm tiên quyết yêu cầu với một nhà lãnh đạo hiệu quả là tầm nhìn – tương lai.</p></li></ul><h2 id="3-Nhung-doan-van-gay-an-tuong">3. Những đoạn văn gây ấn tượng</h2><blockquote><p>Khi được hỏi về việc tại sao Hans lại muốn trở thành lãnh đạo của WorldVenture”. Tác giả đã trả lời:</p><p>…” Trong suốt mười hai năm phục vụ công ty, tôi luôn sẵn sàng nhận những trách nhiệm lớn hơn. Và giờ đây tôi đã sẵn sàng đảm nhiệm những trách nhiệm lớn hơn. Và giờ đây tôi đã sẵn sàng nắm giữ vị trí cao nhất, “nhưng cần nói rõ là tôi sẵn sàng, chứ không theo đuổi”…</p></blockquote><p>=&gt; Đây là một tư duy rất đáng học hỏi. Ý tác giả muốn nói khi ở bất kỳ vị trí nào, trách nhiệm nào thì ông luôn luôn cố gắng, nỗ lực hết mình để hoàn thành suất sắc nhất các nhiệm vụ được giao mà hoàn toàn không suy nghĩ là tôi làm những việc này để tôi trở thành người nọ người kia. Trên thực tế tôi cũng may mắn được nghe chia sẻ về tư duy này từ rất nhiều CEO, CTO thành công.</p><blockquote><p>“Lãnh đạo là khả năng nhận ra năng lực đặc biệt và hạn chế của mỗi người và đặt họ vào vị trí thế mạnh của họ” —J.Oswald Sanders—</p></blockquote><p>=&gt; Đúng vậy, tôi cũng quan điểm rằng: khi làm việc với một nhóm, người lãnh đạo cần phải tạo ra được nhiều giá trị nhất với nguồn lực mình có.</p><blockquote><p>“Nếu mọi thứ có vẻ như đều nằm trong tầm kiểm soát thì anh đang tiến không đủ nhanh.” —Mario Andretti—</p></blockquote><p>=&gt; Tôi thấy câu này cũng chỉ có nghĩa tương đối: không hẳn đúng mà cũng chẳng sai, có thể tôi chưa thực sự hiểu dụng ý của tác giả. (Ai đã đọc và hiểu thì chia sẻ với mình nhé)</p><blockquote><p>Cốt lõi của giao phó trách nhiệm là vấn đề của sự tôn trọng.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
            <tag> 10sailamlonnhatcuanguoilanhdao </tag>
            
            <tag> Hans Finzel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quản lý linh hoạt với Agile Scrum</title>
      <link href="/Management/2022/01/25/agile-scrum/"/>
      <url>/Management/2022/01/25/agile-scrum/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/agile-scrum.png" alt="agile-scrum"></p><h2 id="1-Agile-la-gi-Scrum-la-gi">1. Agile là gì? Scrum là gì?</h2><h3 id="a-Agile-la-gi">a. Agile là gì?</h3><ul><li>Là phương pháp phát triển phần mềm linh hoạt để đưa sản phẩm tốt đến người dùng càng sớm càng tốt.</li></ul><h3 id="b-Scrum-la-gi-Agile-va-Scrum-co-phai-la-mot-khong">b. Scrum là gì? Agile và Scrum có phải là một không?</h3><ul><li>Scrum là một quy trình phát triển phần mềm theo phương pháp Agile. Chính vì thế, Scrum tuân thủ các nguyên tắc của Agile.</li><li>Tuy nhiên, Agile và Scrum không phải là một. Hãy nhớ lại, Agile là gì? Agile là một phương pháp,bao gồm những giá trị cốt lõi và nguyên tắc nhất định còn Scrum là quy trình “hiện thực hoá” những giá trị và nguyên tắc của Agile.</li></ul><p>Note:</p><blockquote><p><strong>ScrumBut</strong> mean that Scrum has exposed a dysfunction that is contributing to the problem, but is too hard to fix. A ScrumBut retains the problem while modifying Scrum to make it invisible so that the dysfunction is no longer a thorn in the side of the team</p><p>Systax: (ScrumBut)(Reason)(Workaround)</p><p>VD: (Chúng tôi sử dụng Scrum nhưng)(vì daily scrum quá phí thời gian)(nên chúng tôi daily 1 tuần 1 lần)…</p></blockquote><h3 id="c-Tuyen-ngon-Agile">c. Tuyên ngôn Agile</h3><p>Đánh giá cao:</p><ul><li><strong>Cá nhân và sự tương tác</strong> hơn là quy trình và công cụ. =&gt; Tính tự tổ chức, tự quản lý, duy trì động lực của các cá nhân là yếu tố then chốt</li><li><strong>Phần mềm chạy tốt</strong> hơn là tài liệu đầy đủ.</li><li><strong>Cộng tác với khách hàng</strong> hơn là đàm phán hợp đồng</li><li><strong>Phản hồi với các thay đổi</strong> hơn là bám sát kết hoạch</li></ul><p>Note: Agile không phủ nhận lợi ích của các vế bên phải, tuy nhiên những vế trái mới là những điều mà Agile tập trung vào.</p><h3 id="d-12-nguyen-tac-cua-Agile">d. 12 nguyên tắc của Agile</h3><ol><li>Ưu tiên cao nhất là làm hài lòng khách hàng thông qua việc bàn giao phần mềm/sản phẩm có giá trị trong thời gian sớm và liên tục.</li><li>Sẵn sàng cho những thay đổi - thậm chí những thay đổi này xuất hiện muộn. Quy trình Agile khai thác sự thay đổi này nhằm gia tăng tính cạnh tranh cho khách hàng.</li><li>Cung cấp phần mềm hoạt động được trong thời gian ngắn từ 1 vài tuần đến 1 vài tháng, càng ngắn càng được ưu tiên.</li><li>Người kinh doanh và đội ngũ phát triển phải làm việc cùng nhau mỗi ngày trong suốt dự án</li><li>Xây dựng dự án xung quanh những cá nhân có động lực. Cho họ môi trường làm việc thuận lợi và sự hỗ trợ cần thiết. Hãy có niềm tin rằng họ sẽ làm tốt công việc của mình.</li><li>Đối thoại trực tiếp mặt đối mặt là phương pháp hữu hiệu nhất trong việc truyền đạt thông tin.</li><li>Phần mềm chạy được là thước đo chính của tiến độ dự án.</li><li>Phát triển bền vững và duy trì việc phát triển liên tục.</li><li>Liên tục quan tâm đến kỹ thuật và thiết kế để tăng cường tính linh hoạt.</li><li>Đơn giản - nghệ thuật tối đa hóa số lượng công việc không làm - là điều cần thiết.</li><li>Các kiến trúc, yêu cầu và thiết kế tốt nhất được tạo nên từ các nhóm tự tổ chức.</li><li>Trong khoảng thời gian đều đặn, nhóm phản ánh về cách trở nên hiệu quả hơn, sau đó điều chỉnh cho phù hợp.</li></ol><h3 id="e-3-tru-cot-cua-Scrum">e. 3 trụ cột của Scrum</h3><p>Scrum được xây dựng trên thuyết thực nghiệm (mọi tri thức đều đến từ kinh nghiệm đã trải qua). Nhóm Scrum liên tục thăm dò và điều chỉnh hoạt động của mình.</p><p>3 trụ cột của Scrum:</p><ul><li><strong>Minh bạch</strong>: Mọi thông tin quan trọng cần rõ ràng với tất cả những bên liên quan đến phát triển sản phẩm</li><li><strong>Thanh tra</strong>: Thường xuyên thanh tra tiến độ để đạt được sprint goals và phát hiện những điểm bất thường ngoài ý muốn</li><li><strong>Thích nghi</strong>: Cần điểu chỉnh càng sớm càng tốt với những vấn đề đang gặp phải và những ý tưởng mới hữu ích cho nhóm</li></ul><h3 id="f-Tai-sao-can-Scrum">f. Tại sao cần Scrum</h3><ul><li>Độ trực quan cao. Vì những features đã được bàn giao ngay từ những bước đầu của việc phát triển sản phẩm</li><li>Giá trị kinh doanh cao. Vì ngay từ lúc còn đang phát triển người dùng vẫn có thể sự dụng sản phẩm. Và những giá trị này ngày càng được tích lũy cùng với tiến độ của dự án</li><li>Khả năng thay đổi linh hoạt cao.</li></ul><h2 id="2-Vong-doi-cua-mot-quy-trinh-Scrum">2. Vòng đời của một quy trình Scrum</h2><ul><li>Mỗi Sprint có độ dài không đổi, diễn ra liên tiếp, không bị gián đoạn.</li><li>Có thể tùy ý chọn độ dài (1, 2 ngày…4 tuần) của một Sprint nhưng không dài quá 4 tuần.</li><li>Sprint được đóng khung về thời gian, không được phép kéo dài hay rút ngắn thời gian.</li><li>Không cho phép thêm bất cứ hạng mục nào được thêm vào trong sprint.</li></ul><h2 id="3-Cac-vai-tro-trong-nhom-Scrum">3. Các vai trò trong nhóm Scrum.</h2><ul><li><p>Một nhóm Scrum chỉ có 3 vai trò:</p><ul><li>Scrum master</li><li>Product Owner</li><li>Development team</li></ul></li><li><p>Các cá nhân trong nhóm Scrum không được phân biệt theo chuyên môn, mà tất cả đều gọi chung là thành viên nhóm Scrum.</p></li><li><p>2 đặc điểm của nhóm Scrum:</p><ul><li><strong>Tự tổ chức</strong>: Được trao quyền để tự ra quyết định, tự quản lý, tổ chức công việc.</li><li><strong>Liên chức năng</strong>: nhóm có đầy đủ những kỹ năng cần thiết để hoàn thành sprint goal mà không cần đến sự trợ giúp từ bên ngoài</li></ul></li></ul><h3 id="a-Scrum-Master">a. Scrum Master</h3><ul><li><p>Scrum Master là gì?</p><ul><li>Đảm bảo Scrum hoạt động tốt</li><li>Tháo gỡ những trở ngại</li><li>Không trực tiếp sản xuất</li><li>Không phải quản lý nhóm mà là lãnh đạo theo phong cách phục vụ.</li></ul></li><li><p>Scrum Master phục vụ:</p><ul><li>Product Owner bằng cách:<ul><li>Đào tạo PO quản lý (tool, làm mịn, viết user story…) backlog hiệu quả</li><li>Hướng dẫn lập kế hoạch sản phẩm: tầm nhìn, chiến lược của sản phẩm.</li><li>Giúp trao đổi, giao tiếp với Development team một cách hiệu quả.</li></ul></li><li>Development team bằng cách:<ul><li>Đào tạo Scrum cho team members và đảm bảo họ tham gia đầy đủ, hiệu quả các events của Scrum</li><li>Tìm kiếm và sử dụng hiệu quả các công cụ, con người hỗ trợ</li><li>Đảm bảo việc trang bị các kỹ thuật, dụng cụ, tài nguyên để phát triển tốt</li><li>Bảo vệ team để không thay đổi, gián đoạn công việc trong một Sprint</li></ul></li><li>Tổ chức bằng cách:<ul><li>Nâng cao năng lực Scrum ở tổ chức: đào tạo, tạo nhóm học tập</li></ul></li></ul></li><li><p>Scrum Master có thể là đảm nhiệm công việc của thành viên trong Development team, nhưng <strong>tuyệt đối không được</strong> kiêm nhiệm vai trò Product Owner</p></li></ul><h3 id="b-Product-Owner">b. Product Owner</h3><ul><li>Product Owner là ai?<ul><li>Là một người duy nhất chứ không phải là một nhóm người. và là người định hướng sản phẩm, tầm nhìn của sản phẩm.</li><li>Có nhiệm vụ tối ưu hóa giá trị của sản phẩm bằng việc tận dụng khả năng sản xuất của development team một cách tốt nhất.</li><li>Là người duy nhất quản lý Product Backlogs.</li></ul></li><li>Nhiệm vụ:<ul><li>Trình bày rõ ràng những features của sản phẩm.</li><li>Sắp xếp độ ưu tiên của các features.</li><li>Luôn sẵn sàng giải thích các features trong product backlog.</li><li>Theo dõi và giải trình tiến độ phát triển sản phẩm.</li></ul></li></ul><p>Note: Chỉ duy nhất PO có quyền kết thúc Sprint hiện tại một cách đột ngột.</p><h3 id="c-Development-team">c. Development team</h3><ul><li>Có nhiệm vụ làm việc và chuyển giao các phần tăng trường hoàn thành</li></ul><h2 id="4-Cac-khai-niem">4. Các khái niệm</h2><h3 id="a-Product-Backlog">a. Product Backlog</h3><ul><li>Là nơi lưu trữ các features mong muốn của sản phẩm. Chúng được sắp xếp dựa trên độ ưu tiên của từng feature.</li><li>PO là người duy nhất được quản lý Product Backlog: nội dung, sắp xếp, làm mịn, làm rõ…</li><li>User story thường được sử dụng để thể hiện một feature của PB</li><li>Tiêu chuẩn <strong>DEEP</strong> để xây dựng một Product Backlog tốt:<ul><li>Detail appropriate: đủ chi tiết hợp lý.</li><li>Estimated: được ước tính (Point, Day, Hour…)</li><li>Emergent: tiến hóa (thêm, bớt, bổ sung, cập nhật… các User Story trong Product Backlog)</li><li>Prioritized: sắp xếp theo độ ưu tiên</li></ul></li></ul><h3 id="b-Sprint-backlog">b. Sprint backlog</h3><ul><li>Là những hạng mục được chọn trong Product Backlog và những công việc development team cần thực hiện trong 1 Sprint.</li><li>Do Development team sở hữu và vận hành.</li><li>Được cập nhật liên tục hàng ngày.</li></ul><h3 id="c-Phan-tang-truong-cua-san-pham">c. Phần tăng trưởng của sản phẩm</h3><ul><li>Là phần tăng trưởng của sản phẩm có khả năng chuyển giao được cuối mỗi Sprint.</li><li>Phần tăng trưởng chỉ được coi là hoàn thành khi đạt được DoD.</li><li>Lợi ích:<ul><li>Nhận được phản hồi sớm từ người dùng, khách hàng =&gt; có thể điểu chỉnh sớm</li><li>Sớm thu được giá trị của sản phẩm.</li><li>Tăng tính minh bạch trong quá trình sản xuất.</li><li>Giảm rủi ro cả về kinh doanh và kỹ thuật.</li></ul></li></ul><h2 id="5-Cac-su-kien">5. Các sự kiện</h2><h3 id="a-Planning">a. Planning</h3><p>Trong buổi Planning cần làm 2 việc:</p><ul><li>Xác định Sprint Goal</li><li>Kế hoạch công việc:<ul><li>Toàn bộ nhóm Scrum tham gia lựa chọn các việc trong Product Backlog cần làm trong Sprint.<ul><li>Để nhóm có quyết định chính xác hơn, PO cần làm rõ số lượng PBs nhiều hơn số lượng PBs mà team có thể đạt được trong 1 Sprint</li></ul></li><li>Scrum master và development team thảo luận cách hoàn thành những việc đó như thế nào. PO có thể vắng mặt nhưng cần sẵn sàng giải đáp khi cần.<ul><li>Có thể sử dụng đơn vị <strong>Point</strong> hoặc <strong>Giờ</strong> để estimate cho các tasks.</li></ul></li></ul></li></ul><p>Với Sprint 1 tháng thì planning kéo dài tối đa trong <strong>8h</strong>. Những Sprint ngắn hơn thì thời gian cũng ngắn hơn.</p><h3 id="b-Daily-Scrum">b. Daily Scrum</h3><ul><li>Yêu cầu tất cả thành viên của development team. PO, SM có thể tham gia hoặc không.</li><li>Kéo dài không quá 15p</li></ul><h3 id="c-Sprint-Review">c. Sprint Review</h3><ul><li>Mục đích: Thanh tra và thích nghi sản phầm</li><li>Thành phần: PO, SM, Development team và có thể có thêm khách hàng, người dùng, lãnh đạo…</li><li>Thông thường 1 tuần làm việc thì thời gian buổi review tối đa là 1h. VD: Sprint 4 tuần kéo dài tối đa là 4h…</li><li>Sprint Review không chỉ là việc demo sản phẩm mà là buổi để những người tham gia trực tiếp thanh tra, thảo luận, đóng góp ý kiến cho việc phát triển tiếp theo.</li><li>Sprint demo được tổ chức tại cuối của Sprint. Các bên tham gia bao gồm: toàn bộ Scrum team, PO, Scrum master, toàn bộ Stakeholders, management and developers from other teams.</li></ul><h3 id="d-Retrospective">d. Retrospective</h3><ul><li>SM và Development team bắt buộc tham gia. PO có thể tham gia hoặc không.</li><li>Sprint 1 tháng tối đa kéo dài trong 3h. Thường 1 tuần làm việc thì thời gian retro tối đa khoảng 45phút.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Management </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Scrum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Đọc sách thông minh</title>
      <link href="/Book/2021/10/27/doc-sach-thong-minh/"/>
      <url>/Book/2021/10/27/doc-sach-thong-minh/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/doc-sach-thong-minh/doc-sach-thong-minh.png" alt="doc-sach-thong-minh"></p><h2 id="Tong-quan">Tổng quan</h2><ul><li>Nên đọc sách với mục đích mở mang kiến thức, nuôi dưỡng tâm hồn hơn.</li><li>Mỗi con người tại mỗi thời gian với những trải nghiệm khác nhau sẽ học được những thứ khác nhau. Chúng ta vẫn luôntìm được những bài học mới trong những quyển sách cũ.</li><li>Việc đọc xong một quyển sách khó mà không hiểu gì cả sau khi gấp sách là chuyện bình thường. Nhưng ít nhất là chúng ta nên biếtquyển sách đó nói về điều gì để sau này khi cần đào sâu thêm thì sẽ lôi ra xử lý kĩ hơn.</li><li>Sách nên có sẵn trong tủ sách, balo, bàn làm việc, điện thoại là cực kỳ quan trọng. Mọi việc bạn sẽ làm ngay nếu nó chỉ tốn của bạn dưới 2 phút.Nếu nhiều hơn 2 phút thì khả năng bạn sẽ “mất hứng” là rất cao.</li><li>Tạo thói quen đọc sách bằng “Vòng lặp thói quen”: Gợi ý -&gt; hành động lặp lại -&gt; phần thưởng. Vòng lặp này thường được thực hiện liên tục trongvòng 66 ngày sẽ trở thành thói quen.</li><li>Có thể đọc nhiều cuốn cùng chủ để 1 lúc mà k nhất thiết phải đọc xong 1 cuốn rồi mới sang cuốn khác.</li><li>Tham gia các hội chợ sách, chợ phiên sách cũ, các thư viện thanh lý sách cũ, hiệu sách giảm giá để mua về. Chưa đọc luôn cũng hay mua.</li></ul><h2 id="Cach-doc-sach-nhanh">Cách đọc sách nhanh</h2><ul><li>Đọc lướt bằng mắt để chụp lại hình ảnh sẽ giúp đọc nhanh hơn. Không nên đọc thành tiếng, đọc to trong đầu vì nó khiến ta đọc từng từ một nêngiảm tốc độ xuống.</li><li>Nếu đoạn nào quan trọng mà chưa hiểu có thể đọc lại chậm hơn.</li><li>Việc cố hiểu thật kỹ rồi mới chuyển cũng là điều khiến chúng ta chậm lại. Vì thế hãy cứ đọc lướt vài trang sau đó các kiến thức sẽ liên kếtlại với nhau và chúng ta sẽ hiểu chúng dễ hơn.</li><li>Khi đọc trong thời gian hữu hạn, cốt lấy ý chính, đừng chú ý vào tiểu tiết. Các tiêu đề, từ nhấn mạnh, biểu đồ chính là những chỗ lưu ý chính.</li><li>Kỹ thuật đọc lướt để lấy thông tin có kiểm soát có 5 bước:<ul><li>B1: Tìm hiểu về cuốn sách</li><li>B2: Đặt câu hỏi tò mò về cuốn sách</li><li>B3: Đọc nhanh</li><li>B4: Xem lại các ý chính và bổ sung thông tin</li><li>B5: Ôn tập - Dùng những ghi chép về ý chính, nội dung để áp dụng</li></ul></li><li>Kỹ thuật đọc phân tích giúp hiểu kỹ và đọc sâu cuốn sách. Sau khi đọc xong phải trả lời được 4 câu hỏi:<ul><li>Tổng quan cuốn sách viết về gì?</li><li>Ý chính của cuốn sách?</li><li>Cuốn sách có đúng k? đúng một phần hay toàn bộ?</li><li>Ý nghĩa của cuốn sách là gì?</li></ul></li></ul><h2 id="Cach-ghi-nho-noi-dung-sach">Cách ghi nhớ nội dung sách</h2><h3 id="1-Ghi-chu-Cornell-note">1. Ghi chú Cornell note</h3><p><img src="/images/doc-sach-thong-minh/cornell-note.png" alt="cornell-note"></p><p>B1: Chia tờ giấy thành 3 phần:</p><ul><li>Header: Ghi thông tin ngày tháng, thông tin sách…</li><li>Body: Ghi thông tin chính</li><li>Footer: Ghi thông tin tóm tắt, tổng kết</li></ul><p>B2: Chia body thành 2 cột</p><ul><li>Cột bên trái ghi câu câu hỏi hoặc từ khóa.</li><li>Cột bên phải ghi các thông tin trả lời cho các câu hỏi.</li></ul><p>Trước và trong quá trình đọc hãy đặt các câu hỏi và ghi các từ khóa vào phần body. Sau khi đọc xong sách hãy cố gắng tóm tắt lạibằng ý hiểu của mình vào footer.</p><h3 id="2-Ghi-chu-bang-mindmap">2. Ghi chú bằng mindmap</h3><p><img src="/images/doc-sach-thong-minh/mindmap.png" alt="mindmap"></p><ul><li>Tool tạo <a href="https://miro.com/app/dashboard/" title="Mindmap online">Mindmap online</a></li></ul><h3 id="3-Ghi-nho-bang-giay-dan">3. Ghi nhớ bằng giấy dán.</h3><ul><li>Khi đọc sách gặp những đoạn muốn note lại thì dùng sticky để ghi chép lại. Khi đọc xong thì hãy tổng hợp chúng lại thành một bản thống nhất.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
            <tag> DocSachThongMinh </tag>
            
            <tag> DuongTrongTan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vị giám đốc một phút</title>
      <link href="/Book/2021/08/10/vi-giam-doc-mot-phut/"/>
      <url>/Book/2021/08/10/vi-giam-doc-mot-phut/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/vi-giam-doc-mot-phut.png" alt="vi-giam-doc-mot-phut"></p><p>Có 2 yếu tố cần cho một người quản lý giỏi:</p><ul><li>Quan tâm đến chỉ tiêu đưa ra, những kế hoạch phải hoàn thành =&gt; được cấp trên tín nhiệm và cho rằng là giám đốc giỏi.</li><li>Tình cảm với nhân viên =&gt;được nhân viên ca tụng hết lời.</li></ul><p>=&gt; Khi dung hòa được 2 yếu tố trên vừa đảm bảo được lợi ích cho công ty vừa đảm bảo được quyền lợi cho nhân viên. Để làm được việc đó có thể áp dụng 3 bí quyết bên dưới.</p><h2 id="1-Bi-quyet-thu-nhat-Lap-muc-tieu-mot-phut-nen-tang-de-quan-ly-hieu-qua">1. Bí quyết thứ nhất: Lập mục tiêu một phút - nền tảng để quản lý hiệu quả</h2><p>Trong buổi họp hàng tuần cùng nhân viên, nghe nhân viên báo cáo công việc tuần vừa qua và cùng nhau phân tích, tháo gỡ những vướng mắc đang gặp phải. Sau đó sẽ lên mục tiêu cho tuần tiếp.</p><p>Lập mục tiêu một phút:</p><ul><li>Xác định mục tiêu. (mục tiêu cần rõ ràng, có thể thực hiện được và thể hiện qua những từ cân đong đó đếm được).</li><li>Xem xét giải pháp thích hợp nhất cho mục tiêu ấy.</li><li>Mô tả rõ từng mục tiêu trên mỗi trang giấy A4, tối đã 250 từ.</li><li>Kiểm tra kỹ từng mục tiêu để đảm bảo rằng việc chúng ta đọc chúng chỉ mất một phút.</li><li>Mỗi ngày dành một phú để đánh giá thành quả công việc của mình.</li><li>Kiểm tra kết quả những việc mình làm có phù hợp với mục tiêu đã đề ra hay không?</li></ul><p>Lợi ích:</p><ul><li>Mong muốn đầu tiên của mọi người là phản hồi kết quả công việc. Nhờ mục tiêu một phút, mọi người thường xuyên xem xét mục tiêu của họ, đồng thời có thể tự kiểm tra xem việc thực thi công việc của họcó bám sát với mục tiêu đã đặt ra hay không?</li><li>Khi cảm thấy hài lòng về bản thân, mọi người sẽ làm việc hiệu quả hơn gấp bội. Việc đạt được mục tiêu đó, sẽ giúp nhân viên sẽ cảm thấy vui sướng và hài lòng.</li></ul><h2 id="2-Bi-quyet-thu-hai-Mot-phut-khen-ngoi">2. Bí quyết thứ hai: Một phút khen ngợi</h2><p>Thường chỉ cần khen ngợi những khi nhân viên mới khi họ làm đúng hoặc gần đúng. Còn những nhân viên đã quen với môi trường và công việc thì có thể ít hơn. Vìkhi đó hãy để họ tự khen ngợi mình khi họ làm tốt. Hơn nữa khi đã quen việc thì có rất nhiều cách để quản lý độ hiệu quả của nhân viên. Trình tự để khen ngợi hiệu quả:</p><ul><li>Ngay từ lúc ban đầu, hãy cho nhân viên biết bạn sẽ để ý đến việc làm của họ.</li><li>Khen tặng họ ngay khi họ làm đúng.</li><li>Nói cho họ biết họ đã làm đúng điều gì, nêu chính xác lý do mà bạn ngợi khen họ.</li><li>Cho họ biết bạn cảm thấy vui thế nào khi họ làm đúng và việc làm đó có tác động như thế nào đối với công ty và những đồng nghiệp khác.</li><li>Dừng lại một lát để họ cảm nhận được cảm giác vui vẻ cảu bạn.</li><li>Khích lệ họ tiếp tục làm tốt như vậy.</li><li>Nên bắt tay hoặc vỗ vai để cho nhân viên của bạn thấy rằng bạn luôn ủng hộ họ thành công. (Cần thiết để tỏ sự thân thiện, quan tâm)</li></ul><h2 id="3-Bi-quyet-thu-ba-Mot-phut-khien-trach">3. Bí quyết thứ ba: Một phút khiển trách</h2><p>Để một phút khiển trách có tác dụng:</p><ol><li><p>Nói trước với nhân viên rằng dứt khoát bạn sẽ khiển trách họ khi họ phạm lỗi.</p></li><li><p>Khi nhân viên phạm lỗi, bạn thực hiện một phút khiển trách:</p></li></ol><ul><li><p>Phần một:</p><ul><li>Khiển trách hành vi của họ ngay lập tức.</li><li>Nói rõ họ đã làm sai điều gì.</li><li>Nói cho họ biết cảm giác của bạn bằng thái độ dứt khoát.</li><li>Ngưng một vài giây, giữ im lặng cho họ cảm nhận được những gì bạn nói.</li></ul></li><li><p>Phần hai:</p><ul><li>Nên bắt tay hoặc vỗ vai để người nhân viên hiểu bạn thực sự đứng về phía bạn.</li><li>Nhắc cho họ biết bạn đánh giá bản thân họ rất cao.</li><li>Nhưng riêng trong trường hợp vừa rồi bạn không tán thành hành vi của họ.</li></ul></li></ul><ol start="3"><li>Khi khiển trách xong ta sẽ không nhắc lại lỗi cũ của nhân viên.</li></ol><p>Lợi ích:</p><ul><li>Nhân viên có thể “nghe” được phản hồi từ Sếp đúng lúc.</li><li><code>Khiển trách một hành vi sai</code> của nhân viên (không được khiển trách cả con người), thì sẽ dễ dàng nói rõ cảm xúc và có thái độ công bình hơn đối với nhân viên.</li></ul><blockquote><p>Nếu ngay từ ban đầu, quản lý tỏ ra nghiêm khắc với từng hành vi của nhân viên, rồi sao đó lại tỏ ra ủng hộ bản thân họ, thì sẽ quản lý họ được hiệu quả hơn.</p></blockquote><h2 id="4-Note">4. Note:</h2><blockquote><p>Bản chất của kiến thức suy cho cùng chính là biết cách áp dụng chúng vào trong thực tiễn cuộc sống</p><p>— Khổng tử. —</p><p>Anh không muốn nghe chú than phiền mà chỉ muốn chú diễn tả một cách cụ thể, rõ ràng điều gì đã xảy ra, bằng những từ cân đong đo đếm được.Nếu chú không xác định được bản thân mình mong muốn sự việc xảy ra như thế nòa thì rõ ràng chú chưa gặp khó khăn thật sự mà chỉ đang than thở thôi.Khó khăn chỉ tồn tại thực sự khi những gì xảy ra trong thực tế khác với những gì ta mong đợi.</p><p>Mục tiêu ĐỊNH HƯỚNG hành động</p><p>Kết quả CHỨNG MINH hành động</p></blockquote><ul><li><p>Không bao giờ quyết định thay cho người khác, chỉ hướng họ tự tìm ra con đường đến đích.</p></li><li><p>Khi tuyển dụng chỉ chọn 2 loại người:</p><ul><li>Tuyển những người giỏi, nhưng sẽ khó kiếm và phải trả họ lương cao.</li><li>Tuyển những người có tiềm năng, sau đó sẽ đào tạo họ trở lên giỏi.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
            <tag> ViGiamDocMotPhut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sức mạnh sự mơ hồ và bí ẩn</title>
      <link href="/Book/2021/08/09/suc-manh-su-mo-ho-va-bi-an/"/>
      <url>/Book/2021/08/09/suc-manh-su-mo-ho-va-bi-an/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/suc-manh-cua-su-mo-ho.jpeg" alt="suc-manh-cua-su-mo-ho"></p><h1>1. Bạn có thích cuốn sách? Tại sao?</h1><p>Bình thường.</p><p>Không thích cách viết của sách: văn phong, từ ngữ dễ gây hiểu nhầm. Dẫn chứng dựa nhiều trên cơ sở lý thuyết</p><h1>2. Bạn mong đợi điều gì ở cuốn sách?</h1><p>Thực dụng hơn, nhiều case study hơn, rõ ràng hơn nữa. nhưng nhớ lại tên cuốn sách là sức mạnh của sự mơ hồ và bí ẩn.</p><h1>3. Mô tả tóm tắt những nội dung chính của cuốn sách.</h1><p>Trong cuộc sống luôn gặp những sự mơ hồ, bí ẩn. Khi đối mặt với chúng con người thường có nhu cầu kết thúc chúng thật nhanh để hướng chúng đến những sự rõ ràng, nhất quán. Con người có 2 cách đối mặt với chúng: 1 là chấp nhận sự mơ hồ thay đổi tư duy hiểu biết của mình, 2 là hờ hững và bỏ qua nó (mặc dù bản thân đã nhận ra sự sai sót đó). Khi môi trường tác động, bị áp lực ví dụ thời gian kết thúc vấn đề thường chúng ta sẽ đưa ra những kết luận theo hướng mà chúng ra mong muốn dù cho những thông tin có được đang đi ngược lại với những điều chúng ta tin. mục đích chỉ là thoát khỏi sự mơ hồ. từ đó những quyết định thường không chính xác. Nhưng nếu không bị chịu về áp lực thì quyết định sẽ chính xác hơn, sáng tạo hơn.</p><p>Tiền nhân từ trước đến này đã dạy: “mọi chuyện cần suy nghĩ, tính toán chín chắn trước khi quyết định”. Quyển sách này như một phần nhắc nhở lại với bản thân. Khi phải đưa ra quyết định hãy luôn đặt thật nhiều câu hỏi, tìm kiếm sự tương đồng để tìm ra giải pháp, nghĩ nó 1 cách thấu đáo nhất và đặc biệt hãy giữ bản thân thật thoải mái và nếu còn vướng bận thì hãy chờ đợi, không nên quyết định bừa.</p><h1>4. Một vài ý thích</h1><ul><li>Chúng ta có thể nhận thức được tương lai bất định bằng cách xây dựng phương pháp phản ứng nhanh trước thay đổi, chứ k phải cố gắng dự đoán. Dưới những điều kiện đúng, sự mơ hồ có thể mang lại cơ hội cách tân, truyền cảm hứng sáng tạo…</li><li>Trong một nhóm khi bắt buộc phải giải quyết 1 vấn đề mơ hồ mà phải chịu áp lực về thời gian, người ta thường có xu hướng tôn sùng một người độc tài ra quyết định nhanh gọn hơn. Hay cũng trong trường hợp đó nếu một người đưa ra ý kiến trái ngược lại đa số nhóm thì ý kiến đó mặc dù hay cũng thường sẽ bị phớt lơ, và xem thường.</li><li>Thất bại buộc chúng ta tái thẩm định lại những niềm tin vững chắc đã cũ kỹ khi mọi thứ không diễn ra theo kế hoạch. Nó đòi hỏi chúng ta nghi ngờ những nguyên nhân mà chúng ta cho rằng mình đã hiểu rõ</li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
            <tag> JamiesHolmes </tag>
            
            <tag> SucManhCuaSuMoHoVaBiAn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phi Lý Trí</title>
      <link href="/Book/2021/04/06/phi-ly-tri/"/>
      <url>/Book/2021/04/06/phi-ly-tri/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/phi-ly-tri/phi-ly-tri-cover.jpeg" alt="phi-ly-tri-cover.jpeg"></p><h2 id="Khai-quat">Khái quát</h2><ul><li>Chúng ta đôi khi phi lý trí hơn chúng ta tưởng, thậm chí là thường xuyên phi lý trí và phi lý trí có hệ thống (được lặp đi lặp lại) và có thể dự đoán trước.</li><li>Cuốn sách giúp người đọc phải suy nghĩ kỹ hơn về những hành vi, sai lầm của mình để sống hợp lý và tốt đẹp hơn.</li></ul><h2 id="Chuong-1-Su-that-ve-tinh-tuong-doi">Chương 1: Sự thật về tính tương đối.</h2><ul><li><p>MỌI THỨ ĐỀU CÓ TÍNH TƯƠNG ĐỐI.</p></li><li><p>Theo kinh tế học thì con người luôn luôn tìm ra những thứ, những cách có giá trị tốt nhất để thực hiện. Tuy nhiên kinh tế học hành vi lại cho rằng con người vẫn luôn có những hành động phi lý trí theo bản năng.</p></li><li><p>Con người ít khi đưa ra lựa chọn cái gì đó (cả vật hữu hình hay những thứ vô hình như trải nghiệm, tình cảm, thái độ, quan điểm…) theo một tiêu chuẩn tuyệt đối.Chúng ta không biết mọi thứ có giá trị là bao nhiêu. Thay vào đó chúng ta tập trung vào ưu thế tương đối của vật này so với vật kia và ước tính giá trị của nó.Tuy nhiên chúng ta lại tập trung vào so sánh những thứ có thể dễ dàng so sánh và luôn tránh so sánh những thứ không dễ so sánh.</p></li><li><p>Lựa chọn nền (Vật làm nền) là lựa chọn được đưa thêm vào để nhằm mục đích làm nổi bật lựa chọn mà muốn focus. Chúng gần giống với lựa chọn focus nhưng sẽkém hơn một vài điểm mà <code>RẤT DỄ</code> so sánh. Từ đó lựa chọn focus tạo cảm giác sẽ là lựa chọn tốt nhất trong tất cả các lựa chọn.</p></li></ul><p><img src="/images/phi-ly-tri/compare-attribute.png" alt="compare-attribute.png"></p><blockquote><p>thuộc tính -A được thêm vào để làm nổi bật A để gọi ý chọn nó: A không chỉ tốt hơn -A mà còn tốt hơn cả B.</p></blockquote><ul><li>Đứng trước 3 lựa chọn, hầu hết mọi người sẽ chọn phương án trung gian. (tivi có giá: $690 , <code>$850</code>, $1480)</li><li>Các món ăn có đơn giá cao hơn trên thực đơn sẽ giúp tăng doanh thu cho nhà hàng ngay cả khi không khách hàng nào lựa chọn món đó cả.Bằng cách tạo ra món ăn đắt tiền nhất, chủ nhà hàng có thể lôi kéo thực khách đặt món ăn đắt thứ hai.</li></ul><h2 id="Chuong-2-Quan-diem-sai-giua-cung-va-cau">Chương 2: Quan điểm sai giữa cung và cầu</h2><ul><li><p>Để khiến một người thèm thuồng thứ gì đó, chỉ cần làm cho việc đó trở lên khó khăn</p></li><li><p>Hiện tượng khắc sâu. Con người có sẽ khắc sâu với những ấn tượng và quyết định ban đầu.</p></li><li><p>Mỏ neo. Chỉ khi chúng ta bắt đầu đưa ra quyết định muốn mua 1 sản phầm với giá X thì lúc đó X sẽ trở thành mỏ neo. Chiếc mỏ neo đầu tiên không chỉ hướng tới quyết định mua ngay lúc đó mà còntới nhiều quyết định theo sao khác. Nó sẽ có tác dụng lâu dài đối với giá hiện tại và trong tương lai. Vì thế chúng ta nên đặc biệt chú ý cân nhắc đến những quyết định đầu tiên này.</p></li><li><p>Những người chuyển tới một thành phố mới đều giữ mức chi trả cho nhà ở như ở thành phố cũ.</p></li><li><p>Hành vi bày đàn xảy ra khi chúng ta cho rằng một điều gì đó là tốt (hoặc xấu) căn cứ vào hành vi trước của người khác và chúng ta sẽ hành động theo sau cho phù hợp.Nhưng cũng có một hành vi bày đàn khác là tự bày đàn. Nó xảy ra khi chúng ra cho rằng một điều gì đó tốt (hoặc xấu) căn cứ vào hành vi trước đây của chính mình (ví dụ như lần đầu đi ăn ởmột quán nào đó bạn thấy ngon, thì những lần sau bạn sẽ lại quay lại sử dụng quán ăn đó)</p></li><li><p>Chúng ta có thể cải thiện tích cực các hành vi phi lý trí của mình bằng việc chất vấn các thói quen hàng ngày (kiểm tra lại những mỏ neo của mình). Nó bắt đầu thế nào? Nó có dễ chịu nếu từ bỏ thói quen đó? Trên thực tế bạn nênđặt câu hỏi cho các hành vi lặp đi lặp lại của mình. Chọn điện thoại có nhất thiết là phải đẹp không? cà phê hay trang phục có nhất thiết phải là loại đắt tiền không? Trước kia nó có thể dãrất đúng nhưng hiện tại thì sao?</p></li><li><p>Mức độ hài lòng về lương của nhân viên dựa vào sự so sánh với lương của những người họ biết hay liên quan.</p></li></ul><h2 id="Chuong-3-Cai-gia-cua-mien-phi">Chương 3: Cái giá của miễn phí</h2><ul><li>Khi có được một món đồ miễn phí chúng ta thường thấy rất phấn khởi. Nhưng giá 0 đồng còn là một cảm xúc nóng - một nguồn kích thích phi lý trí.</li><li>Bản chất con người sợ mất mát, mà hàng miễn phí thì sẽ không bị mất gì. Vì thế hàng miễn phí luôn cho ta cảm giác nó có giá trị hơn rất nhiều so với giá trị thực của nó.</li><li>Khái niệm con số 0 còn áp dụng cho thời gian. Thời gian dành cho một hoạt động, bản chất cũng là lấy từ một hoạt động khác. Nếu dành nhiều thời gian để lấy được các hàng miễn phí nhưngkhông có quá nhiều giá trị với bản thân thì thực sự là không đáng.</li></ul><h2 id="Chuong-4-Cai-gia-cua-cac-quy-chuan-xa-hoi">Chương 4: Cái giá của các quy chuẩn xã hội</h2><ul><li>Chúng ta đồng thời sống trong hai thế giới khác nhau: một với các quy chuẩn xã hội chiếm ưu thế và một với quy chuẩn thị trường tạo ra quy tắc.</li><li>Khi chúng ta đặt quy chuẩn xã hội và quy chuẩn thị trường trên hai con đường riêng biệt, cuộc sống trở lên tốt đẹp hơn.</li><li>Khi các quy chuẩn xã hội và thị trường va chạm nhau, thì vấn đề sẽ nảy sinh.</li><li>Đúng với quy chuẩn thị trường, những người nhận tiền cao hơn trung bình sẽ làm việc tốt hơn. Nhưng những người làm việc với tiêu chuẩn xã hội (làm giúp…) thì kết quả của họ tốt hơn tất thảy.</li><li>Văn phòng luật sư sẽ không đồng ý giảm giá cho những người nghỉ hưu gặp khó khăn, nhưng lại sẵn sàng giúp đỡ họ một cách miễn phí.</li><li>Một khi các quy chuẩn thị trường được thâm nhập vào sự cân nhắc của chúng ta, các quy chuẩn xã hội sẽ tự động không còn chỗ đứng. Nó sẽ làm tổn thương các mối quan hệ,và khi đó sẽ rất khó để khôi phục lại mối quan hệ xã hội đó. Để làm nổi bật quy chuẩn thị trường, chỉ cần đề cập đến tiền là đủ (ngay cả khi tiền không được trao tay).</li><li>Thực tế những người làm việc dưới đặc điểm thị trường: ích kỷ và tự lực hơn. Họ muốn dành thời gian một mình nhiều hơn, họ có xu hướng chọn những bải tập đòi hỏi nguồn lực cá nhân hơn là đồng đội. và khi đang phảiquyết định chọn chỗ ngồi, họ sẽ chọn những chỗ ngồi cách xa khỏi người được yêu cầu làm việc cùng.</li><li>Khi áp dụng mức phạt cho các phụ huynh đón con muộn sẽ càng khiến cho việc đón muộn càng trở lên phổ biến hơn. Vì khi đó quy chuẩn xã hội (đón con muộn sẽ ngại với các giáo viên) đã chuyển sangquy chuẩn thị trường (bị phạt tiền - họ nghĩ đã trả tiền cho sự chậm trễ nên sẽ không cần phải khẩn trương đến đón con). Và tệ hơn nữa khi nhà trường bỏ việc phạt tiền thì việc đón muộn còn tănglên nữa.</li><li>Quy chuẩn xã hội là cách tốt nhất để khiến nhân viên trung thành và hăng say làm việc.</li><li>Trong việc đối xử với các nhân viên của mình, các công ty phải hiểu cam kết dài hạn có ý nghĩa thế nào. Nếu các nhân viên hứa hẹn sẽ làm việc chăm chỉ hơn đểđảm bảo tiến độ (thậm chí hủy bỏ việc gia đình cho mục tiêu đó),… thì đáp lại, họ cũng phải nhận được sự giúp đỡ khi ốm đau, hoặc cơ hội giữ được công việccủa mình khi thị trường đe dọa lấy mất công việc của họ</li><li>Tặng quà cho nhân viên sẽ đem lại nhiều lợi ích (làm việc chăm chỉ hơn, trung thành với công ty hơn…) hơn việc tặng tiền. Dù việc tặng tiền được nhiều người thích hơn.</li><li>Dùng tiền thưởng là cách “đắt” nhất để khuyến khích mọi người. Các quy chuẩn xã hội không chỉ “rẻ” hơn mà còn hiệu quả hơn rất nhiều.</li><li>Không ai thấy bị xúc phạm vì món quà nhỏ, vì ngay cả món quà nhỏ cũng giữ chúng ta tránh khỏi các quy chuẩn thị trường</li><li>Mọi người thường làm việc vì một lý do nào đó hơn là vì tiền bạc. Chúng ta đều biết, chỉ vì đồng lương sẽ không thể tạo ra được động lực cho mọi người mạo hiểm cuộc sống,mà chính vì những tự hào nghề nghiệp, nâng cao xứ mệnh, ý thức trách nhiệm… Đây cũng chính là điểm trên cùng của tháp maslow</li></ul><h2 id="Chuong-5-Anh-huong-cua-su-hung-phan">Chương 5: Ảnh hưởng của sự hưng phấn.</h2><ul><li>Bình thường chúng ta tưởng là đã hiểu được chính mình. Nhưng trong trạng thái phấn khích mãnh liệt, bỗng nhiên có một sự chuyển đổi nội tại nào đó và mọi thứ thay đổi.</li><li>Chúng ta phải thận trọng với những tình huống mà ngày Hyde bên trong chúng ra kiểm soát. Khi sếp phê bình chúng ta trước mặt mọi người, có thể chúng ta sẽ đáp trả lại bằng một email với nhữnglời lẽ phản bác kịch liệt. Liệu sẽ tốt hơn chăng nếu chúng ta lưu bức thư đó vào mục thư nháp vài ngày?</li><li>Tránh khỏi sự cám dỗ sẽ dễ dàng hơn là vượt qua nó.</li><li>Không tồn tại con người nhất thể. Thực tế, chúng ta là tổng thể của rất nhiều cái tôi. Cần nhận thức được rằng chúng ta có nguy cơ đưa ra quyết định sai khi bị kiểm soát hoàn toàn bởicảm giác mãnh liệt có thể giúp chúng ta.</li></ul><h2 id="Chuong-6-Van-de-cua-su-tri-hoan-va-tu-kiem-soat">Chương 6: Vấn để của sự trì hoãn và tự kiểm soát.</h2><ul><li>Ở trạng thái bình thường ta nghĩ sẽ giảm cân, dành 5h mỗi ngày để học tập, nhưng đến khi phải thực hiện, sự thích thú của ngủ, facebook… khiến ngài Hyde thức dậy. và chúng ta trì hoãn.</li><li>Việc hạn chế nghiêm ngặt quyền tự do bản thân là phương pháp tốt để chữa trị bệnh trì hoãn. Nhưng nếu chỉ cần trao cho mọi người một công cụ để họ có thể cam kết trước các thời hạn sẽ giúp đạt được kết quả tốt hơn.</li><li>Tại sao chúng ta liên tục thất bại trong việc đạt được các mục tiêu lâu dài của mình. Lý do là, không có các cam kết từ trước.</li></ul><blockquote><p>Cách tốt nhất để tránh việc trì hoãn bản thân là hãy cho mọi người cơ hội cam kết hành động của mình (cơ chế cam kết trước: chuyển tiền tiết kiệm ngay khi nhận lương,trả tiền trước khi thi chứng chỉ…). Cách này có thể không hiệu quả bằng cách làm độc đoán áp đặt nhưng nó giúp chúng ta đi đúng hướng</p></blockquote><h2 id="Chuong-7-Cai-gia-cua-su-so-huu">Chương 7: Cái giá của sự sở hữu</h2><ul><li>Hiệu ứng hàng đã có. Khi chúng ta sở hữu một thứ gì đó thì chúng ta luôn coi trọng giá trị của nó hơn những người khác. (Có liên quan đến việc khi mất đi một thứ gì đó ta thường xót hơn những ng ngoài. Vìcon người luôn lo sợ sự mất mát.)</li><li>Phần lớn cuộc đời chúng ta là dành cho việc sở hữu, nhưng đa phần chúng ta làm việc này rất kém vì:<ul><li>Chúng ta thướng yêu quý những gì chúng ta có.</li><li>Chúng ta tập trung vào những gỉ chúng ta có thể mất hơn là chúng ta có thể có.</li><li>Chúng ta cho rằng người khác sẽ nhìn nhận sự giao dịch đó từ góc độ của chúng ta.</li></ul></li><li>Sở hữu cũng có các đặc tính:<ul><li>Bạn càng bỏ nhiều công sức cho một việc gì đó, bạn càng cảm thấy sự sở hữu dành cho nó tăng lên. (Hiệu ứng Ikea)</li><li>Chúng ta có thể ảo tưởng về quyền sở hữu ngay cả trước khi chúng ta sở hữu một cái gì đó.</li><li>Không giới hạn ở việc sở hưu đồ vật, nó cũng đúng với các quan điểm.</li></ul></li></ul><blockquote><p>Cách giải quyết sự sở hữu là nhìn nhận các giao dịch (đặc biệt là giao dịch lớn) như thể mình không phải là người sở hữu chúng, đặt ra một khoảng cách nhất định giữa bản thân và món đồ đang quan tâm</p></blockquote><h2 id="Chuong-8-Luon-de-ngo-cac-lua-chon">Chương 8: Luôn để ngỏ các lựa chọn</h2><ul><li>Chúng ta rất sợ cảm giác mất mát, và chúng ta thường làm bất cứ điều gì để cứu vớt tình hình.</li><li>Con người luôn lo lắng không phải bởi vì họ thiếu cơ hội mà là vì họ có quá nhiều cơ hội.</li><li>Chúng ta luôn mong muốn biết nhiều, biết rộng. Nhưng khi nảy sinh ra vấn đề liệu sự trải nghiệm của chúng ta có quá mỏng manh không?</li><li>Lạ lùng hơn chúng ra còn ham muốn theo đuổi những cánh cửa mà không mang lại cho chúng ta lợi ích gì.</li></ul><blockquote><p>Thật ngốc nghếch nếu chúng ta cứ chạy loạn xạ để ngăn tất cả các cánh cửa không bị đóng lại. Điều mà ta cần làm là chủ động đóng lại một số cánh cửa. Nhưng khi các cánh cửa tương đương nhau,chúng ta phân vân không biết nên chọn cánh cửa nào, thì điều tiếp theo chúng ta phải làm là quyết định thật nhanh cánh cửa nào ta sẽ đi tiếp, vì hậu quả của việc không quyết định (quyết định chậm) có thểsẽ là rất lớn</p></blockquote><h2 id="Chuong-9-Hieu-ung-cua-su-mong-doi">Chương 9: Hiệu ứng của sự mong đợi</h2><ul><li>Tại sao chúng ta lại cảm nhận theo những gì chúng ta cảm nhận. Khi chúng ta tin rằng một cái gì đó tốt thì nó sẽ tốt và khi chúng ta nghĩ nó tệ thì nó sẽ tệ.</li><li>Cùng một tình huống bóng trên vạch vôi. Nhưng luôn có 2 ý kiến trái chiều nhau giữa những cổ động viên 2 bênkhông bao giờ biết rằng trong loại bia mà họ uống có pha thêm giấm thơm.</li><li>Nếu được đọc bản miêu tả món ăn, thực khách sẽ rất thích thú món đó.</li><li>Những thứ làm nổi bật thương hiệu (ví dụ màu đỏ của coca…) tốt thường làm chúng ta thích những sản phẩm của họ hơn.</li><li>Nếu sản phẩm của bạn không có gì đặc biệt, hãy bán cái vỏ của nó.</li><li>Hành vi của chúng ta cũng có thể bị ảnh hưởng với các định kiến của chính mình, sự kích hoạt các định kiến phụ thuộc vào tình trạng tinh thần hiện tại và cách chúng ta nhìn nhận bản thân mình vàothời điểm đó. (Ví dụ: định kiến về người châu Á giỏi toán hơn =&gt; thì quốc tế sẽ tự tin hơn).</li><li>Việc nếm thử bia mà không biết gì về giấm thơm hoặc biết sau khi đã thử bia, sẽ giúp người thử cảm nhận được hương vị thật. Những người đó cũng thích nó hơn những người biết trước có giấm thơm trong bia(vì họ luôn muốn loại bia chuẩn, nhưng khi biết bia có giấm thơm họ nghĩ họ sẽ không thích)</li></ul><blockquote><p>Áp dụng khi tranh cãi: Quan điểm mỗi bên được trình bày mà không đưa ra quyết định cuối cùng là mình thuộc phe nào. Nó sẽ giúp nhận ra sự thật tốt hơn.</p></blockquote><h2 id="Chuong-10-Suc-manh-cua-gia-ca">Chương 10: Sức mạnh cùa giá cả.</h2><ul><li>Sự thật, giả dược hoạt động bằng sức mạnh của niềm tin, Chúng hiệu quả vì người ta tin tưởng chúng.</li><li>Sự quen thuộc chắc chắn tạo ra sự mong đợi</li><li>Những sản phẩm motivate (thuốc, thực phẩm chức năng, nước tăng lực…) có giá cao sẽ có tác dụng trấn an tốt hơn nếu nó có giá thấp.</li></ul><h2 id="Chuong-11-12-Tac-dong-cua-boi-canh-den-tinh-cach">Chương 11 + 12: Tác động của bối cảnh đến tính cách</h2><ul><li>Có hai kiểu không trung thực:<ul><li>Những kẻ trộm cắp, cướp bóc</li><li>Những người nghĩ mình là trung thực (Những người lấy những thứ nhỏ nhặt, khai tăng giá tiền của chiếc xe bị mất…)</li></ul></li><li>Khi có cơ hội, nhiều người “trung thực” sẽ gian lận. Nhưng họ sẽ không gian lận quá mức, và lạ thay, họ lại không nhìn thấy họ đang gian lận.</li><li>Gian lận sẽ dễ dàng hơn rất nhiều nếu nó không trực tiếp dính dáng đến tiền</li></ul><blockquote><p>Khi nghĩ về sự trung thực thì chúng ta sẽ ngừng hành vi gian lận ngay lập tức. Nên việc suy tưởng về một chuẩn mực dạo đức nào đó sẽ khuyến khích tính trung thực (10 điều răn của Chúa, lời tuyên thệ, đạo đức nghề nghiệp…)</p></blockquote><h2 id="Chuong-13-Bia-va-nhung-bua-an-mien-phi">Chương 13: Bia và những bữa ăn miễn phí</h2><ul><li>Khi gọi theo thứ tự (công khai) những người trong cùng một bàn sẽ gọi nhiều loại bia hơn - về bản chất là chọn sao cho phong phú. Có thể những loại đó họ không thực sự thích nhưng để thể hiệncá tính khác biệt của bản thân thì họ vẫn sẵn sàng.</li><li>Nên là người gọi đầu tiên, hoặc chọn anonymous…</li></ul><blockquote><p>Nếu tất cả chúng ta đều mắc lỗi có hệ thống trong các quyết định của mình thì tại sao không phát triển các chiến lược, công cụ và phương pháp giúp chúng ta đưa ra các quyết định sáng suốt hơn.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
            <tag> DanAriely </tag>
            
            <tag> PhiLyTri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memory Java</title>
      <link href="/Technology/Java/Scala/2020/12/12/java-memory-model/"/>
      <url>/Technology/Java/Scala/2020/12/12/java-memory-model/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java-Memory-model-co-nhung-gi">1. Java Memory model có những gì?</h2><p><img src="/images/java-memory/jvm-memory.png" alt="jvm-memory"></p><p>Java Memory model gồm 2 phần chính: các thread Stack và Heap.</p><ul><li>Mỗi thread chạy trong máy ảo JVM sẽ có 1 bộ nhớ thread Stack riêng và các thread khác nhau không thể truy cập giá trị thread stack của nhau.</li><li>Các thread stack này chứa thông tin về những method mà thread cần gọi và local variables của từng method đang thực thi. Mỗi thread stack sẽ có một bản clone local variables của method đó.</li><li>Bộ nhớ Heap thì chứa tất cả các Object được tạo trong chương trình. Mọi thread có thể dùng chung dữ liệu lưu trong Heap.</li><li>Sau khi các method kết thúc, các giá trị lưu trong thread stack sẽ được xóa, nhưng data trong Heap thì vẫn còn. Nó sẽ được GC dọn sau.</li><li>Nếu local variable là kiểu primitive =&gt; biến sẽ lưu trong thread stack.</li><li>Nếu trong Object có nhiều method và trong method có các biến local. thì các biến local đó cũng được lưu trong Thread stack.</li><li>Nếu local variable tham chiếu đến một Object =&gt; tham chiếu được lưu trong thread Stack, giá trị Object được lưu trong Heap</li><li>Các attributes của Object sẽ luôn luôn được lưu cùng Object đó trong Heap mà không cần quan tâm đến type of attribute.</li></ul><p><img src="/images/java-memory/jvm-memory-mapping.png" alt="jvm-memory-mapping"></p><p><strong>Giải thích diagram</strong></p><ul><li><code>local variable 1</code> ở cả 2 thread stack là biến primitive.</li><li><code>local variable 2</code> ở cả 2 thread stack đều tham chiếu đến <strong>Object 3</strong> được lưu trong Heap. <strong>Object 3</strong> lại có 2 biến local có giá trị là <strong>Object 2</strong> và <strong>Object 4</strong></li><li><code>local variable 1</code> ở methodTwo() trong 2 thread stack tham chiếu đến hai Object khác nhau lưu trong Heap là <strong>Object 1</strong> và <strong>Object 5</strong></li></ul><blockquote><pre><code>public class MyRunnable implements Runnable() &#123;  public void run() &#123;    methodOne();  &#125;  public void methodOne() &#123;    int localVariable1 = 45;    MySharedObject localVariable2 = MySharedObject.sharedInstance;    //... do more with local variables.    methodTwo();  &#125;  public void methodTwo() &#123;    //Mỗi thread sẽ tạo mới Object và lưu trong Heap.    Integer localVariable1 = new Integer(99);     //... do more with local variable.  &#125;&#125;public class MySharedObject &#123;  //Do được định nghĩa là static nên chỉ có duy nhất một instant được tạo ra và lưu trong Heap  public static final MySharedObject sharedInstance = new MySharedObject();  public Integer object2 = new Integer(22);  public Integer object4 = new Integer(44);  // Mặc dù member1 và member2 có kiểu là primitive nhưng vì nó là attribute của Object,  // nên nó vẫn được lưu vào trong Heap cùng với Object cha.  // chỉ có local variables như localVariable1 mới được lưu trong thread Stack.  public long member1 = 12345;  public long member2 = 67890;&#125;</code></pre></blockquote><h2 id="2-Cau-truc-bo-nho-phan-cung">2. Cấu trúc bộ nhớ phần cứng</h2><p><img src="/images/java-memory/hardware.png" alt="hardware"></p><ul><li>Một máy tính ngày nay thường có nhiều hơn 2 CPU. Mỗi CPU thường sẽ có 2 thread.</li><li>Mỗi CPU sẽ có một vài các thanh ghi để làm bộ nhớ trong của CPU. Tốc độ đọc ghi trên các thanh ghi này là cực kỳ nhanh. Nhanh hơn rất nhiều so với đọc trên RAM.</li><li>Mỗi CPU có thể sẽ có thêm 1 bộ nhớ cache, nhưng kích thước thường không được lớn lắm. Tốc độ đọc trên Cache cũng không nhanh bằng trên thanh ghi, nhưng vẫn là rất nhanh so với RAM.</li><li>Việc lưu trữ, trao đổi data sẽ được chuyển qua lại giữa các bộ nhớ CPU Registers, CPU Cache Memory, RAM. CPU sẽ load một phần data trong RAM vào Cache. và cũng có thể sẽ load một phầndata từ Cache vào CPU Registers để thực hiện các tính toán.</li><li>Khi cần lưu data lại vào RAM thì CPU sẽ truyền data từ CPU Registers ngược lại cho Cache. Nhưng Cache sẽ không truyền ngay data về RAM,mà sẽ chờ đến khi CPU cần phải lưu những thứ khác trong Cache thì khi đó nó sẽ gửi data xuống RAM.</li></ul><h2 id="3-Bo-nho-phan-cung-tuong-tac-voi-JVM-memory">3. Bộ nhớ phần cứng tương tác với JVM memory</h2><p><img src="/images/java-memory/hardware-mapping-jvm.png" alt="hardware-mapping-jvm"></p><p>Cấu trúc bộ nhớ của JVM và máy tính là khác nhau. Các data của Thread stack, Heap đều có thể được lưu một phần trong CPU Registers, CPU Cache Memory, RAM. Vì thế có 2 vấn đề thường gặp:</p><ul><li>Visibility of thread updates (writes) to shared variables.</li><li>Race conditions</li></ul><p>Xét ví dụ sau đây để làm rõ</p><p><img src="/images/java-memory/visibility-shared-object.png" alt="visibility-shared-object"></p><ul><li>Biến <strong>count</strong> trong RAM có giá trị là 1.</li><li>CPU A và CPU B load <strong>count</strong> lên Cache của chúng.</li><li>CPU A tăng giá trị count của thêm 1 để count trong Cache của CPU A là 2. nhưng vì Cache chưa gửi về RAM nên count trong RAM vẫn là 1.</li></ul><blockquote><p>Chú ý: Nếu muốn CPU A update lại <strong>count</strong> vào RAM ngay sau khi thay đổi <strong>count</strong> và các thread khác luôn luôn đọc biến <strong>count</strong> trực tiếp từ RAM thìchúng ta có thể khai báo biến với từ khóa <code>volatile</code>. Ví dụ:</p><pre><code>public volatile int count = 1;</code></pre><p>Tuy nhiên dùng <strong>volatile</strong> cũng chưa đủ an toàn. Vì khi CPU A đang tính toán và chuẩn bị update <strong>count</strong> = 2 về RAM thì CPU B đã load giá trị của <strong>count</strong> = 1 nên Cache. Khi đó vẫn làm sai lệchdữ liệu.</p></blockquote><ul><li>Lúc này Cache của CPU B count vẫn có giá trị là 1 vì thread của CPU B không thể truy cập được Cache của CPU A</li><li>CPU B tăng giá trị count của thêm 1 để count trong Cache của CPU A là 2. nhưng vì Cache chưa gửi về RAM nên count trong RAM vẫn là 1.</li></ul><blockquote><p>Chú ý:Khi có <strong>ÍT NHẤT 2 THREAD</strong> (thread trên CPU A và CPU B) muốn thay đổi giá trị của shared object (<strong>count</strong>) thì có thể sẽ xảy ra <strong>race conditon</strong>.<strong>Thread safe</strong> là không có <strong>race condition</strong></p></blockquote><p><img src="/images/java-memory/race-condition.png" alt="race-condition"></p><p>Để giải quyết tất cả vấn đề trên có thể dùng <code>block synchronized</code>. Block synchronized đảm bảo việc tất cả các biến được truy cập trong block này sẽ được đọc từ RAM,và khi thread rời khỏi block thì mọi thay đổi tới các biến sẽ được ghi vào RAM ngay lập tức. Sau đó những thread khác mới bắt đầu load data và tính toán</p><h2 id="4-Refer">4. Refer</h2><ul><li><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Scala </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Implicit in Scala</title>
      <link href="/Technology/scala/2020/11/02/implicit-scala/"/>
      <url>/Technology/scala/2020/11/02/implicit-scala/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/implicit-in-scala.png" alt="implicit-in-scala"></p><h2 id="1-Implicit-conversion">1. Implicit conversion</h2><p>Cách thức hoạt động:</p><ul><li>Đầu tiên compiler sẽ compile code, nhưng sẽ gặp lỗi type errors.</li><li>Trước khi kết thúc việc compile, compiler sẽ tìm các implicit conversion phù hợp đểrepair lỗi đó.</li><li>Nếu fix được thì nó sẽ tiếp tục việc compile còn không sẽ throw error.</li></ul><h2 id="2-Cac-Rule">2. Các Rule</h2><h3 id="a-Making-rule">a. Making rule</h3><p>Các variable, function, object phải được khai báo với từ khóa <code>implicit</code> thì compiler mới có thể sử dụng được.</p><blockquote><pre><code>   implicit def intToString(x: Int) = x.toString</code></pre></blockquote><h3 id="b-Scope-rule">b. Scope rule</h3><p>Một implicit conversion được sử dụng phải trong scope và nó phải là implicit duy nhất, hoặc được liên kết với source or target type của conversion.</p><p>Muốn sử dụng implicit có 2 cách:</p><blockquote><p>Import implicit mà bạn muốn dùng.</p><pre><code>import Preamble._</code></pre><p>Viết các implicit trong companion Object. vì các companion sẽ liên kết với các class, case class của nó nên compiler sẽ tự động sử dụng chúng khi cần.</p><pre><code>object Dollar &#123;    implicit def dollarToEuro(x: Dollar): Euro = ...&#125; class Dollar &#123; ... &#125;</code></pre></blockquote><h3 id="c-One-at-a-time-rule">c. One at a time rule</h3><p>Trong một thời điểm chỉ có một implicit được áp dụng. Compiler sẽ không bao giờ áp dụng thêm những implicit conversion khác khi đã có một implicit được sử dụng. Vì khi đó sẽ làm tăngcompile time khi gặp code lỗi. Đồng thời nó cũng có thể dẫn đến việc hiểu nhầm giữa code của developer với cái mà compiler tạo ra.</p><blockquote><pre><code>convert1(convert2(x)) + y // sẽ không bao giờ có trường hợp này</code></pre></blockquote><h3 id="d-Explicits-first-rule">d. Explicits first rule</h3><p>Bất cứ khi code đang hoạt động tốt, implicit sẽ không bao giờ được sử dụng. (Nó chỉ được sử dụng khi compiler phát hiện lỗi).</p><h2 id="3-Khi-nao-implicit-se-duoc-ap-dung">3. Khi nào implicit sẽ được áp dụng</h2><p>Có 3 cách mà implicit được sử dụng:</p><ul><li>Conversions to an expected type</li><li>Conversions of the receiver of a selection</li><li>Implicit parameters</li></ul><h3 id="a-Conversions-to-an-expected-type">a. Conversions to an expected type</h3><blockquote><p>Bất cứ khi nào compiler thấy một kiểu X nhưng lại cần một kiểu Y. Nó sẽ tìm một implicit method chuyển X sang Y.</p></blockquote><p>Lấy ví dụ để dễ hiểu:</p><blockquote><p>Nếu một số Double cần chuyển đổi thành số Int. Compiler sẽ tìm những implicit trong scope có thể chuyển Double thành Int để apply để tránh khỏi lỗi.</p><pre><code>  val age: Int  =  26.5 // got error</code></pre><p>Solution:</p><pre><code>  implicit def doubleToInt(x: Double): Int = x.toInt  val age: Int  =  26.5 // age = 26</code></pre></blockquote><p>Với ví dụ trên việc implicit conversion từ Double sang Int sẽ gây rất khó hiểu (Vì các số bị làm tròn). Nhưng nếu implicit conversion từ Int sang Double thì sẽ hợp lý hơn rất nhiều. Vì thế khi dùng implicit thìnên chuyển đổi từ một kiểu nhỏ sang một kiểu lớn hơn, bao quát hơn, tránh làm ngược lại.</p><p>Đoạn code trên nên được sửa lại thành:</p><blockquote><pre><code>  implicit def int2double(x: Int): Double = x.toDouble // chuyển từ Int sang Double thì các giá trị sẽ luôn đúng</code></pre></blockquote><h3 id="b-Conversions-of-the-receiver-of-a-selection">b. Conversions of the receiver of a selection</h3><p>Khi một <code>object</code> gọi một method mà nó không có, thì compiler sẽ chuyển đổi <code>object</code> đó thành <code>object</code> khác mà chứa method được gọi.</p><p>Nó được sử dụng chính trong 2 trường hợp:</p><ul><li>Tương tác với những types mới (Interoperating with new types). Dễ hiểu thì là: Khi viết <code>obj.doIt</code> mà <code>obj</code> lại không hề có <code>doIt</code>.Lúc này compiler sẽ tìm kiếm các implicit conversion có thể biến đổi từ <code>obj</code> sang 1 kiểu nào đó mà có chứa <code>doIt</code>.</li></ul><blockquote><pre><code>  class Rational(n: Int, d: Int) &#123;      def + (that: Rational): Rational = ...      def + (that: Int): Rational = ...  &#125;  val oneHalf = new Rational(1, 2)</code></pre><p>Khi viết như sau thì hoàn toàn hợp lệ:</p><pre><code>  oneHalf + 1 // res = 3/2</code></pre><p>Nhưng nếu viết như sau sẽ throw Exception:</p><pre><code>  1 + oneHalf // Exception</code></pre><p>Do <code>1</code> không có method <code>+</code> nào nhận giá trị có kiểu <code>Rational</code> làm parameter cả. Để giải quyết vấn đề này có thể viết thêm như sau:</p><pre><code>  implicit def intToRational(x: Int) = new Rational(x, 1)</code></pre></blockquote><ul><li>Mô phỏng systax mới (Simulating new syntax).</li></ul><blockquote><p>Bạn có thể quen thuộc khi khai báo Map như sau:</p><pre><code>  Map(1 -&gt; &quot;one&quot;, 2 -&gt; &quot;two&quot;, 3 -&gt; &quot;three&quot;)</code></pre><p>Ta có thể thấy <code>1</code> là số Int thì tại sao lại có method <code>-&gt;</code>. Vì muốn tạo ra systax mới (method <code>-&gt;</code>) cho một kiểu bất kỳ thì library đã tạo ra một <code>implicit def -&gt;</code> để convert các type sang <code>ArrowAssoc</code>Lúc này compiler sẽ apply <code>implicit def -&gt;</code> vào trong số <code>1</code>.</p><pre><code>  package scala  object Predef &#123;      class ArrowAssoc[A](x: A) &#123;      def -&gt; [B](y: B): Tuple2[A, B] = Tuple2(x, y)      &#125;      implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =      new ArrowAssoc(x)      ...  &#125;</code></pre><p>Trong Scala cũng sử dụng rất nhiều các class có tên kiểu <code>RichSomething</code> ví dụ như RichInt, RichBoolean… Thì khả năng nó sẽ thêm các systax mới để phục vụ cho kiểu <code>Something</code></p></blockquote><h3 id="c-Implicit-parameters">c. Implicit parameters</h3><p>Được áp dụng cho các parameters được parse vào method mà được khai báo là implicitNó được dùng chủ yếu để cung cấp thêm thông tin về type của một parameter được thêm vào trước đó trong method.</p><p>Chú ý: Chúng ta nên tạo ra các type mới cho các implicit parameter để có thể giúp người đọc hiểu hơn về giá trị implicit truyền vào có ý nghĩa gì. Như ví dụ bên dưới, thay vì để <code>promt</code> <code>hoặc</code> <code>drink</code>có type là String thì ta nên để type của chúng <code>PreferredPrompt</code> và <code>PreferredDrink</code>.</p><blockquote><pre><code>class PreferredPrompt(val preference: String)class PreferredDrink(val preference: String)object Greeter &#123;  implicit val prompt = new PreferredPrompt(&quot;Yes, master&gt; &quot;)  implicit val drink = new PreferredDrink(&quot;tea&quot;)  def greet(name: String)(implicit prompt: PreferredPrompt, drink: PreferredDrink) &#123;     println(&quot;Welcome, &quot;+ name +&quot;. The system is ready.&quot;)     print(&quot;But while you work, &quot;)     println(&quot;why not enjoy a cup of &quot;+ drink.preference +&quot;?&quot;)     println(prompt.preference)  &#125;&#125;Greeter.greet(&quot;Joe&quot;)// Welcome, Joe. The system is ready.// But while you work, why not enjoy a cup of tea?// Yes, master&gt;</code></pre></blockquote><h2 id="4-Trong-mot-scope-nhung-co-nhieu-conversion-co-the-ap-dung">4. Trong một scope nhưng có nhiều conversion có thể áp dụng</h2><ul><li><p>Với scala 2.7 trở về trước, khi gặp trường hợp này compiler sẽ throw ra lỗi <code>ambiguous</code>. Vì nó không biết chọn cái nào để aply. (Nó cũng tương tự overloading. khi có 2 method giống hệt nhau thì compiler sẽ báo lỗi.)</p></li><li><p>Với scala 2.8 trở đi thì compiler sẽ chọn ra một implicit mà nó rõ ràng hơn để sử dụng</p></li></ul><blockquote><p>Tuy nhiên dù thế nào đi nữa, chúng ta nên chỉ định rõ ràng implicit nào được sử dụng để tránh confuse.</p></blockquote><h2 id="5-Tong-ket">5. Tổng kết.</h2><p>Implicit rất mạnh mẽ và được sử dụng rất rộng rãi. Gần như trong tất cả libraries, 3rd đều sử dụng nó. Nó có các lợi ích sau:</p><ul><li>Có thể giúp bạn thêm các fields, method cho các class mà bạn muốn.</li><li>Giúp code ngắn gọn hơn</li><li>Reuse code tốt hơn.</li></ul><p>Bên cạnh nó nếu lạm dụng thì code sẽ trở lên khó hiểu, và khó debug. Vì thế <code>NẾU KHÔNG CÒN LỰA CHỌN NÀO KHÁC THÌ HÃY SỬ DỤNG IMPLICIT</code></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Encoding</title>
      <link href="/Technology/common/2019/07/14/encoding/"/>
      <url>/Technology/common/2019/07/14/encoding/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/unicode.png" alt="Unicode"></p><h2 id="1-Thuat-ngu">1. Thuật ngữ</h2><ul><li><p>encode: dùng 1 thứ gì đó để để thể hiện cho 1 thứ khác. VD: 01100010 là b</p></li><li><p>Encoding: là tập hợp các quy tắc để thực hiện việc chuyển đổi đó. VD: mã hóa ký tự sang bit</p></li><li><p>decode: từ bit giải mã sang ký tự</p></li><li><p>character set, charset: tập hợp các ký tự có thể được encode</p></li><li><p>code page: là bảng mapping bit với ký tự</p></li></ul><h2 id="2-Overview">2. Overview</h2><p>Máy tính chỉ có thể làm việc và hiểu được với bit.</p><p>Để biểu diễn bất cứ thứ gì thì ta cần phải có quy tắc để chuyển đổi chúng thành bit và ngược lại. Quy tắc đó chính là encoding scheme (lược đồ mã hóa) gọi tắt là encoding.</p><blockquote><p>VD: trong encoding ASCII thì:</p><pre><code>   1100010 là b   01101001 là i   01110100 là t</code></pre></blockquote><p>1 byte có 8 bits chứ không phải 7 hay 9 bits vì tổ hợp của 8 bits là 256 trường hợp khác nhau. Nó vừa đủ để để biểu diễn tất cả các ký tự trong tiếng Anh mà không thừa, không thiếu. Nhưng nó lạikhông đủ để mapping cho tất cả các ngôn ngữ trên thế giới (tiếng Trung, Nhật, Ấn Độ, Pháp…) nên người tađã tạo rất nhiều loại encoding phù hợp với ngôn ngữ của họ. Và họ đã nghĩ tới việc tăng 1 ký tự tương ứng với 2 bytes (16 bits) VD: BIG-5, GB18030</p><p>Con người có thể dùng hệ bát phân, thập phân và thập lục phân để viết cho gọn. Còn máy tính luôn luôn sử dụng hệ nhị phân. Quá trình đóng gói và truyền qua internet cũng là tổ hợp các gói tin và gửi đi.</p><h2 id="3-Unicode">3. Unicode</h2><p>Unicode ra đời để hợp nhất tất cả các chuẩn mã. Unicode là 1 encode schema nhưng không phải là 1 loại encoding. Nó tạo ra 1 code page chứa đến 1,114,112 ký tự. Nó có thể biểu diễn cho tất cả các ngôn ngữ, ký tự trên thế giới.</p><p>Bài toán đặt ra: để biểu diễn hết tất cả các ký tự trong unicode, nếu encoding dùng 2 bytes (2^16 ký tự) thì không đủ. còn 3 bytes (2^24) thì đủ nhưng ngta không dùng 3 bytes. nên 4 bytes đã được chọn.</p><p>Với encoding UTF-32 sẽ mã hóa mọi ký tự bằng 4 bytes. Nhưng như thế nó quá tốn kém trong việc lưu trữ (có thể file size lớn lên 4 lần).</p><p>UTF-16 và UTF-8 là 2 loại encoding đa chiều dài nên sẽ tối ưu hơn.</p><ul><li>Với UTF- 8: Nếu ký tự chỉ cần 1 byte thì nó sẽ mã hóa bằng 1 byte…Nếu cần 4 bytes nó sẽ mã hóa bằng 4 bytes. Khi giải mã thì byte đầu tiên trong chuỗi (bit có trọng số cao nhất – MSB) sẽ dùng để xác định số byte cấu thành ký tự.</li><li>UTF-16: Cũng tương tự như UTF-8 nhưng nó sẽ dùng ít nhất 2 bytes, và có thể tăng lên 4 bytes.</li></ul><h2 id="4-Chon-sai-encoding-khi-mo-1-van-ban">4. Chọn sai encoding khi mở 1 văn bản</h2><p>Việc biết 1 văn bản được encoding bằng encoding nào rất là khó. chỉ có thể dựa vào suy đoán.</p><p>Khi mở văn bản sai encoding có thể sẽ ảnh hưởng đến nội dung của văn bản. Vì khi mở văn bản. Có thể các editor có thể âm thầm thay thế những bytes mà nó không nhận diện ra được bằng ký tự ? hoặc � (thậm chí là loại bỏ bytes đó đi). Từ đó không thể khôi phục lại được dữ liệu ban đầu.</p><p>Nếu muốn convert từ encoding này sang encoding khác thì cần dùng các phần mềm chuyên dụng để mapping lại cái giá trị tương ứng trong code page của từng loại.</p><h2 id="5-UTF-8-va-ASCII">5. UTF-8 và ASCII</h2><p>UTF-8 tương thích hoàn toàn với ASCII.</p><p>Mọi ký tự trong ASCII đều tương đương với giá trị trong UTF-8. Những ký tự không có trong ASCII sẽ có từ 2 bytes trở lên.</p><p>Mọi String trong Javascript đều được encoding chỉ bởi UTF-16</p><p>Ngày nay, UTF-8 được coi là tiêu chuẩn. Vì nó mã hoá gần như mọi ký tự bạn cần, tương thích ngược với và khá hiệu quả về mặt bộ nhớ đối với hầu hết các trường hợp.</p><h2 id="6-Tong-ket">6. Tổng kết</h2><ul><li>Khi làm việc với CSV cũ thì nên mở với UTF16 LE để tránh lỗi encoding</li></ul><h2 id="7-Refer">7.Refer</h2><ul><li><a href="https://kunststube.net/encoding/">https://kunststube.net/encoding/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> common </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> JS </tag>
            
            <tag> Scala </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Index trong MySQL</title>
      <link href="/Technology/MySQL/2019/03/27/index-in-mysql/"/>
      <url>/Technology/MySQL/2019/03/27/index-in-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Index-la-gi">1. Index là gì?</h2><blockquote><p>“Indexes are special lookup tables that the database search engine can use to speed up data retrieval. Simply put, an index is a pointer to data in a table. An index in a database is very similar to an index in the back of a book”</p></blockquote><p>Hay hiểu đơn giản là dùng với mục đích là tăng tốc độ tìm kiếm</p><h2 id="2-Khi-nao-nen-su-dung-index">2. Khi nào nên sử dụng index?</h2><ul><li>Table có nhiều dữ liệu</li><li>Lấy dữ liệu &lt; 5% tổng data</li><li>Bảng ít update, delete, insert data</li><li>Column ít giá trị null</li><li>Column thường được sử dụng làm điều kiện khi truy vấn</li><li>Nên đánh index trên khóa ngoại</li><li>Selectivity cao (= cardinality/(number of records) * 100% )=&gt; Những column Unique, Sorted</li></ul><blockquote><p>cardinality: là số lượng bản ghi duy nhất xuất hiện trong table cho column đó.Ví dụ: table Employee với column sex, cột này chỉ có thể có 2 giá trị là Male và Female, như vậy cardinality cho column sex sẽ là 2, vì ta chỉ có 2 giá trị duy nhất xuất hiện ở cột column</p></blockquote><h2 id="3-Cac-loai-index-thuong-dung">3. Các loại index thường dùng</h2><ul><li>Btree Index (default và phổ biến nhất)</li><li>Bitmap Index</li><li>Index-organized table</li><li>Hash clusters</li><li>Index clusters</li><li>Nested table</li><li>Reverse Key Index</li></ul><h2 id="4-B-Tree-index">4. B-Tree index</h2><p><img src="/images/b-tree-index.png" alt="B-tree-index"></p><ul><li>Là index mặc định trong Database</li><li>Index sẽ bị xóa khi table bị xóa</li><li>Gồm 3 phần: Root, Branch, Leaf</li></ul><blockquote><p>Leaf gồm:</p><ul><li>Index entry header: thông tin lưu trữ số column và thông tin khoá của các hàng trong bảng.</li><li>Key column length_value pair: chứa thông tin về kích thước column tham gia vào khoá và tiếp theo là kích thước của đó.</li><li>ROWID: là giá trị của ROWID chứa giá trị khoá của index</li></ul></blockquote><blockquote><p>Các lệnh DML(Data manipulation Language)</p><ul><li>Insert: Thêm index entry</li><li>Delete: Disable index entry</li><li>Update: Disable =&gt; insert new index entry</li></ul></blockquote><h3 id="a-Dac-diem">a. Đặc điểm</h3><ul><li>Giá trị khóa sẽ lặp đi lặp lại nếu có nhiều giá trị trùng nhau</li><li>Với composite index trên nhiều column, khi tìm kiếm nó sử dụng 2 column đầu tiên để tìm kiếm, tìm kiếm theo thứ tự đánh index=&gt; column unique, nhiều data thì nên đánh trước</li><li>Không lưu dữ liệu có giá trị null</li></ul><h3 id="b-Index-khong-duoc-ap-dung-khi">b. Index không được áp dụng khi</h3><ul><li>Dùng cho các toán tử &lt;&gt;, != và NOT IN, NOT LIKE</li><li>Kết hợp toán tử Like có ‘%’ ở đầu.</li><li>Kết hợp các thành phần khác (giá trị, biểu thức…)=&gt; function-base Index. VD: CREATE INDEX idx ON emp (UPPER(emp_name));</li><li>So sánh với giá trị khác kiểu</li></ul><h3 id="c-Rebuild">c. Rebuild</h3><p>Tại sao cần rebuild:</p><blockquote><ul><li>Height index càng nhỏ thì tìm càng nhanh. Nếu Height = 3 thì khi hoạt động index cần phải đọc ít nhất 3 block là root block, branch block và leaf block</li><li>Việc delete, update dữ liệu nhiều =&gt; deleted leaf nhiều =&gt; tree mất cân bằng</li></ul></blockquote><p>Khi nào nên rebuild</p><blockquote><ul><li>Height &gt; 4, deleted leaf &gt; 20%</li></ul></blockquote><p>Chú ý:</p><blockquote><ul><li>Nên run lại câu lệnh statistic để cập nhật lại thông tin statistic và EP sauANALYZE TABLE &lt;TBL_NAME&gt; COMPUTE STATISTICS</li></ul></blockquote><h3 id="d-Cac-cau-lenh-hay-dung">d. Các câu lệnh hay dùng</h3><blockquote><ul><li>Create Index: CREATE INDEX index_name ON table (column1, column2…) [ONLINE];</li><li>Rename: ALTER INDEX index RENAME TO &lt;new_index_name&gt;;</li><li>Drop Index: DROP INDEX index_name;</li><li>Rebuild Index: ALTER INDEX DEPT_LOCATION_IX REBUILD [ONLINE];</li></ul></blockquote><p>Note:</p><ul><li>Thông thường trong khi tạo index, các câu lệnh DML tác động lên cột dữ liệu có liên quan đều tạm thời không thực hiện được cho đến khi hoàn tất việc tạo index.</li><li>Để có thể cho phép thực hiện câu lệnh DML tác động lên các cột dữ liệu được index, Oracle có hỗ trợ Index online (Index trực tuyến) khi này, ta cần bổ sung thêm mệnh đề ONLINE vào trong câu lệnh.</li></ul><h2 id="5-Refer">5. Refer</h2><ul><li><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL statement processing</title>
      <link href="/Technology/Oracle/MySQL/2019/02/14/sql-statement-processing/"/>
      <url>/Technology/Oracle/MySQL/2019/02/14/sql-statement-processing/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Trinh-tu-xu-ly-cau-lenh-SQL">1. Trình tự xử lý câu lệnh SQL</h2><p><img src="/images/sql-state-process-phase.png" alt="sql-state-process-phase"></p><p>Parse Phase</p><ul><li>Check <code>Execute Plan(EP)</code> đã tồn tại trên <code>Shared Pool</code> chưa? Nếu có rồi thì sang bước <code>Bind</code></li><li>Phân tích, kiểm tra cú pháp, quyền truy cập</li><li>Tạo EPExecute Plan: Oracle Server sẽ lên kế hoạch để thực thi câu lệnh sao cho chi phí bỏ ra là thấp nhất thông qua Trình tối ưu câu lệnh (Optimizer)</li></ul><h2 id="2-Trinh-toi-uu-cau-lenh-Optimizer">2. Trình tối ưu câu lệnh(Optimizer)</h2><ul><li>Giúp tạo ra EP tốt nhất cho câu lệnh</li><li>Có 2 phương pháp:<ul><li>Rule Based Optimizer (RBO): Dùng lược đồ phân rank các phương thức truy cập. Rank càng thấp thì càng được ưu tiên.VD: single row by rowId có rank = 1; Full table scan có rank = 15</li><li>Cost Based Optimizer (CBO): Dựa vào các thông tin: CPU, IO… để tính Cost. sẽ chọn EP có Cost nhỏ nhất.</li></ul></li></ul><h2 id="3-Cac-cach-truy-cap-du-lieu">3. Các cách truy cập dữ liệu</h2><ul><li>Physical:</li></ul><blockquote><p>Truy cập DB theo DB_Block (disk read). Tốn nhiều thời gian và resources vì cần IO disk</p></blockquote><ul><li>Logical: Đọc block data từ Buffer Cache</li></ul><blockquote><ul><li>Table Access Full: duyệt tuần tự từng bản ghi. Dùng khi:<ul><li>Không có Index hoặc Index không dùng được</li><li>Dù có Index, nhưng tập data trả về lớn</li><li>Số lượng bản ghi ít</li></ul></li><li>Index scan: Chỉ đọc trên Index</li><li>Table Access by Index RowId: Duyệt Index =&gt; duyệt rowId</li></ul></blockquote><h2 id="4-Co-che-thuc-thi-lenh-Join">4. Cơ chế thực thi lệnh Join</h2><ul><li>Optimizer sẽ tự chọn các thuật toán để JOIN table sao cho chi phí là thấp nhất</li><li>Các loại:</li></ul><blockquote><ul><li>Nested Loop Join</li><li>Sort Merge Join</li><li>Hash Join</li></ul></blockquote><h4 id="a-Nested-Loop-Join">a. Nested Loop Join</h4><ul><li>Implement: Khi Join T1 - inner table với T2 - outer table. Từng row trong T1 sẽ so sánh với tất cả rows trên T2</li><li>Dùng khi: T1 nhỏ, và T2 được sort theo trường được Join</li><li>Thể hiện: Câu lệnh hiệu quả, chi phí thấp</li></ul><h4 id="b-Merge-Join">b. Merge Join</h4><ul><li>Implement: Cả 2 table T1 vs T2 phải sort theo trường được Join. Sau đó cả 2 bảng sẽ đọc từ đầu và cùng tiến lên song song. Có thể sẽ kết thúc nếu quét hết data của table nhỏ.</li><li>Trong trường hợp 1 trong 2 table không được sắp xếp thì Optimizer sẽ sort table còn lại và dùng Merge Join hoặc có thể dùng Hash Join</li><li>Hiệu quả: Tập dữ liệu trả về lớn</li></ul><h4 id="c-Hash-Join">c. Hash Join</h4><p><img src="/images/hash-join-implement.png" alt="hash-join-implement"></p><ul><li>Hiệu quả: Tập dữ liệu trả về lớn và field Join không được sắp xếp</li><li>So với Merge Join:<ul><li>Hash Join sẽ nhanh hơn so với việc phải sắp xếp lại table.</li><li>Tốn CPU, Memory hơn do phải tạo bảng + hash</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Oracle </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Mysql </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>This in Javascript</title>
      <link href="/Technology/JS/2019/01/16/this-in-javascript/"/>
      <url>/Technology/JS/2019/01/16/this-in-javascript/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/this-in-js.png" alt="this-in-js"></p><h2 id="1-Call-site">1. Call-site</h2><ul><li><p><strong>call-site</strong> là vị trí đoạn code nơi mà function được gọi (không phải nơi được khai báo). Đây là thứ duy nhất mà <code>this</code> phụ thuộc vào.</p></li><li><p><strong>call-stack</strong>: là một stack chứa các functions được thực thi.</p></li></ul><blockquote><pre><code>  function baz() &#123;      // call-stack là: `baz`      // call-site sẽ là global scope      console.log( &quot;baz&quot; );      bar(); // call-site cho `bar`  &#125;  baz(); // call-site cho `baz`  function bar() &#123;      // call-stack lúc này là: `baz` -&gt; `bar`.      // Do `baz` được gọi trước và call đến `bar` trong nó      // call-site là trong `baz`      console.log( &quot;bar&quot; );      foo(); // call-site cho `foo`  &#125;  function foo() &#123;      // call-stack là: `baz` -&gt; `bar` -&gt; `foo`      // call-site là trong `bar`      console.log( &quot;foo&quot; );  &#125;</code></pre></blockquote><p>Để dễ dàng xác định call-stack, có thể sử dụng <code>debugger</code> hoặc <code>breakpoint</code> để xem call-stack. Dựa vào call-stack ta dễ dàng xác định được call-site</p><h2 id="2-Rules">2. Rules</h2><h3 id="a-Default-Binding">a. Default Binding</h3><p>Khi function được gọi một cách độc lập <strong>default binding</strong> sẽ được áp dụng.</p><p>Xét ví dụ:</p><blockquote><pre><code>  function foo() &#123;      // call-site sẽ là global scope      // call-stack là: `foo`      let a = 1;      console.log( this.a ); //this chính là global object  &#125;  var a = 2; // a là một property của global object  // call-site cho foo  foo(); // 2 </code></pre></blockquote><p>Do <code>foo()</code> có call-site là trong global scope. Và default binding được áp dụng nên <code>this.a</code> sẽ trỏ đến biến <code>a</code> của global object.</p><p>Chú ý: Nếu sử dụng <code>strict mode</code> ở trong <code>foo()</code> (còn các nơi khác thì không liên quan) thì <code>this</code> sẽ là <code>undefined</code></p><blockquote><pre><code>  function foo() &#123;     &quot;use strict&quot;;      console.log( this.a );  &#125;  var a = 2;  function bar() &#123;      console.log( this.a );  &#125;    (function()&#123;      &quot;use strict&quot;; // strict mode không ảnh hưởng đến `this` trong `bar`      bar(); // 2  &#125;)();    foo(); // TypeError: `this` is `undefined`</code></pre></blockquote><h3 id="b-Implicit-Binding">b. Implicit Binding</h3><p><strong>call-site</strong> có context là object. Hay nói cách khác, functions được tạo hoặc chứa trong object thì <strong>implicit binding</strong> sẽ được áp dụng</p><p>Xét ví dụ:</p><blockquote><pre><code>  function foo() &#123;      console.log( this.a ); // this.a chính là obj2.a  &#125;  var obj2 = &#123;      a: 42,      foo: foo  &#125;;  var obj1 = &#123;      a: 2,      obj2: obj2  &#125;;  obj1.obj2.foo(); // 42</code></pre></blockquote><p>Ta thấy <code>foo()</code> được chứa trong object <code>obj2</code>, nên <strong>implicit binding</strong> sẽ được áp dụng. Vì thế <code>this.a</code> cũng chính là <code>obj2.a</code>.</p><p>Chú ý là chỉ có object cuối cùng trong call-stack mới ảnh hưởng đến call-site nên <code>obj1.a</code> sẽ không được tham chiếu trong trường hợp trên.</p><h4 id="Implicit-Lost">Implicit Lost</h4><p>Cũng có trường hợp <strong>Implicit binding</strong> không được áp dụng mặc dù functions được tạo hoặc chứa trong object. Khi này <strong>Default Binding</strong> sẽ được áp dụng</p><p>Như ví dụ bên dưới, mặc dù<code>foo()</code> được chứa trong <code>obj</code> nhưng function <code>obj.foo</code> được gán bằng biến <code>bar</code> . Nên khi gọi <code>bar()</code> thì call-site của <code>foo()</code> lúc này sẽ là global</p><blockquote><pre><code>  function foo() &#123;      console.log( this.a );  &#125;  var obj = &#123;      a: 2,      foo: foo  &#125;;  var bar = obj.foo; // gán function vào variable  var a = &quot;oops, global&quot;; // `a` also property on global object  bar(); // &quot;oops, global&quot;</code></pre></blockquote><p>Khi được sử dụng trong call back function thì <strong>implicit binding</strong> cũng không được áp dụng.</p><blockquote><pre><code>  function foo() &#123;      console.log( this.a );  &#125;  var obj = &#123;      a: 2,      foo: foo  &#125;;  var a = &quot;oops, global&quot;; // `a` also property on global object  setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</code></pre></blockquote><h3 id="c-Explicit-Binding">c. Explicit Binding</h3><p><strong>explicit binding</strong> giúp chúng ta ép <code>this</code> có call-site của object cụ thể theo ý mình thông qua 3 methods:<a href="/Technology/JS/2019/01/03/call-bind-apply-in-js/" title="compare call, apply, bind">call(), apply() và bind().</a></p><p>** explicit binding** sẽ có độ ưu tiên cao hơn <strong>Implicit binding</strong>, và dĩ nhiên là cả <strong>default binding</strong></p><h3 id="d-New-Binding">d. New Binding</h3><p>Khi call một function với <code>new</code> operator thì JS sẽ tự động thực hiện:</p><ul><li>Tạo mới một object mới từ function được gọi.</li><li>Object mới này sẽ được binding <code>this</code> cho function đó</li><li>Trừ khi function đó return về một function thay thế nếu không sẽ luôn tự động trả về object mới.</li></ul><p>Ví dụ:</p><blockquote><pre><code>  function foo(a) &#123;      this.a = a;  &#125;  // một function object mới được tạo ra và gán vào `bar`  var bar = new foo( 2 );   console.log( bar.a ); // 2</code></pre></blockquote><p><strong>New binding</strong> có khả năng override <code>bind()</code> trong explicit (call() và apply() sẽ gọi function ngay lập tức nên không được xét).</p><h2 id="3-Note">3. Note</h2><ul><li><p>Để xác định được <code>this</code> là gì, ta cần phải xác định được chính xác call-site của function đó. Thứ tự ưu tiên của các rules để xác định call-site lần lượt là:</p><ul><li>Function được gọi với từ khóa <code>new</code>.</li><li>Function được gọi với <code>call</code>, <code>apply</code> hoặc là <code>bind</code> function.</li><li>Function được gọi với một context của object chứa nó</li><li>Default binding. Với <strong>strict mode</strong> <code>this</code> là <code>undefined</code>, còn lại sẽ là global object.</li></ul></li><li><p>Các functions bình thường sẽ tuân theo 4 rules kể trên. Nhưng trong ES6 có một function đặc biệt là <strong>arrow-fucntion</strong>.<strong>Arrow function</strong> sẽ có call-site của nơi bên ngoài gần nó nhất (function hoặc global).</p></li></ul><blockquote><pre><code>  function foo() &#123;      // return an arrow function      return (a) =&gt; &#123;          // `this` ở đây sẽ được binding với `this` của `foo()`          console.log( this.a );      &#125;;  &#125;  var obj1 = &#123; a: 2 &#125;;  var obj2 = &#123; a: 3 &#125;;  // `this` của foo() được `binding` với `obj1`.  // nên arrow function cũng sẽ có this binding là `obj1`  // mặc dù đã binding lại `bar` với `obj2` nhưng cũng sẽ không có tác dụng.  // vì bar là một arrow-function  var bar = foo.call( obj1 );  bar.call( obj2 ); // 2, not 3!</code></pre></blockquote><h2 id="4-Refer">4. Refer</h2><p><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch2.md">https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this %26 object prototypes/ch2.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> JS </tag>
            
            <tag> This </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Call, Apply, Bind trong JS</title>
      <link href="/Technology/JS/2019/01/03/call-bind-apply-in-js/"/>
      <url>/Technology/JS/2019/01/03/call-bind-apply-in-js/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/call-apply-bind-in-js.png" alt="call-apply-bind-in-js"></p><p>Mọi functions trong JS đều là Object. Và object Function sẽ gồm các thành phần:</p><ul><li>name: Là tên của function. Nếu không có name thì function sẽ là anonymous function</li><li>code: Là những dòng lệnh khi function được invoke.</li><li>3 utilities function: call(), apply(), bind()</li></ul><h2 id="1-Cach-su-dung-call">1. Cách sử dụng call()</h2><blockquote><p><strong>The call() method calls a function with a given <code>this</code> value and arguments provided individually.</strong></p><p>Nghĩa là: call() sẽ gọi một function ngay lập tức và truyền một tham số đại diện cho <code>this</code> và có thể có hoặc không arguments</p><pre><code>  call(thisArg, arg1, ... , argN)</code></pre></blockquote><p>Ví dụ:</p><blockquote><pre><code>  function print(address, gender) &#123;      console.log(`name: $&#123;this.name&#125;`);      console.log(`address: $&#123;address&#125;`);      console.log(`gender: $&#123;gender&#125;`);  &#125;  var person = &#123;      name: &quot;Jun&quot;  &#125;;  print.call( person,  &quot;VN&quot;, &quot;M&quot;);</code></pre></blockquote><h2 id="2-Cach-su-dung-apply">2. Cách sử dụng apply()</h2><blockquote><p><strong>The apply() method calls a function with a given <code>this</code> value, and arguments provided as an array.</strong></p><p>Nghĩa là: apply() sẽ gọi một function và truyền một tham số đại diện cho <code>this</code> và các arguments là một Array.</p><pre><code>  apply(thisArg, argsArray)</code></pre></blockquote><p>Nhìn chung <code>apply()</code> và <code>call()</code> gần giống nhau. Chúng chỉ khác nhau ở cách truyền các tham số.</p><p>Ví dụ:</p><blockquote><pre><code>  function print(address, gender) &#123;      console.log(`name: $&#123;this.name&#125;`);      console.log(`address: $&#123;address&#125;`);      console.log(`gender: $&#123;gender&#125;`);  &#125;  var person = &#123;      name: &quot;Jun&quot;  &#125;;  print.apply( person,  [&quot;VN&quot;, &quot;M&quot;]);</code></pre></blockquote><h2 id="3-Cach-su-dung-bind">3. Cách sử dụng bind()</h2><blockquote><p><strong>The bind() method creates a new function that, when called, has its this keyword set to the provided value,with a given sequence of arguments preceding any provided when the new function is called.</strong></p><p>Nghĩa là: Trả về một function mới sau khi gọi một function và truyền một tham số đại diện cho <code>this</code> và có thể có hoặc không arguments.</p><pre><code>  bind(thisArg, arg1, ... , argN)</code></pre></blockquote><ul><li>khi function đã được binding bằng <code>bind()</code> thì this context sẽ luôn không đổi.</li><li><code>bind()</code> sẽ rất hữu hiệu khi sử dụng với các callback function.</li><li><code>bind()</code> có độ ưu tiên cao nhất trong 3 functions. Nếu dùng cả <code>bind()</code> và <code>call</code> thì <code>bind()</code> luôn được ưu tiên.VD: bind(obj1).call(obj2). obj1 sẽ được apply</li></ul><p>Ví dụ:</p><blockquote><pre><code>  function print(address, gender) &#123;      console.log(`name: $&#123;this.name&#125;`);      console.log(`address: $&#123;address&#125;`);      console.log(`gender: $&#123;gender&#125;`);  &#125;  var person = &#123;      name: &quot;Jun&quot;  &#125;;  // JS engine sẽ tạo một instance của `print` method  // và binding `person` vào biến `this` của function `print`  var printJun = print.bind( person,  &quot;VN&quot;, &quot;M&quot;);   printJun();</code></pre></blockquote><h2 id="4-Note">4. Note</h2><ul><li>Nếu pass một giá primitive(boolean, number…) vào để đại diện cho <code>this</code> thì nó sẽ được boxing và wrap bởi chính các object của nó (new Boolean(…), new Number(…))</li><li>Nếu truyền <code>null</code> hoặc <code>undefined</code> vào để biểu diễn cho <code>this</code> thì<a href="/Technology/JS/2019/01/16/this-in-javascript/#a-Default-Binding" title="default binding">default binding</a> sẽ được áp dụng.</li></ul><blockquote><pre><code>  function foo(a,b) &#123;      console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );  &#125;  // spreading out array as parameters  foo.apply( null, [2, 3] ); // a:2, b:3  // currying with `bind(..)`  var bar = foo.bind( null, 2 );  bar( 3 ); // a:2, b:3</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> JS </tag>
            
            <tag> Call </tag>
            
            <tag> Apply </tag>
            
            <tag> Bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First class in JS</title>
      <link href="/Technology/JS/2018/12/30/first-class-in-js/"/>
      <url>/Technology/JS/2018/12/30/first-class-in-js/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/first-class-function-in-js.png" alt="first-class-function-in-js"></p><h2 id="1-First-class-function-la-gi">1. First-class function là gì?</h2><blockquote><p><strong>A programming language is said to have First-class functions when functions in that language are treated like any other variable.</strong></p><p>Nghĩa là: Một ngôn ngữ lập trình được gọi là có First-class functions nếu các functions của nó được coi như là một biến. Có thể:</p><ul><li>Có thể gán cho một biến.</li><li>Là một argument cho những functions khác.</li><li>Là kết quả trả về cho một function khác.</li></ul></blockquote><h2 id="2-Gan-function-cho-mot-bien">2. Gán function cho một biến</h2><p>Vì mọi functions trong JS đều là Object, nên ta dễ dàng gán một function cho một biến, và function được gán sẽ sử dụng như là một giá trị cho biến được gán.</p><p>Ví dụ:</p><blockquote><pre><code>  const foo = () =&gt; &#123;      console.log(&quot;foo&quot;);  &#125;  const bar = () =&gt; &#123;      console.log(&quot;bar&quot;);  &#125;  // Invoke it using the variable  foo(); // foo    var funcs = [foo, bar]  funcs.map(e =&gt; e()); // foo bar</code></pre></blockquote><h2 id="3-La-mot-argument-cho-nhung-functions-khac">3. Là một argument cho những functions khác.</h2><p>Ví dụ:</p><blockquote><pre><code>  function helloByVietNamese() &#123;      return &quot;Xin chào, &quot;;  &#125;  function greeting(helloMessage, name) &#123;      console.log(helloMessage() + name);  &#125;  // Pass `helloByVietNamese` as an argument to `greeting` function  greeting(helloByVietNamese, &quot;JavaScript!&quot;);</code></pre></blockquote><p>Function mà được truyền cho những functions khác như là một argument thì nó được gọi là <code>Callback function</code>. Trong trường hợp này <strong>helloByVietNamese</strong> là một Callback function</p><h2 id="4-La-ket-qua-tra-ve-cho-mot-function-khac">4. Là kết quả trả về cho một function khác.</h2><p>Vì trong JS, function có thể được gán cho một biến nên nó cũng hoàn toàn có thể được return từ một function khác.</p><p>Ví dụ:</p><blockquote><pre><code>  function sayHello() &#123;      return function() &#123;          console.log(&quot;Hello!&quot;);      &#125;  &#125;    // first way to run  const myFunc = sayHello();  myFunc(); // Hello!  // second way to run  sayHello()();</code></pre></blockquote><h2 id="5-Note">5. Note</h2><p>First-class functions và Higher-Order function liên hệ rất mật thiết với nhau.Một ngỗn ngữ lập trình có First-class functions có nghĩa là nó support higher-order function.Nhưng một ngôn ngữ support Higher-Order function không có nghĩa nó có First-class functions (tuy nhiên rất khó kiếm ngôn ngữ lập trình nào như thế).</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> JS </tag>
            
            <tag> FirstClassFunction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookies</title>
      <link href="/Technology/JS/2018/05/12/cookies/"/>
      <url>/Technology/JS/2018/05/12/cookies/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cookies.png" alt="Cookies"></p><h2 id="1-Cookies-la-gi">1. Cookies là gì?</h2><p>Là 1 file dữ liệu nhỏ (tối đa là 4093kb) được server trả về và lưu trong trình browser của người dùng.</p><p>Mỗi khi request lên server thì cookie (chỉ key và value, còn những data khác: httpOnly, sameSite… sẽ không được gửi lên) của server đó cũng sẽ được gửi lên cùng.</p><p>Vì thế, nên ưu tiên save thông tin mà server không cần dùng vào localstorage, sessionstorage, indexeddb để tránh việc gửi data thừa lên server.</p><p>Có 3 mục đích chính khi dùng cookies:</p><ul><li>Quản lý phiên làm việc: thông tin đăng nhập, giỏ hàng…</li><li>Thông tin về cá nhân: tùy chọn giao diện, cài đặt…</li><li>Theo dõi, phân tích hành vi của người dùng</li></ul><h2 id="2-Cac-loai-cookies">2. Các loại cookies.</h2><p>Có 2 loại cookies:</p><ul><li>Session Cookies: Cookies sẽ bị xóa khi trình duyệt bị đóng.</li><li>Persistent Cookies: Cookies sẽ bị xóa khi bị hết hạn hoặc bị xóa thủ công</li></ul><p>Khi tạo cookies nếu không set expire date hoặc max-age thì đó là session cookies, còn ngược lại là Persistent cookies</p><h2 id="3-Cac-thanh-phan-co-trong-Cookie">3. Các thành phần có trong Cookie</h2><blockquote><ul><li>name : String</li><li>value : String</li><li>httpOnly : Boolean</li><li>Secure : Boolean</li><li>maxAge : Option[Int]</li><li>sameSite : Option[SameSite]</li><li>domain : Option[String]</li><li>path : String</li></ul></blockquote><p><code>name</code> và <code>value</code> là giá trị thông tin cookie cần lưu.</p><blockquote><pre><code>  name = access_token  value = Bearer MTIzNDU2Nzphc2RmZw==</code></pre></blockquote><p><code>httpOnly</code>: Đảm bảo Cookie chỉ được sử dụng trong 1 HTTP. Sẽ không thể dùng Javascript để lấy được thông tin cookies (document.cookie). Với httpOnly có thể prevent tấn công XSS từ hacker</p><p><code>Secure</code>: Đảm bảo Cookies luôn được mã hóa khi chuyển từ Client lên Server bằng cách chỉ gửi Cookies đi nếu kết nối SSL được sử dụng (Https), với Http Cookie sẽ không được gửi</p><p><code>maxAge</code>: thời gian tồn tại của Cookie. được tính bằng giây (s).</p><blockquote><pre><code>  maxAge = Some ( 1 * 60 * 60)</code></pre></blockquote><p>Chú ý: Nếu giá trị expires cũng được define thì maxAge sẽ được ưu tiên cao hơn =&gt; thời gian tồn tại sẽ tính theo maxAge</p><p><code>Samesite</code>: Giúp bảo vệ khỏi tấn công Cross-site request forgery attacks (CSRF). Có 3 giá trị: Strick, Lax, None</p><p><code>Domain</code>: Với thuộc tính này sẽ giúp define cho việc cookie sẽ được lưu cho những domain nào.</p><blockquote><p>VD: có 3 domain như bên dưới.</p><ul><li><a href="http://batdongsan.com">batdongsan.com</a></li><li><a href="http://aip-frontend-dev.batdongsan.com">aip-frontend-dev.batdongsan.com</a></li><li><a href="http://aip-cms-dev.batdongsan.com">aip-cms-dev.batdongsan.com</a></li></ul><p>Note 1 : Mặc định nếu thuộc tính domain để trống thì các cookie sẽ không được share cho nhau. Cookie chỉ được sử dụng với duy nhất domain mà tạo ra nó</p><p>Note 2: Nếu domain = Some(“.batdongsan.com”) hoặc Some(“<a href="http://batdongsan.com">batdongsan.com</a>”) thì cookie của cả 3 domain sẽ được dùng chung. chỉ cần 1 domain thay đổi cookie là những domain khác cũng nhận được sự thay đổi này</p><p>Path: Với thuộc tính này sẽ define những path nào mới được dùng cookie. Mặc định sẽ là “/”</p><p>VD: path=”/admin” thì chỉ khi nào request từ <a href="http://domain.com/admin">domain.com/admin</a> thì cookie mới được kèm theo, còn <a href="http://domain.com/user">domain.com/user</a> thì không</p></blockquote><h2 id="4-Cach-tao-Cookie">4. Cách tạo Cookie</h2><ul><li>Tạo bằng webserver: tomcat, nginx…</li><li>Tạo bằng framework: Play framework, spring…</li><li>Tạo bằng JS: document.cookie=”access_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9″</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> JS </tag>
            
            <tag> Scala </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Singleton Pattern</title>
      <link href="/Technology/Java/2018/03/01/singleton-pattern/"/>
      <url>/Technology/Java/2018/03/01/singleton-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Singleton-Pattern-la-gi">1. Singleton Pattern là gì?</h2><blockquote><p><strong>The Singleton Pattern ensure a class only has one instance, and provide a global point of access to it</strong></p><p>Nghĩa là: Với 1 class, Singleton đảm bảo luôn luôn có 1 và chỉ 1 instance được khởi tạo cho class đó. Và có thể truy cậpinstance đó ở bất kỳ đâu (bằng cách gọi class method).</p></blockquote><h2 id="2-Uu-nhuoc-diem">2. Ưu, nhược điểm</h2><h3 id="a-Uu-diem">a. Ưu điểm</h3><ul><li>Đảm bảo lass chỉ có duy nhất 1 instance</li><li>Có một global access point trong instance duy nhất đó.</li><li>Singleton object được khởi tạo chỉ khi call class method lần đầu tiên</li></ul><h3 id="b-Nhuoc-diem">b. Nhược điểm</h3><ul><li>Vi phạm nguyên tắc <strong>Single Responsibility Principle</strong> do vừa phải chịu trách nhiệm cho việc quản lý instance của chính nó và vừa quản lý các business logic trong program.</li><li>Cần handle với multithreading.</li><li>Khó trong việc unit test</li></ul><h3 id="c-Khi-nao-ap-dung">c. Khi nào áp dụng</h3><ul><li>Khi class chỉ cần có 1 instance cho tất cả clients. VD: Database Connection, Logger, Caching…</li></ul><h2 id="3-Implementation">3. Implementation</h2><p><img src="/images/design-pattern/singleton.png" alt="singleton"></p><h3 id="a-Lazy-initialization">a. Lazy initialization</h3><ul><li>Chỉ work well nếu Single thread</li></ul><blockquote><pre><code> public class Database &#123;      private static Database instance;      // để constructor là private để tránh việc khởi tạo Object từ bên ngoài     private Database()&#123;&#125;      // cần phải là static method để có thể gọi được getInstance() từ bên ngoài.     // vì không thể gọi được method bình thường nếu không khởi tạo được instance.     public static Database getInstance() &#123;         if (instance == null) instance = new Database();         return instance;     &#125; &#125;</code></pre></blockquote><h3 id="b-Thread-Safe-initialization">b. Thread Safe initialization</h3><ul><li>Bằng các synchronized cả class method dễ dàng cung cấp thread-safety</li><li>Tuy nhiên việc synchronized cả method rất tốn kém mà thực tế chúng ta chỉ cần thread safe với lần tạo instance đầu tiên. Còn khiinstance đã được khởi tạo thì không cần đến thread safe nữa. Để tránh việc này có thể áp dụng Double checked locking bên dưới</li></ul><blockquote><pre><code>  public class Database &#123;        private static Database instance;        private Database()&#123;&#125;        // synchronized để thread safe      public synchronized static Database getInstance() &#123;          if (instance == null) instance = new Database();          return instance;      &#125;  &#125;</code></pre></blockquote><h3 id="c-Double-checked-locking">c. Double checked locking</h3><ul><li>Chuyển việc synchronized method sang block synchronized và dùng<a href="/Technology/Java/Scala/2020/12/12/java-memory-model/#3-Bo-nho-phan-cung-tuong-tac-voi-JVM-memory">volatile</a> keyword.</li><li>Việc khai báo <strong>DatabaseSyncDoubleCheck result = instance</strong> sẽ giúp performance của method tăng lên 25%. Vì nó giúp hạn chế việc access đến biến volatile.</li></ul><blockquote><pre><code>  public class Database &#123;        private volatile static Database instance;       private Database()&#123;&#125;    public static DatabaseSyncDoubleCheck getInstance() &#123;           DatabaseSyncDoubleCheck result = instance;          if (result == null) &#123;              // chỉ synchronize trong lần khởi tạo đầu tiên              synchronized (DatabaseSyncDoubleCheck.class) &#123;                  result = instance;                  if (instance == null) &#123;                      instance = result = new DatabaseSyncDoubleCheck();                  &#125;              &#125;          &#125;          return result;      &#125;  &#125;</code></pre></blockquote><h3 id="d-Eager-initialization">d. Eager initialization</h3><ul><li>Thay vì khởi tạo instance khi getInstance() được call thì ta sẽ tạo new instance khi ngay khi class được load.</li><li>Cách implement này phù hợp với singleton class không sử dụng nhiều resources.</li></ul><blockquote><pre><code>  public class DatabaseEager &#123;            // vì là một static variable nên instance sẽ được khởi tạo khi load class      // nó sẽ đảm bảo thread safe      private static final DatabaseEager instance = new DatabaseEager();        private DatabaseEager()&#123;&#125;        public static DatabaseEager getInstance() &#123;          return instance;      &#125;  &#125;</code></pre></blockquote><h3 id="e-Bill-Pugh-Singleton-Implementation">e. Bill Pugh Singleton Implementation</h3><ul><li>Khi <strong>BillPughSingleton</strong> được load thì <strong>SingletonHelper</strong> sẽ không được load và memory. Chỉ khi nào getInstance() được gọi thì lớp Helper mớiđược gọi và tạo ra instance cho Singleton class.</li><li>Các tiếp cận này không cần synchronization. Vì instance chỉ được khởi tạo 1 lần duy nhất để lưu vào biến static final.</li><li>Đây là một cách implement đơn giản nhưng rất hiệu quả.</li></ul><blockquote><pre><code>  public class BillPughSingleton &#123;        private BillPughSingleton()&#123;&#125;        private static class SingletonHelper&#123;          private static final BillPughSingleton INSTANCE = new BillPughSingleton();      &#125;        public static BillPughSingleton getInstance()&#123;          return SingletonHelper.INSTANCE;      &#125;  &#125;</code></pre></blockquote><h2 id="4-Refer">4. Refer</h2><ul><li><a href="https://www.digitalocean.com/community/tutorials/thread-safety-in-java-singleton-classes">https://www.digitalocean.com/community/tutorials/thread-safety-in-java-singleton-classes</a></li><li><a href="https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/designpattern/creational/singleton">Code example</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Java </tag>
            
            <tag> SingletonPattern </tag>
            
            <tag> DesignPattern </tag>
            
            <tag> CreationalPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Strate Pattern</title>
      <link href="/Technology/Java/2018/01/25/strategy-pattern/"/>
      <url>/Technology/Java/2018/01/25/strategy-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Strategy-Pattern">1. Strategy Pattern.</h2><p>Định nghĩa theo wiki:</p><blockquote><p><strong>The strategy pattern (also known as the policy pattern) is a behavioral software design pattern that enables selecting an algorithm at runtime.Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use.</strong></p><p><strong>Strategy lets the algorithm vary independently from clients that use it</strong></p><p>Nghĩa là: Strategy pattern cho phép tại thời điểm runtime chúng ta có thể thay đổi algorithm trong family algorithms đó.Và implement của algorithm cũng tách biệt với các phần sử dụng nó.</p></blockquote><h2 id="2-Uu-nhuoc-diem">2. Ưu, nhược điểm</h2><h3 id="a-Uu-diem">a. Ưu điểm</h3><ul><li>Thể hiện 1 quy tắc quan trọng trong thiết kế OOP: <strong>Prefer composition over inheritance</strong></li><li>Có thể đổi algorithms được sử dụng trong runtime</li><li>Dễ dang kết hợp các algorithms với nhau mà không làm duplicate code.</li><li>Tách biệt phần implement của algorithm với phần code sử dụng nó.</li><li>Dễ dàng mở rộng với các algorithms mới.</li></ul><h3 id="b-Nhuoc-diem">b. Nhược điểm</h3><ul><li>Chỉ phù hợp với những algorithms hay thay đổi và số lượng lớn.</li></ul><h3 id="c-Khi-nao-ap-dung">c. Khi nào áp dụng</h3><ul><li>Khi có nhiều algorithms và muốn thay đổi việc algorithm này sang algorithm khác trong rumtime</li><li>Khi có nhiều classes giống nhau nhưng chỉ khác nhau về một vài behavior. Mục đích để reduce duplicate code</li><li><strong>Inheritance should only be used when subclass ‘is a’ superclass. Don’t use inheritance to get code reuse. If there is no ‘is a’ relationship, then use composition for code reuse</strong></li></ul><h2 id="3-Implementation">3. Implementation</h2><p><img src="/images/design-pattern/strategy-pattern.png" alt="strategy-pattern"></p><p>Ví dụ chúng ta có đối tượng Calculator có function: Add, Subtract, Multiply. Clients có thể chọn các functions trên tính toán.Áp dụng Strategy ta sẽ có các class được định nghĩa như bên dưới:</p><blockquote><pre><code>   interface Strategy &#123;      public int compute(int a, int b);   &#125;   public class StrategyAdd implements Strategy&#123;        @Override       public int compute(int a, int b) &#123;           return a + b;       &#125;   &#125;   public class StrategySubtract implements Strategy&#123;          @Override       public int compute(int a, int b) &#123;           return a - b;       &#125;   &#125;   public class StrategyMultiply implements Strategy&#123;          @Override       public int compute(int a, int b) &#123;           return a * b;       &#125;   &#125;   public class Calculator &#123;          private Strategy strategy;       private int a;       private int b;          public int compute() &#123;           return strategy.compute(a, b);       &#125;          public Calculator(int a, int b, Strategy strategy) &#123;           this.a = a;           this.b = b;           this.strategy = strategy;       &#125;       // getter &amp; setter   &#125;   public class TestApplication &#123;          public static void main(String[] args) &#123;           StrategyMultiply strategyMultiply = new StrategyMultiply();           int a = 1;           int b = 2;           Calculator calculator = new Calculator(a, b, strategyMultiply);           System.out.println(&quot;Result is: &quot; + calculator.compute());       &#125;   &#125;</code></pre></blockquote><p>Với việc dùng composition chúng ta có thể dễ dàng phát triển thêm feature kết hợp nhiều functions để tính toán.</p><h2 id="4-Refer">4. Refer</h2><ul><li><a href="https://refactoring.guru/design-patterns/strategy">https://refactoring.guru/design-patterns/strategy</a></li><li><a href="https://www.geeksforgeeks.org/favoring-composition-over-inheritance-in-java-with-examples/">https://www.geeksforgeeks.org/favoring-composition-over-inheritance-in-java-with-examples/</a></li><li><a href="https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/designpattern/behavioral/strategy">Code example</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
            <tag> StrategyPattern </tag>
            
            <tag> BehavioralPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Abstract Factory Pattern</title>
      <link href="/Technology/Java/2018/01/20/abstract-factory-pattern/"/>
      <url>/Technology/Java/2018/01/20/abstract-factory-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Abstract-Factory-Pattern-la-gi">1. Abstract Factory Pattern là gì?</h2><blockquote><p><strong>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</strong></p><p>Nghĩa là: Cung cấp một interface cho việc tạo ra tập hợp objects liên quan hoặc phụ thuộc nhau mà không chỉ rõ cụ thể những classes đó.</p></blockquote><h2 id="2-Uu-nhuoc-diem">2. Ưu, nhược điểm</h2><h3 id="a-Uu-diem">a. Ưu điểm</h3><ul><li>Dễ quản lý code hơn do ít dùng câu lệnh rẽ nhánh (if-else, switch-case) hơn khi Factory Method tăng nhiều lên.</li><li>Dễ dàng mở rộng số lượng Factories mà không impact đến các phần khác.</li></ul><h3 id="b-Nhuoc-diem">b. Nhược điểm</h3><ul><li>Code có thể sẽ phức tạp hơn vì cần tạo thêm cái interfaces, classes để cài đặt được pattern này</li></ul><h3 id="c-Khi-nao-ap-dung">c. Khi nào áp dụng</h3><ul><li>Khi muốn tạo ra một loạt các objects có liên quan hoặc phụ thuộc với nhau. Ví dụ như Address và Phone Number của VietNam sẽ là 1 pair và sẽ khác với American.</li><li>Abstract Factory thường được cái đặt cùng Singleton, factory method và đôi khi là prototype.</li></ul><h2 id="3-Implementation">3. Implementation</h2><p><img src="/images/design-pattern/factory-method/abstract-factory.png" alt="abstract-factory"></p><ul><li><strong>AbstractFactory</strong>: là interface hoặc abstract class, chứa các methods tạo ra các objects thuộc 2 abstract ProductA và ProductB.</li><li><strong>ConcreteFactoryX</strong>: là các classes implement các methods của AbstractFactory để tạo ra các objects cụ thể.</li><li><strong>AbstractProduct</strong>: là interface hoặc abstract class, các Product cụ thể sẽ implements nó.</li></ul><blockquote><pre><code>   public abstract class Pho &#123;          protected String meat;          public void cook(String note) &#123;           System.out.println(&quot;Cooking Pho with &quot; + meat + &quot; and &quot; + note);       &#125;          public abstract Pho delivery();          public void description() &#123;           System.out.println(&quot;This is &quot; + meat + &quot; Pho&quot;);       &#125;   &#125;      public class BeefPho extends Pho &#123;          public BeefPho() &#123;           this.meat = &quot;Beef&quot;;       &#125;          @Override       public Pho delivery() &#123;           //do something           return this;       &#125;   &#125;     public class ChickenPho extends Pho &#123;          public ChickenPho() &#123;           this.meat = &quot;Chicken&quot;;       &#125;          @Override       public Pho delivery() &#123;           //do something           return this;       &#125;   &#125;   public abstract class PhoFactory &#123;         // createPho bat buoc subclasses phai implement no      // PhoFactory khong biet duoc subclasses tao instance cho class nao.      public abstract Pho createPho(PhoType type);         public void order(PhoType type)&#123;          Pho pho = createPho(type);          pho.description();      &#125;  &#125;    public class HaNoiPhoFactory extends PhoFactory&#123;        @Override      public Pho createPho(PhoType type) &#123;          Pho pho;          if (type == PhoType.BEEF_PHO) &#123;              pho = new BeefPho();          &#125; else &#123;              pho = new ChickenPho();          &#125;          pho.cook(&quot;well-done meat&quot;);          return pho.delivery();      &#125;  &#125;    public class NamDinhPhoFactory extends PhoFactory&#123;        @Override      public Pho createPho(PhoType type) &#123;          Pho pho;          if (type == PhoType.BEEF_PHO) &#123;               pho = new BeefPho();          &#125; else &#123;              pho = new ChickenPho();          &#125;          pho.cook(&quot;medium-rare meat&quot;);          return pho.delivery();      &#125;  &#125;    public class Test &#123;        public static String location = &quot;NAM_DINH&quot;;        public static void main(String[] args) &#123;          PhoFactory phoFactory;          if (location.equals(&quot;NAM_DINH&quot;)) &#123;               phoFactory = new NamDinhPhoFactory();          &#125; else &#123;              phoFactory = new HaNoiPhoFactory();          &#125;          phoFactory.order(PhoType.BEEF_PHO);      &#125;  &#125;</code></pre></blockquote><h2 id="4-Refer">4. Refer</h2><ul><li><a href="https://refactoring.guru/design-patterns/abstract-factory">https://refactoring.guru/design-patterns/abstract-factory</a></li><li><a href="https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/designpattern/creational/factory/abstractfactory">Code example</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Java </tag>
            
            <tag> AbstractFactoryPattern </tag>
            
            <tag> DesignPattern </tag>
            
            <tag> CreationalPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Factory Pattern</title>
      <link href="/Technology/Java/2018/01/10/factory-pattern/"/>
      <url>/Technology/Java/2018/01/10/factory-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Factory-Pattern">1. Factory Pattern.</h2><p>Factory Pattern có 3 mô hình chính:</p><ul><li>Simple Factory</li><li>Factory method</li><li>Abstract factory</li></ul><p><strong>Lợi ích</strong></p><ul><li>Giúp loose coupling cho code vì hướng tiếp cận đã được chuyển sang <strong>implement an interface</strong>.</li><li>Scalable code một cách đơn giản. Thêm khai báo trong Factory</li><li>Che dấu được việc khởi tạo các objects và tập trung code vào một nơi sẽ giúp client có thể khởi tạo chúng ở nhiều nơi một cách ngắn gọn, dễ dàng.</li></ul><p>Trong nội dung bài này chúng ta sẽ đi tìm hiểu Simple Factory và Factory method. Abstract factory sẽ được viết trong một bài khác.</p><h2 id="2-Simple-Factory">2. Simple Factory</h2><h3 id="a-Simple-Factory-la-gi">a. Simple Factory là gì?</h3><blockquote><p><strong>Creates objects without exposing the instantiation logic to the client.</strong></p><p>Nghĩa là: Tạo ra các objects mà không lộ logic khởi tạo cho client. Hay còn gọi là <strong>Static Factory Method</strong></p></blockquote><ul><li>Nó <code>không</code> được coi là một Design Pattern.</li><li>Được sử dụng khi client chỉ cần một object mà không quan tâm về cách tạo ra nó.VD: Chỉ quan tâm là có một bát phở, còn phở được nấu với thịt bò hay thịt gà thì không quan trọng.</li></ul><h3 id="b-Implementation">b. Implementation</h3><p><img src="/images/design-pattern/factory-method/simple-factory.png" alt="simple-factory"></p><ul><li><strong>factoryMethod</strong> thường là một <a href="/Technology/Java/2017/08/24/static-in-java/#3-Static-methods">static method</a> để đỡ tốn công vào việc khởi tạo object Factory.</li><li><strong>ParentClass</strong> nên là abstract class hoặc interface.</li><li><strong>App</strong> sẽ call <strong>factoryMethod()</strong> trong <strong>SimpleFactory</strong> để khởi tạo một object có kiểu là <strong>ParentClass</strong></li></ul><p>Ví dụ:</p><blockquote><pre><code>   public abstract class Pho &#123;          protected String meat;          public void cook(String note) &#123;           System.out.println(&quot;Cooking Pho with &quot; + meat + &quot; and &quot; + note);       &#125;          public abstract Pho delivery();          public void description() &#123;           System.out.println(&quot;This is &quot; + meat + &quot; Pho&quot;);       &#125;   &#125;      public class BeefPho extends Pho &#123;          public BeefPho() &#123;           this.meat = &quot;Beef&quot;;       &#125;          @Override       public Pho delivery() &#123;           //do something           return this;       &#125;   &#125;     public class ChickenPho extends Pho &#123;          public ChickenPho() &#123;           this.meat = &quot;Chicken&quot;;       &#125;          @Override       public Pho delivery() &#123;           //do something           return this;       &#125;   &#125;    public class PhoFactory &#123;      // khai báo là static method để tránh việc khởi tạo PhoFactory      public static Pho order(PhoType type) &#123;          Pho pho;          if (type == PhoType.BEEF_PHO) &#123;              pho = new BeefPho();          &#125; else &#123;              pho = new ChickenPho();          &#125;          pho.cook(&quot;well-done meat&quot;);          return pho.delivery();      &#125;  &#125;    public enum PhoType &#123;      BEEF_PHO, CHICKEN_PHO  &#125;    public class Test &#123;      public static void main(String[] args) &#123;          Pho pho = PhoFactory.order(PhoType.BEEF_PHO);          pho.description();      &#125;  &#125;</code></pre></blockquote><h2 id="3-Factory-Method-Pattern">3. Factory Method Pattern</h2><h3 id="a-Factory-Method-Pattern-la-gi">a. Factory Method Pattern là gì?</h3><blockquote><p>Theo Gang of Four: <strong>Define an interface for creating an object, but let subclasses decide which class to instantiate.Factory Method lets a class defer instantiation to subclasses.</strong></p><p>Nghĩa là: Định nghĩa một interface để tạo một object, nhưng để subclasses quyết định class nào được khởi tạo instance.Factory Method để việc khởi tạo một object cụ thể cho các subclasses</p></blockquote><ul><li>Factory method gợi ý chúng ta thay vì khởi tạo 1 object cụ thể bằng trực tiếp gọi toán tử <code>new</code> thì hãy gọi nó qua một factory method.</li><li>Được sử dụng khi client không biết những lớp cụ thể nào được yêu cầu tạo trong runtime, nó chỉ muốn nhận một object để thực hiện việc gì đó.</li></ul><h3 id="b-Implementation-v2">b. Implementation</h3><ul><li>Tạo ra một abstract hoặc interface Creator class với mục đích khai báo <strong>factoryMethod()</strong>.</li><li><strong>factoryMethod()</strong> NÊN là một abstract method để các subclasses bắt buộc phải implements nó.</li><li>Tạo ra các subclasses <strong>ConcreteCreator</strong> để implement method <strong>factoryMethod()</strong> của Creator.Đây chính là cách là Factory Method để việc khởi tạo một object cho các subclasses quyết định</li></ul><p><img src="/images/design-pattern/factory-method/factory-method.png" alt="factory-method"></p><p>Ví dụ:Áp dụng Factory Method vào ví dụ bên trên chúng ta cần sửa lại PhoFactory và Test.Đồng thời tạo thêm HaNoiPhoFactory (chuyên món BeefPho )và NamDinhPhoFactory (chuyên về món ChickenPho) để extends PhoFactory.</p><blockquote><pre><code>   public abstract class PhoFactory &#123;         // createPho bat buoc subclasses phai implement no      // PhoFactory khong biet duoc subclasses tao instance cho class nao.      public abstract Pho createPho();         public void order()&#123;          Pho pho = createPho();          pho.description();      &#125;  &#125;    public class HaNoiPhoFactory extends PhoFactory&#123;        @Override      public Pho createPho() &#123;          Pho pho = new BeefPho();          pho.cook(&quot;well-done meat&quot;);          return pho.delivery();      &#125;  &#125;    public class NamDinhPhoFactory extends PhoFactory&#123;        @Override      public Pho createPho() &#123;          Pho pho = new ChickenPho();          pho.cook(&quot;Chicken's legs&quot;);          return pho.delivery();      &#125;  &#125;    public class Test &#123;        public static String location = &quot;NAM_DINH&quot;;        public static void main(String[] args) &#123;          PhoFactory phoFactory;          if (location.equals(&quot;NAM_DINH&quot;)) &#123;               phoFactory = new NamDinhPhoFactory();          &#125; else &#123;              phoFactory = new HaNoiPhoFactory();          &#125;          phoFactory.order();      &#125;  &#125;</code></pre></blockquote><h2 id="4-Refer">4. Refer</h2><ul><li><a href="https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/designpattern/creational/factory/factorymethod">Code example</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
            <tag> FactoryPattern </tag>
            
            <tag> SimpleFactory </tag>
            
            <tag> FactoryMethod </tag>
            
            <tag> CreationalPatterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design Pattern</title>
      <link href="/Technology/Java/2018/01/05/design-pattern/"/>
      <url>/Technology/Java/2018/01/05/design-pattern/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/design-pattern/design-pattern.png" alt="design-pattern"></p><h2 id="1-Design-Pattern-la-gi">1. Design Pattern là gì?</h2><blockquote><p><strong>In software engineering, a design pattern is a general repeatable solution to a commonly occurring problem in software design.It is a description or template for how to solve a problem that can be used in many different situations.</strong></p><p>Nghĩa là: Một design pattern là một giải pháp có thể lặp lại chung cho các vấn đề thưởng gặp trong thiết kế phần mềm.Nó là một bản mô tả hoặc template về cách giải quyết vấn để có thể được sử dụng trong nhiều trường hợp khác nhau, mà không phụ thuộc vào công nghệ.</p></blockquote><p>Theo Gang of Four, 2 quy tắc quan trọng nhất trong thiết kế phần mềm hướng đối tượng:</p><ul><li>Program to an interface, not an implementation.</li><li>Prefer composition over inheritance. (Inheritance should only be used when subclass ‘is a’ superclass. Don’t use inheritance to get code reuse. If there is no ‘is a’ relationship, then use composition for code reuse)</li></ul><p>Lợi ích:</p><ul><li>Giúp code dễ thay đổi, nâng cấp, sửa chữa.</li><li>Giúp code dễ hiểu, ít bugs.</li><li>Giúp reuse code hiệu quả.</li><li>Tăng tốc độ phát triển phần mềm.</li></ul><h2 id="2-Cac-loai-Patterns">2. Các loại Patterns</h2><h3 id="a-Creational-design-patterns">a. Creational design patterns</h3><p>Giúp trong việc khởi tạo các class và object. Nó có thể chia thành 2 phần: <strong>class-creation patterns</strong> and <strong>object-creational patterns</strong>.</p><ul><li><a href="/Technology/Java/2018/01/10/factory-pattern/#3-Factory-Method-Pattern" title="Factory Method">Factory Method</a></li><li><a href="/Technology/Java/2018/01/20/abstract-factory-pattern/" title="Abstract Factory">Abstract Factory</a></li><li>Builder</li><li>Prototype</li><li><a href="/Technology/Java/2018/03/01/singleton-pattern/" title="Singleton">Singleton</a></li></ul><h3 id="b-Structural-design-patterns">b. Structural design patterns</h3><p>Giúp chúng ta thiết lập, định nghĩa quan hệ giữa các đối tượng với nhau</p><ul><li>Adapter</li><li>Bridge</li><li>Composite</li><li>Decorator</li><li>Facade</li><li>Flyweight</li><li>Proxy</li></ul><h3 id="c-Behavioral-design-patterns">c. Behavioral design patterns</h3><p>Thiết kế liên quan đến các hành vi của các đối tượng.</p><ul><li>Interpreter</li><li>Template Method</li><li>Chain of Responsibility</li><li>Command</li><li>Iterator</li><li>Mediator</li><li>Memento</li><li>Observer</li><li>State</li><li><a href="/Technology/Java/2018/01/25/strategy-pattern/" title="Strategy">Strategy</a></li><li>Visitor</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Java </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLID-principles</title>
      <link href="/Technology/Java/Scala/2017/12/09/SOLID-principles/"/>
      <url>/Technology/Java/Scala/2017/12/09/SOLID-principles/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SOLID-la-gi">1. SOLID là gì?</h2><ul><li>Là những nguyên lý thiết kế trong OOP. Nó giúp project dễ hiểu, dễ maintenance, dễ testing và linh hoạt hơn. Nên khi scale project cũng sẽ dễ dàng hơn</li><li>Nó là viết tắt của 5 nguyên lý sau:<ul><li>Single responsibility - Đơn chức năng</li><li>Open/closed</li><li>Liskov substitution (LSP) – thay thế</li><li>Interface segregation (ISP) – phân tách</li><li>Dependency Inversion</li></ul></li></ul><p><img src="/images/SOLID-principles.jpeg" alt="SOLID-principles"></p><h2 id="2-Single-responsibility-principle">2. Single responsibility principle</h2><blockquote><p><strong>A class should have one and only one reason to change, meaning that a class should have only one job.</strong></p><p>Nghĩa là: Một class chỉ nên giữ một trách nhiệm duy nhất. Chỉ có thể sửa đổi class với một lý do duy nhất</p></blockquote><p>Lợi ích:</p><ul><li>Testing: số test cases sẽ ít hơn</li><li>Lower coupling: các class ít phụ thuộc vào nhau.</li><li>Organization:<ul><li>Tổ chức các class nhỏ sẽ dễ dàng cho việc tìm kiếm hơn trong một class lớn.</li><li>Code bớt cồng kềnh hơn, khi thay đổi code sẽ bớt khó khăn và giảm impact đến features khác.</li></ul></li></ul><p>Ví dụ:</p><blockquote><pre><code>  public class Book &#123;      private String name;      private String content;      public boolean isWordInContent(String w)&#123;          return content.contains(w);      &#125;      // method này đã vi phạm nguyên tắc Single responsibility.      // Cách giải quyết là viết method này sang BookPrinter.java      // Ở BookPrinter chúng ta có thể thêm các phương thức khác như printContentToScreen,...      public void printContentToConsole() &#123;         // do something      &#125;  &#125;</code></pre></blockquote><p>Cách khắc phục là tạo ra class mới chỉ xử lý việc hiển thị nội dung qua các phương tiện khác</p><blockquote><pre><code>  public class BookPrinter &#123;      public void printContentToConsole(String text) &#123;          // do something      &#125;      public void printContentToScreen(String text) &#123;          // do something      &#125;  &#125;</code></pre></blockquote><h2 id="3-Open-closed-principle">3. Open/closed principle</h2><blockquote><p><strong>Objects or entities should be open for extension but closed for modification.</strong></p><p>Nghĩa là: Một class có thể mở rộng thoải mái, nhưng không sửa đổi nó.</p></blockquote><p>Lợi ích:</p><ul><li>Ngăn sửa đổi những code đã có để không phát sinh bugs cho những đoạn code đang sử dụng.</li></ul><p>Ví dụ:</p><p>Vẫn với class <code>Book</code> như phía trên, nhưng hôm nay chúng ta nhận được yêu cầu cần thêm một loại sách <code>ebook</code> vào trong program. Loại sách này sẽ có thêm attribute là <code>link</code> để thể hiện link của cuốn sách.Thay vì thêm trực tiếp <code>link</code> vào class <code>Book</code>, chúng ta nên tạo ra class <code>EBook</code> extend lại <code>Book</code>. Điều này giúp chúng ta không cần quan tâm đến những đoạn code mà <code>Book</code> được sử dụng</p><blockquote><pre><code>  public class EBook extends Book&#123;      private String link;  &#125;</code></pre></blockquote><h2 id="4-Liskov-substitution-principle-LSP">4. Liskov substitution principle (LSP)</h2><blockquote><p><strong>if class A is a subtype of class B, we should be able to replace B with A without disrupting the behavior of our program.</strong></p><p>Nghĩa là: Nếu class A là 1 subtype của class B, thì B có thể được thay thế bằng A mà không làm thay đổi tính đúng đắn của chương trình</p></blockquote><p>Lợi ích:</p><ul><li>Giúp đảm bảo class cha và class con luôn luôn nhất quán với nhau.</li></ul><p>Biểu hiện:</p><ul><li>class con <code>Override method</code> class cha nhưng thực hiện chức năng khác.</li><li>class con <code>Override method</code> class cha nhưng throw exception.</li><li>class con <code>Override method</code> class cha nhưng không làm gì cả.</li></ul><p>Ví dụ:</p><blockquote><pre><code>  public abstract class Book &#123;      protected String name;      protected String content;      public abstract String preview();  &#125;  public class EBook extends Book &#123;      private String link;      @Override      public String preview() &#123;          return this.content.substring(0, 200);      &#125;  &#125;</code></pre></blockquote><blockquote><pre><code>  public class PaperBook extends Book&#123;      // method này đã vi phạm LSP.      // vì mặc dù PaperBook là subtype của Book      // tuy nhiên method preview lại không thực hiện chức năng như class Book define      @Override      public String preview() &#123;          return null;      &#125;  &#125;</code></pre></blockquote><p>Cách khắc phục là ta để method <code>preview()</code>chỉ define ở trong class <code>Ebook</code></p><h2 id="5-Interface-segregation-principle-ISP">5. Interface segregation principle (ISP)</h2><blockquote><p><strong>Larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them</strong></p><p>Thay vì dùng 1 interface lớn, ta nên tách thành nhiều interface nhỏ</p></blockquote><p>Lợi ích:</p><ul><li>Có thể đảm bảo rằng việc implement các class chỉ cần quan tâm đến các method mà chúng quan tâm.</li></ul><p>Ví dụ:</p><blockquote><pre><code>  public interface Repository &#123;      public Book resolveBy(long id);      public List&lt;Book&gt; resolveAll();      public boolean resolveBy(Book book);  &#125;</code></pre></blockquote><p>Vì có thể có những class chỉ sử dụng đến các chức năng resolve mà không dùng đến chức năng update. Nên để không vi phạm ISP ta nên tách nhỏ <code>Repository</code> thành các interface nhỏ hơn.</p><blockquote><pre><code>  public interface ResolveFeatureRepository &#123;      public Book resolveBy(long id);  &#125;  public interface ResolveAllFeatureRepository &#123;      public List&lt;Book&gt; resolveAll();  &#125;  public interface UpdateFeatureRepository &#123;      public boolean update(Book book);  &#125;  public interface BookRepository extends ResolveFeatureRepository, UpdateFeatureRepository &#123;&#125;  public class BookRepositoryImpl implements BookRepository &#123;      @Override      public Book resolveBy(long id) &#123;          // do something      &#125;      @Override      public boolean update(Book book) &#123;          // do something      &#125;  &#125;</code></pre></blockquote><h2 id="6-Dependency-Inversion-Principle">6. Dependency Inversion Principle</h2><blockquote><p><strong>High-level modules should not depend on low-level modules. Both should depend on abstractions.</strong></p><p>Nghĩa là: Các module cấp cao không nên phụ thuộc vào các modules cấp thấp. Cả 2 nên phụ thuộc vào abstraction.</p><p><strong>Abstractions should not depend upon details. Details should depend upon abstractions.</strong></p><p>Nghĩa là: Interface (abstraction) không nên phụ thuộc vào chi tiết, mà ngược lại. (Các class giao tiếp với nhau thông qua interface, không phải thông qua implementation.)</p></blockquote><p>Để tránh sự phụ thuộc vào nhau, các module cấp cao nên tạo ra interface, các module cấp thấp sẽ implements các interface đó.</p><p>Ví dụ:</p><p>Chúng ta có class <code>Windows98Machine</code> với <code>StandardKeyboard</code> và <code>monitor</code>.</p><blockquote><pre><code>  public class Windows98Machine &#123;      private final StandardKeyboard keyboard;      private final Monitor monitor;      public Windows98Machine() &#123;          monitor = new Monitor();          keyboard = new StandardKeyboard();      &#125;  &#125;</code></pre></blockquote><p>Tuy nhiên đoạn code trên có vấn đề trong việc khởi tạo <code>monitor</code> và <code>keyboard</code> cố định với từ khóa <code>new</code>. Nó làm đoạn cả <code>Windows98Machine, StandardKeyboard, Monitor</code> dính chặt với nhau.Nếu muốn thay keyboard hay monitor thành một loại khác sẽ khiến chúng ta phải thay đổi code nhiều nơi. Chúng ta có thế sửa thành</p><blockquote><pre><code>  public interface Keyboard &#123; &#125;  public class Windows98Machine&#123;      private final Keyboard keyboard;      private final Monitor monitor;      public Windows98Machine(Keyboard keyboard, Monitor monitor) &#123;          this.keyboard = keyboard;          this.monitor = monitor;      &#125;  &#125;  public class StandardKeyboard implements Keyboard &#123; &#125;</code></pre></blockquote><p>Việc này làm giúp code của chúng ta lower coupling, dễ thay đổi, ít bugs hơn.</p><h2 id="7-Refer">7. Refer</h2><ul><li><a href="https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/solid">Code example</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Scala </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String vs StringBuilder vs StringBuffer in Java</title>
      <link href="/Technology/Java/Scala/2017/11/01/string-vs-stringbuilder-stringbuffer/"/>
      <url>/Technology/Java/Scala/2017/11/01/string-vs-stringbuilder-stringbuffer/</url>
      
        <content type="html"><![CDATA[<p>Khi làm việc với chuỗi trong Java chúng ta có 3 options: String, StringBuilder, StringBuffer.</p><ul><li><p>Với String là immutable. Khi một chuỗi String được tạo ra sẽ không thể thay đổi được giá trịcủa nó.</p></li><li><p>Với StringBuilder và StringBuffer là mutable. Nó được tạo ra để giúp cho việc thay đổi giá trịcủa chuỗi. Nhưng StringBuffer thread safe còn String Builder thì không.</p></li></ul><p><img src="/images/string-stringbuilder-stringbuffer.jpeg" alt="string-stringbuilder-stringbuffer.jpeg">Để làm rõ hơn chúng ta cùng tìm hiểu chi tiết về chúng.</p><h2 id="1-String-Concatenation">1. String Concatenation</h2><p>Ta xét ví dụ sau:</p><blockquote><pre><code>  String query = &quot;SELECT username FROM&quot; + &quot; Users &quot; + &quot; WHERE 1 = 1&quot;;  query += &quot; AND age &gt; 20&quot;;  query += &quot; AND gender = 1&quot;;  query = query.concat(&quot; AND is_delete = 0&quot;);</code></pre></blockquote><h3 id="a-String-Concatenation-voi-operator">a. String Concatenation với <code>+</code> operator</h3><blockquote><pre><code>  String query = &quot;SELECT username FROM&quot; + &quot; Users &quot; + &quot; WHERE 1 = 1&quot;;</code></pre></blockquote><p>Với câu lệnh này thì Java compiler sẽ convert chúng thành:</p><blockquote><pre><code>  String query = (new StringBuilder()).append(&quot;SELECT username FROM&quot;)      .append(&quot; Users&quot;)      .append(&quot; WHERE 1 = 1&quot;).toString();  </code></pre></blockquote><p>Thay vì việc tạo ra nhiều ô chỉ nhớ khác nhau để lưu các String và sau đó cộng chúng lại với nhau. Compiler của Java đã làm việcrất hiệu quả để tối ưu được bộ nhớ.</p><blockquote><p>Note:Có thể dùng <code>+</code> để concat các giá trị primitive khác với String. Compiler cũng sẽ convert chúng như trên.</p><pre><code>  String info = &quot;I am &quot; + 25 + &quot;years old&quot;;</code></pre></blockquote><h3 id="b-String-Concatenation-bang-operator">b. String Concatenation bằng <code>+=</code> operator</h3><blockquote><pre><code>  query += &quot; AND age &gt; 20&quot;;  query += &quot; AND gender = 1&quot;;</code></pre></blockquote><p>Java compiler sẽ convert chúng thành:</p><blockquote><pre><code>  String query = &quot;SELECT username FROM&quot; + &quot; Users &quot; + &quot; WHERE 1 = 1&quot;;  StringBuilder tmp;  tmp = new StringBuilder();  tmp.append(query);  tmp.append(&quot; AND age &gt; 20&quot;);  query = tmp.toString();  tmp = new StringBuilder();  tmp.append(query);  tmp.append(&quot; AND gender = 1&quot;);  query = tmp.toString();</code></pre></blockquote><p>Như vậy sẽ tạo ra rất nhiều instant của StringBuilder. Khi số lượng chuỗi cộng ít thì có thể không vấn đề.Nhưng khi số lượng lớn nên sẽ rất ảnh hưởng đến performance. (Xem kết quả thực nghiệm phía dưới)</p><h3 id="c-String-Concatenation-bang-concat-operator">c. String Concatenation bằng concat() operator</h3><blockquote><pre><code>  query = query.concat(&quot; AND is_delete = 0&quot;);</code></pre></blockquote><p>Vì concat() của String trong Java được thực hiện bằng cách:</p><ul><li>Tạo ra một <code>char Arrays</code> mới có size bằng số ký tự của 2 chuỗi.</li><li>Copy giá trị của chuỗi 1 và chuỗi 2 vào <code>char Arrays</code> mới vừa được tạo.</li><li>Trỏ lại biến vào String mới vừa được tạo ra.</li></ul><blockquote><p>Note:Với cách dùng concat() gây tốn bộ nhớ và performance khi phải tạo 1 ô nhớ mới.</p></blockquote><h2 id="2-StringBuilder-va-StringBuffer">2. StringBuilder và StringBuffer</h2><ul><li>StringBuilder/StringBuffer sử dụng <code>char Array</code> là mutable khác với <code>char Array</code> của String là immutable.</li><li>Khi cộng chuỗi, StringBuilder/StringBuffer sẽ thực hiện việc thay đổi giá trị của <code>char Array</code> thay vì tạo ra liên tục các instant mới.</li></ul><p>=&gt; Chính vì thế khi cộng chuỗi được thực hiện nhiều lần StringBuilder/StringBuffer cho hiệu năng vượt trội hơn hẳn String.</p><h2 id="3-Ket-luan">3. Kết luận</h2><ul><li>Nếu có thể hãy sử dụng concat by <code>+</code> operator của String để có được hiệu năng và clean code tốt nhất.</li><li>Nếu việc cộng chuỗi được lặp lại nhiều lần, ưu tiên hàng đầu là StringBuilder (/StringBuffer nếu cần thread-safe).</li><li>Hạn chế tối đa việc sử dụng <code>+=</code> operator của String</li></ul><h2 id="4-Thu-nghiem">4. Thử nghiệm</h2><blockquote><pre><code>  String c = &quot;&quot;;  // StringBuilder c = new StringBuilder(&quot;&quot;);  for (long i = 0; i &lt; 100000L; i++) &#123;      c = c.concat(b); // take 10s  //    c += b; // take 40s  //    c.append(b) // 15ms  &#125;</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Scala </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Static in Java</title>
      <link href="/Technology/Java/2017/08/24/static-in-java/"/>
      <url>/Technology/Java/2017/08/24/static-in-java/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/static-in-java.png" alt="static-in-java"></p><h2 id="1-Tu-khoa-static">1. Từ khóa static</h2><ul><li>static mục đích chính là để quản lý bộ nhớ tốt hơn.</li><li>static được sử dụng trong 4 trường hợp sau:<ul><li>static variables</li><li>static methods</li><li>static blocks of code</li><li>static nested class</li></ul></li></ul><h2 id="2-Static-variable">2. Static variable</h2><ul><li>Khi khai báo một biến với static thì biến đó là biến static.</li><li>Biến static thuộc về class chứ không phải instance nên nó có thể truy cập trực tiếp bằng tên của class mà không cần object.</li><li>Biến static được chia sẻ chung cho tất cả các instance của class đó.</li><li>Biến static chỉ được cấp phát bộ nhớ một lần khi loading class trong class Area.</li></ul><blockquote><p>Class Area là một thành phần của JVM. Nó lưu trữ cấu trúc của các lớp, thuộc tính, phương thức của lớp, và code của các phương thức.</p></blockquote><p>Ví dụ:</p><blockquote><pre><code>  public class Counter &#123;       public static int COUNT = 0;        int count = 0;       public void add() &#123;           COUNT++;           count++;           System.out.println(COUNT);            System.out.println(count);       &#125;          public static void main(String[] args) &#123;           Counter c1 = new Counter();           c1.add(); // COUNT = 1; count = 1;           // do COUNT được share chung với các instance nên           // cả c1.COUNT, c2.COUNT hay Counter.COUNT cũng đều trỏ vào chung một biến           Counter c2 = new Counter();           c2.add(); // COUNT = 2; count = 1;       &#125;   &#125;</code></pre></blockquote><h2 id="3-Static-methods">3. Static methods</h2><ul><li>Khi khai báo một method với static thì biến đó là method static.</li><li>Giống như biến static, static method thuộc về class chứ không phải instance nên nó có thể truy cập trực tiếp bằng tên của class mà không cần object.</li><li>Static method có thể truy cập và thay đổi giá trị của biến static, nhưng không gọi trực tiếp các biến non-static khác.</li><li>Static method có thể gọi các static method khác, nhưng không gọi trực tiếp các non-static method khác.</li><li>Static method không thể sử dụng <code>this</code> và <code>super</code> trong thân hàm</li></ul><p>Ví dụ:</p><p>Trong class Counter ta tạo thêm 2 static method như sau:</p><blockquote><pre><code>   static void subtract() &#123;      COUNT--; // Call trực tiếp được một biến static      // count--; Không thể call một biến non-static      print(); // call trực tiếp một static method   &#125;   static void print()&#123;       System.out.println(COUNT);   &#125;</code></pre></blockquote><p>Khi này trong hàm <code>main</code> ta thêm dòng code sau:</p><blockquote><pre><code>  Counter.subtract(); // 1 </code></pre></blockquote><h2 id="4-Static-blocks-of-code">4. Static blocks of code</h2><ul><li>static blocks được dùng để tạo hoặc thay đổi giá trị cho các biến static.</li><li>static blocks sẽ được execute trước khi hàm main khi loading class</li></ul><p>Ví dụ:</p><blockquote><pre><code>   public class Counter &#123;          public static int COUNT;       int count = 0;          static &#123;          System.out.println(&quot;invoked static block&quot;);           COUNT = 0;       &#125;       public static void main(String[] args) &#123;           System.out.println(&quot;invoked main&quot;);       &#125;   &#125;</code></pre></blockquote><p>Kết quả:</p><pre><code>    invoked static block    invoked main    0</code></pre><h2 id="5-Static-nested-class">5. Static nested class</h2><ul><li>Static nested class giúp nhóm các class có liên quan lại với nhau. Và giúp code của chúng đơn giản hơn.</li><li>Tất cả <strong>static classes</strong> là <strong>nested class</strong> (các classes bên trong), nhưng ngược lại thì không.</li><li>Nó chỉ truy cập được các variables và methods static của outer class (bao gồm cả <strong>private</strong> access modifier).</li></ul><p>Ví dụ:</p><blockquote><pre><code>   public class Outer &#123;          private static String name = &quot;Outer&quot;;       private String hello = &quot;This is outer class&quot;;          //static nested class       static class InnerStatic &#123;           void replaceOuterName() &#123;               // thay đổi biến static của outer class mặc dù name là `private`               name = &quot;Outer class&quot;;               // hello = &quot;&quot;; -- vì des là non-static variable nên sẽ bị lỗi           &#125;           static void print() &#123;               System.out.println(name);           &#125;       &#125;          // inner class       class InnerNonStatic &#123;           void sayHello() &#123;               // truy cập tất cả các biến của Outer class               System.out.println(hello + &quot;, I am InnerNonStatic&quot;);           &#125;       &#125;          public static void main(String[] args) &#123;           // Do `replaceOuterName()` là non-static method nên           // cần tạo instance cho `InnerStatic` class           Outer.InnerStatic obj = new Outer.InnerStatic();           obj.replaceOuterName();           System.out.println(Outer.name); // Outer class              Outer.InnerStatic.print();              Outer outer = new Outer();          Outer.InnerNonStatic nonStatic = outer.new InnerNonStatic();           nonStatic.sayHello();       &#125;   &#125;</code></pre></blockquote><h2 id="6-Refer">6. Refer</h2><ul><li><a href="https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/staticinjava">Code example</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Java </tag>
            
            <tag> Static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String pool</title>
      <link href="/Technology/Java/Scala/2017/08/10/string-pool/"/>
      <url>/Technology/Java/Scala/2017/08/10/string-pool/</url>
      
        <content type="html"><![CDATA[<h2 id="1-String-la-gi">1. String là gì?</h2><p>Chúng ta chắc hẳn đã rất quen thuộc với String khi code Java. Với định nghĩa <a href="https://docs.oracle.com/javase/tutorial/java/data/strings.html">String</a> từ Oracle như sau:</p><blockquote><p>Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects</p></blockquote><p>Có một vài chú ý với String như sau:</p><ul><li>String là 1 reference type</li><li>Là immutable (không thể thay đổi được giá trị, ô chỉ nhớ của n)</li><li>Có thể tạo mới 1 String theo 2 cách:<ul><li>String literal</li><li>new operator</li></ul></li></ul><p>Bài toán đặt ra: vì String là immutable, khi tạo quá nhiều String, liệu có dễ xảy ra tràn bộ nhớ Heap không?=&gt; Câu trả lời chính là String Pool</p><h2 id="2-String-pool-la-gi">2. String pool là gì?</h2><ul><li>String Pool là 1 phân vùng nhỏ nằm trong bộ nhớ Heap chứa các Strings.</li><li>Nó được tạo ra với mục đích tối ưu lưu trữ và dùng vùng nhớ khi khai báo String từ đó giúp hạn chế tình trạng tràn bộ nhớ Heap</li></ul><h2 id="3-Cach-hoat-dong-cua-String-pool">3. Cách hoạt động của String pool</h2><p><img src="/images/string-constant-pool-in-java.png" alt="string-constant-pool-in-java"></p><h3 id="a-Tao-String-moi-bang-String-literal">a. Tạo String mới bằng String literal</h3><p>JVM sẽ check trong String pool xem có ô nhớ nào có giá trị giống với giá trị cần tạo hay không? Nếu tồn tại trong pool rồi nó sẽ tham chiếu đến ô chỉ nhớ vừa tìm được, ngược lại, nếu không tìm thấy ô nhớ nào có giá trị giống giá trị cần tạo, JVM sẽ lưu giá trị mới vào trong pool và tiến hành trỏ vào ô chỉ nhớ mới tạo đó.</p><blockquote><p>Ví dụ:</p><pre><code>  String s1 = “java”;  String s2 = “java”;  s1 == s2 //true</code></pre><p>Khi khai báo s1, JVM tìm kiếm trong pool và không thấy có ô nhớ nào có giá trị là “java” cả. JMV sẽ tạo mới 1 ô nhớ trong pool có giá trị là “java”.</p><p>Khi khai báo s2, JVM tìm kiếm trong pool và thấy có 1 ô nhớ có giá trị là “java” được JVM tạo ra trước đó khi khai báo s1. Vì thế JVM sẽ trỏ s2 vào ô chỉ nhớ vừa tìm được thay vì tạo ra 1 ô nhớ mới</p></blockquote><h3 id="b-Tao-String-moi-bang-new-operator">b. Tạo String mới bằng new operator</h3><p>JVM sẽ luôn tạo ra 1 ô nhớ mới trong Heap memory (dù đã tồn tại những ô nhớ có cùng giá trị)</p><blockquote><p>Ví dụ:</p><pre><code>  String s3 = new String(“java”);  String s4 = new String(“java”);  s3 == s4 //false</code></pre><p>Khi khai báo s3 hay s4, JVM luôn luôn tạo ra 2 ô nhớ khác nhau trong Heap memory để tham chiếu đến.</p></blockquote><h3 id="c-Chung-ta-nen-tao-moi-1-String-bang-cach-nao">c. Chúng ta nên tạo mới 1 String bằng cách nào?</h3><p>Chúng ta nên tạo mới một String bằng String literal vì chúng dễ đọc, ngắn gọn, tăng khả năng optimize của JVM. (mặc dù tạo bằng new operator sẽ nhanh hơn vì không phải kiểm tra trong String Pool)</p><h2 id="4-Vay-tai-sao-String-la-immutable">4. Vậy tại sao String là immutable?</h2><ul><li>Với một Object là immutable sẽ giúp thread safe và khi làm việc multi-threading. Chúng sẽ không bị thay đổi bởi các thread dùng chung object.</li><li>Các String được reference chung vào ô chỉ nhớ trong String Pool, nên nếu String là mutable sẽ dẫn đến sai giá trị của những biến khác đang được trỏ vào ô nhớ chung đó.</li><li>Để sử dụng Hashcode caching. Khi tạo một String thì JDK sẽ tự động override lại hashCode() theo giá trị của String đó và lưu chúng vào bộ nhớ đệm và sử dụng lại trong những lần sau khi nó phải tính toán với giá trị tương tự.hashCode() sẽ được sử dụng với các Map implementation như HashMap, HashTable, HashSet… để so sánh giá trị của Object.</li><li>Vấn đề về bảo mật. Khi String được sử dụng để lưu giá trị cho username, url, path… Khi các bước validate với String đó verified hợp lệnhưng sau đó String được thay đổi thì rất nguy hiểm.</li></ul><blockquote><pre><code>  boolean deleteProductBy(String ownername)&#123;  if (!isAdmin(ownername)) &#123;      throw new PermissionException();  &#125;      //ownername được thay đổi trước khi deleteAllProduct được gọi      deleteAllProduct(ownername)  &#125;</code></pre></blockquote><h2 id="5-Chu-y-voi-String-trong-Scala">5. Chú ý với String trong Scala</h2><ul><li>String trong Scala sẽ tương tứng với String trong Java</li><li>Khi so sánh 2 String trong Scala sẽ dùng phương thức <code>==</code>. Phương thức này sẽ tiến hành check <code>null</code> trước sau đó sẽ gọi <code>equals</code> để so sánh.<br>Chính vì thế khi so sánh 1 String <code>== null</code> trong Scala sẽ không bị <code>NullPointerException</code>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Scala </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English</title>
      <link href="/English/2017/07/04/english/"/>
      <url>/English/2017/07/04/english/</url>
      
        <content type="html"><![CDATA[<h2 id="I-Grammar">I. Grammar</h2><h3 id="1-Cac-thi">1. Các thì</h3><h3 id="2-Cau-so-sanh">2. Câu so sánh</h3><h3 id="3-Cau-bi-dong">3. Câu bị động</h3><h3 id="4-Cau-dieu-kien">4. Câu điều kiện</h3><h3 id="5-Menh-de">5. Mệnh đề</h3><h3 id="6-Cau-gia-dinh">6. Câu giả định</h3><h2 id="II-Vocabulary">II. Vocabulary</h2><ul><li>Reminder (n) Lời nhắc nhở<br/>Just a reminder that better seats will cost more</li><li>Once in a while: Đôi khi<br/>Once in a while we came to this coffee shop</li><li>get a ride: đi nhờ xe<br/> I get a ride with Jone, and he has a motorbike</li><li>Cubicle (n) gian làm việc<br/> she has the cubicle closest to the stairs</li><li>That would be convenient: Điều đó sẽ thuận tiện đấy!</li><li>Automotive part (n) Linh kiện oto<br/>Some automotive parts we ordered haven’t arrived.</li><li>dealership (n) đại lý<br/>He was a salesman at a Toyota dealership</li><li>contain (v) Bao gồm, chứa<br/>The email does not contain enough detailed information</li><li>Suppose<ul><li>Suppose that + clause: cho rằng/giả sử rằng/yêu cầu rằng<br/>I suppose that they will come back and accept our suggestion</li><li>Why do you suppose + clause: Tại sao bạn cho rằng<br/>Why do you suppose I will come to your birthday?</li><li>There is no reason to suppose + clause: Không có lý do gì để cho rằng<br/>There is no reason to suppose she is lying</li><li>Be supposed to do/be something: Đáng ra lên làm gì đó<br/>You were supposed to be here an hour ago.<br/>I were supposed to take the 2p.m from Denver to Seattle</li></ul></li><li>trade show (n) Triển lãm thương mại<br/>I’m presenting at a trade show</li><li>plenty (n) sự có nhiều, sung túc, dồi dào<br/>we are in plenty of time (chúng ta có nhiều thời gian)</li><li>exposure (n) Quảng cáo<br/>Her new film has had a lot of exposure on TV recently</li><li>free up something (v):<ul><li>làm cho SMT available để có thể sử dụng<br/>They will free up room for us soon</li><li>Dành tiền/thời gian cho việc khác<br/> I need to free up some time this weekend to finish the report</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
