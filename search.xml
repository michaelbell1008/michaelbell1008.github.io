<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vị giám đốc một phút</title>
      <link href="/Book/2021/08/10/vi-giam-doc-mot-phut/"/>
      <url>/Book/2021/08/10/vi-giam-doc-mot-phut/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/vi-giam-doc-mot-phut.png" alt="vi-giam-doc-mot-phut"></p><p>Có 2 yếu tố cần cho một người quản lý giỏi:</p><ul><li>Quan tâm đến chỉ tiêu đưa ra, những kế hoạch phải hoàn thành =&gt; được cấp trên tín nhiệm và cho rằng là giám đốc giỏi.</li><li>Tình cảm với nhân viên =&gt;được nhân viên ca tụng hết lời.</li></ul><p>=&gt; Khi dung hòa được 2 yếu tố trên vừa đảm bảo được lợi ích cho công ty vừa đảm bảo được quyền lợi cho nhân viên. Để làm được việc đó có thể áp dụng 3 bí quyết bên dưới.</p><h2 id="1-Bi-quyet-thu-nhat-Lap-muc-tieu-mot-phut-nen-tang-de-quan-ly-hieu-qua">1. Bí quyết thứ nhất: Lập mục tiêu một phút - nền tảng để quản lý hiệu quả</h2><p>Trong buổi họp hàng tuần cùng nhân viên, nghe nhân viên báo cáo công việc tuần vừa qua và cùng nhau phân tích, tháo gỡ những vướng mắc đang gặp phải. Sau đó sẽ lên mục tiêu cho tuần tiếp.</p><p>Lập mục tiêu một phút:</p><ul><li>Xác định mục tiêu. (mục tiêu cần rõ ràng, có thể thực hiện được và thể hiện qua những từ cân đong đó đếm được).</li><li>Xem xét giải pháp thích hợp nhất cho mục tiêu ấy.</li><li>Mô tả rõ từng mục tiêu trên mỗi trang giấy A4, tối đã 250 từ.</li><li>Kiểm tra kỹ từng mục tiêu để đảm bảo rằng việc chúng ta đọc chúng chỉ mất một phút.</li><li>Mỗi ngày dành một phú để đánh giá thành quả công việc của mình.</li><li>Kiểm tra kết quả những việc mình làm có phù hợp với mục tiêu đã đề ra hay không?</li></ul><p>Lợi ích:</p><ul><li>Mong muốn đầu tiên của mọi người là phản hồi kết quả công việc. Nhờ mục tiêu một phút, mọi người thường xuyên xem xét mục tiêu của họ, đồng thời có thể tự kiểm tra xem việc thực thi công việc của họcó bám sát với mục tiêu đã đặt ra hay không?</li><li>Khi cảm thấy hài lòng về bản thân, mọi người sẽ làm việc hiệu quả hơn gấp bội. Việc đạt được mục tiêu đó, sẽ giúp nhân viên sẽ cảm thấy vui sướng và hài lòng.</li></ul><h2 id="2-Bi-quyet-thu-hai-Mot-phut-khen-ngoi">2. Bí quyết thứ hai: Một phút khen ngợi</h2><p>Thường chỉ cần khen ngợi những khi nhân viên mới khi họ làm đúng hoặc gần đúng. Còn những nhân viên đã quen với môi trường và công việc thì có thể ít hơn. Vìkhi đó hãy để họ tự khen ngợi mình khi họ làm tốt. Hơn nữa khi đã quen việc thì có rất nhiều cách để quản lý độ hiệu quả của nhân viên. Trình tự để khen ngợi hiệu quả:</p><ul><li>Ngay từ lúc ban đầu, hãy cho nhân viên biết bạn sẽ để ý đến việc làm của họ.</li><li>Khen tặng họ ngay khi họ làm đúng.</li><li>Nói cho họ biết họ đã làm đúng điều gì, nêu chính xác lý do mà bạn ngợi khen họ.</li><li>Cho họ biết bạn cảm thấy vui thế nào khi họ làm đúng và việc làm đó có tác động như thế nào đối với công ty và những đồng nghiệp khác.</li><li>Dừng lại một lát để họ cảm nhận được cảm giác vui vẻ cảu bạn.</li><li>Khích lệ họ tiếp tục làm tốt như vậy.</li><li>Nên bắt tay hoặc vỗ vai để cho nhân viên của bạn thấy rằng bạn luôn ủng hộ họ thành công. (Cần thiết để tỏ sự thân thiện, quan tâm)</li></ul><h2 id="3-Bi-quyet-thu-ba-Mot-phut-khien-trach">3. Bí quyết thứ ba: Một phút khiển trách</h2><p>Để một phút khiển trách có tác dụng:</p><ol><li><p>Nói trước với nhân viên rằng dứt khoát bạn sẽ khiển trách họ khi họ phạm lỗi.</p></li><li><p>Khi nhân viên phạm lỗi, bạn thực hiện một phút khiển trách:Phần một:</p><ul><li>Khiển trách hành vi của họ ngay lập tức.</li><li>Nói rõ họ đã làm sai điều gì.</li><li>Nói cho họ biết cảm giác của bạn bằng thái độ dứt khoát.</li><li>Ngưng một vài giây, giữ im lặng cho họ cảm nhận được những gì bạn nói.Phần hai:</li><li>Nên bắt tay hoặc vỗ vai để người nhân viên hiểu bạn thực sự đứng về phía bạn.</li><li>Nhắc cho họ biết bạn đánh giá bản thân họ rất cao.</li><li>Nhưng riêng trong trường hợp vừa rồi bạn không tán thành hành vi của họ.</li></ul></li><li><p>Khi khiển trách xong ta sẽ không nhắc lại lỗi cũ của nhân viên.</p></li></ol><p>Lợi ích:</p><ul><li>Nhân viên có thể “nghe” được phản hồi từ Sếp đúng lúc.</li><li><code>Khiển trách một hành vi sai</code> của nhân viên (không được khiển trách cả con người), thì sẽ dễ dàng nói rõ cảm xúc và có thái độ công bình hơn đối với nhân viên.</li></ul><blockquote><p>Nếu ngay từ ban đầu, quản lý tỏ ra nghiêm khắc với từng hành vi của nhân viên, rồi sao đó lại tỏ ra ủng hộ bản thân họ, thì sẽ quản lý họ được hiệu quả hơn.</p></blockquote><h2 id="4-Note">4. Note:</h2><blockquote><p>Bản chất của kiến thức suy cho cùng chính là biết cách áp dụng chúng vào trong thực tiễn cuộc sống</p><p>— Khổng tử. —</p><p>Anh không muốn nghe chú than phiền mà chỉ muốn chú diễn tả một cách cụ thể, rõ ràng điều gì đã xảy ra, bằng những từ cân đong đo đếm được.Nếu chú không xác định được bản thân mình mong muốn sự việc xảy ra như thế nòa thì rõ ràng chú chưa gặp khó khăn thật sự mà chỉ đang than thở thôi.Khó khăn chỉ tồn tại thực sự khi những gì xảy ra trong thực tế khác với những gì ta mong đợi.</p><p>Mục tiêu ĐỊNH HƯỚNG hành động</p><p>Kết quả CHỨNG MINH hành động</p></blockquote><ul><li><p>Không bao giờ quyết định thay cho người khác, chỉ hướng họ tự tìm ra con đường đến đích.</p></li><li><p>Khi tuyển dụng chỉ chọn 2 loại người:</p><ul><li>Tuyển những người giỏi, nhưng sẽ khó kiếm và phải trả họ lương cao.</li><li>Tuyển những người có tiềm năng, sau đó sẽ đào tạo họ trở lên giỏi.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
            <tag> Vi giam doc mot phut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sức mạnh sự mơ hồ và bí ẩn</title>
      <link href="/Book/2021/08/09/suc-manh-su-mo-ho-va-bi-an/"/>
      <url>/Book/2021/08/09/suc-manh-su-mo-ho-va-bi-an/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/suc-manh-cua-su-mo-ho.jpeg" alt="suc-manh-cua-su-mo-ho"></p><h1>1. Bạn có thích cuốn sách? Tại sao?</h1><p>Bình thường.</p><p>Không thích cách viết của sách: văn phong, từ ngữ dễ gây hiểu nhầm. Dẫn chứng dựa nhiều trên cơ sở lý thuyết</p><h1>2. Bạn mong đợi điều gì ở cuốn sách?</h1><p>Thực dụng hơn, nhiều case study hơn, rõ ràng hơn nữa. nhưng nhớ lại tên cuốn sách là sức mạnh của sự mơ hồ và bí ẩn.</p><h1>3. Mô tả tóm tắt những nội dung chính của cuốn sách.</h1><p>Trong cuộc sống luôn gặp những sự mơ hồ, bí ẩn. Khi đối mặt với chúng con người thường có nhu cầu kết thúc chúng thật nhanh để hướng chúng đến những sự rõ ràng, nhất quán. Con người có 2 cách đối mặt với chúng: 1 là chấp nhận sự mơ hồ thay đổi tư duy hiểu biết của mình, 2 là hờ hững và bỏ qua nó (mặc dù bản thân đã nhận ra sự sai sót đó). Khi môi trường tác động, bị áp lực ví dụ thời gian kết thúc vấn đề thường chúng ta sẽ đưa ra những kết luận theo hướng mà chúng ra mong muốn dù cho những thông tin có được đang đi ngược lại với những điều chúng ta tin. mục đích chỉ là thoát khỏi sự mơ hồ. từ đó những quyết định thường không chính xác. Nhưng nếu không bị chịu về áp lực thì quyết định sẽ chính xác hơn, sáng tạo hơn.</p><p>Tiền nhân từ trước đến này đã dạy: “mọi chuyện cần suy nghĩ, tính toán chín chắn trước khi quyết định”. Quyển sách này như một phần nhắc nhở lại với bản thân. Khi phải đưa ra quyết định hãy luôn đặt thật nhiều câu hỏi, tìm kiếm sự tương đồng để tìm ra giải pháp, nghĩ nó 1 cách thấu đáo nhất và đặc biệt hãy giữ bản thân thật thoải mái và nếu còn vướng bận thì hãy chờ đợi, không nên quyết định bừa.</p><h1>4. Một vài ý thích</h1><ul><li>Chúng ta có thể nhận thức được tương lai bất định bằng cách xây dựng phương pháp phản ứng nhanh trước thay đổi, chứ k phải cố gắng dự đoán. Dưới những điều kiện đúng, sự mơ hồ có thể mang lại cơ hội cách tân, truyền cảm hứng sáng tạo…</li><li>Trong một nhóm khi bắt buộc phải giải quyết 1 vấn đề mơ hồ mà phải chịu áp lực về thời gian, người ta thường có xu hướng tôn sùng một người độc tài ra quyết định nhanh gọn hơn. Hay cũng trong trường hợp đó nếu một người đưa ra ý kiến trái ngược lại đa số nhóm thì ý kiến đó mặc dù hay cũng thường sẽ bị phớt lơ, và xem thường.</li><li>Thất bại buộc chúng ta tái thẩm định lại những niềm tin vững chắc đã cũ kỹ khi mọi thứ không diễn ra theo kế hoạch. Nó đòi hỏi chúng ta nghi ngờ những nguyên nhân mà chúng ta cho rằng mình đã hiểu rõ</li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
            <tag> Jamies Holmes </tag>
            
            <tag> Suc manh cua su mo ho va bi an </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phi Lý Trí</title>
      <link href="/Book/2021/04/06/phi-ly-tri/"/>
      <url>/Book/2021/04/06/phi-ly-tri/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/phi-ly-tri/phi-ly-tri-cover.jpeg" alt="phi-ly-tri-cover.jpeg"></p><h2 id="Khai-quat">Khái quát</h2><ul><li>Chúng ta đôi khi phi lý trí hơn chúng ta tưởng, thậm chí là thường xuyên phi lý trí và phi lý trí có hệ thống (được lặp đi lặp lại) và có thể dự đoán trước.</li><li>Cuốn sách giúp người đọc phải suy nghĩ kỹ hơn về những hành vi, sai lầm của mình để sống hợp lý và tốt đẹp hơn.</li></ul><h2 id="Chuong-1-Su-that-ve-tinh-tuong-doi">Chương 1: Sự thật về tính tương đối.</h2><ul><li><p>MỌI THỨ ĐỀU CÓ TÍNH TƯƠNG ĐỐI.</p></li><li><p>Theo kinh tế học thì con người luôn luôn tìm ra những thứ, những cách có giá trị tốt nhất để thực hiện. Tuy nhiên kinh tế học hành vi lại cho rằng con người vẫn luôn có những hành động phi lý trí theo bản năng.</p></li><li><p>Con người ít khi đưa ra lựa chọn cái gì đó (cả vật hữu hình hay những thứ vô hình như trải nghiệm, tình cảm, thái độ, quan điểm…) theo một tiêu chuẩn tuyệt đối.Chúng ta không biết mọi thứ có giá trị là bao nhiêu. Thay vào đó chúng ta tập trung vào ưu thế tương đối của vật này so với vật kia và ước tính giá trị của nó.Tuy nhiên chúng ta lại tập trung vào so sánh những thứ có thể dễ dàng so sánh và luôn tránh so sánh những thứ không dễ so sánh.</p></li><li><p>Lựa chọn nền (Vật làm nền) là lựa chọn được đưa thêm vào để nhằm mục đích làm nổi bật lựa chọn mà muốn focus. Chúng gần giống với lựa chọn focus nhưng sẽkém hơn một vài điểm mà <code>RẤT DỄ</code> so sánh. Từ đó lựa chọn focus tạo cảm giác sẽ là lựa chọn tốt nhất trong tất cả các lựa chọn.</p></li></ul><p><img src="/images/phi-ly-tri/compare-attribute.png" alt="compare-attribute.png"></p><blockquote><p>thuộc tính -A được thêm vào để làm nổi bật A để gọi ý chọn nó: A không chỉ tốt hơn -A mà còn tốt hơn cả B.</p></blockquote><ul><li>Đứng trước 3 lựa chọn, hầu hết mọi người sẽ chọn phương án trung gian. (tivi có giá: $690 , <code>$850</code>, $1480)</li><li>Các món ăn có đơn giá cao hơn trên thực đơn sẽ giúp tăng doanh thu cho nhà hàng ngay cả khi không khách hàng nào lựa chọn món đó cả.Bằng cách tạo ra món ăn đắt tiền nhất, chủ nhà hàng có thể lôi kéo thực khách đặt món ăn đắt thứ hai.</li></ul><h2 id="Chuong-2-Quan-diem-sai-giua-cung-va-cau">Chương 2: Quan điểm sai giữa cung và cầu</h2><ul><li><p>Để khiến một người thèm thuồng thứ gì đó, chỉ cần làm cho việc đó trở lên khó khăn</p></li><li><p>Hiện tượng khắc sâu. Con người có sẽ khắc sâu với những ấn tượng và quyết định ban đầu.</p></li><li><p>Mỏ neo. Chỉ khi chúng ta bắt đầu đưa ra quyết định muốn mua 1 sản phầm với giá X thì lúc đó X sẽ trở thành mỏ neo. Chiếc mỏ neo đầu tiên không chỉ hướng tới quyết định mua ngay lúc đó mà còntới nhiều quyết định theo sao khác. Nó sẽ có tác dụng lâu dài đối với giá hiện tại và trong tương lai. Vì thế chúng ta nên đặc biệt chú ý cân nhắc đến những quyết định đầu tiên này.</p></li><li><p>Những người chuyển tới một thành phố mới đều giữ mức chi trả cho nhà ở như ở thành phố cũ.</p></li><li><p>Hành vi bày đàn xảy ra khi chúng ta cho rằng một điều gì đó là tốt (hoặc xấu) căn cứ vào hành vi trước của người khác và chúng ta sẽ hành động theo sau cho phù hợp.Nhưng cũng có một hành vi bày đàn khác là tự bày đàn. Nó xảy ra khi chúng ra cho rằng một điều gì đó tốt (hoặc xấu) căn cứ vào hành vi trước đây của chính mình (ví dụ như lần đầu đi ăn ởmột quán nào đó bạn thấy ngon, thì những lần sau bạn sẽ lại quay lại sử dụng quán ăn đó)</p></li><li><p>Chúng ta có thể cải thiện tích cực các hành vi phi lý trí của mình bằng việc chất vấn các thói quen hàng ngày (kiểm tra lại những mỏ neo của mình). Nó bắt đầu thế nào? Nó có dễ chịu nếu từ bỏ thói quen đó? Trên thực tế bạn nênđặt câu hỏi cho các hành vi lặp đi lặp lại của mình. Chọn điện thoại có nhất thiết là phải đẹp không? cà phê hay trang phục có nhất thiết phải là loại đắt tiền không? Trước kia nó có thể dãrất đúng nhưng hiện tại thì sao?</p></li><li><p>Mức độ hài lòng về lương của nhân viên dựa vào sự so sánh với lương của những người họ biết hay liên quan.</p></li></ul><h2 id="Chuong-3-Cai-gia-cua-mien-phi">Chương 3: Cái giá của miễn phí</h2><ul><li>Khi có được một món đồ miễn phí chúng ta thường thấy rất phấn khởi. Nhưng giá 0 đồng còn là một cảm xúc nóng - một nguồn kích thích phi lý trí.</li><li>Bản chất con người sợ mất mát, mà hàng miễn phí thì sẽ không bị mất gì. Vì thế hàng miễn phí luôn cho ta cảm giác nó có giá trị hơn rất nhiều so với giá trị thực của nó.</li><li>Khái niệm con số 0 còn áp dụng cho thời gian. Thời gian dành cho một hoạt động, bản chất cũng là lấy từ một hoạt động khác. Nếu dành nhiều thời gian để lấy được các hàng miễn phí nhưngkhông có quá nhiều giá trị với bản thân thì thực sự là không đáng.</li></ul><h2 id="Chuong-4-Cai-gia-cua-cac-quy-chuan-xa-hoi">Chương 4: Cái giá của các quy chuẩn xã hội</h2><ul><li>Chúng ta đồng thời sống trong hai thế giới khác nhau: một với các quy chuẩn xã hội chiếm ưu thế và một với quy chuẩn thị trường tạo ra quy tắc.</li><li>Khi chúng ta đặt quy chuẩn xã hội và quy chuẩn thị trường trên hai con đường riêng biệt, cuộc sống trở lên tốt đẹp hơn.</li><li>Khi các quy chuẩn xã hội và thị trường va chạm nhau, thì vấn đề sẽ nảy sinh.</li><li>Đúng với quy chuẩn thị trường, những người nhận tiền cao hơn trung bình sẽ làm việc tốt hơn. Nhưng những người làm việc với tiêu chuẩn xã hội (làm giúp…) thì kết quả của họ tốt hơn tất thảy.</li><li>Văn phòng luật sư sẽ không đồng ý giảm giá cho những người nghỉ hưu gặp khó khăn, nhưng lại sẵn sàng giúp đỡ họ một cách miễn phí.</li><li>Một khi các quy chuẩn thị trường được thâm nhập vào sự cân nhắc của chúng ta, các quy chuẩn xã hội sẽ tự động không còn chỗ đứng. Nó sẽ làm tổn thương các mối quan hệ,và khi đó sẽ rất khó để khôi phục lại mối quan hệ xã hội đó. Để làm nổi bật quy chuẩn thị trường, chỉ cần đề cập đến tiền là đủ (ngay cả khi tiền không được trao tay).</li><li>Thực tế những người làm việc dưới đặc điểm thị trường: ích kỷ và tự lực hơn. Họ muốn dành thời gian một mình nhiều hơn, họ có xu hướng chọn những bải tập đòi hỏi nguồn lực cá nhân hơn là đồng đội. và khi đang phảiquyết định chọn chỗ ngồi, họ sẽ chọn những chỗ ngồi cách xa khỏi người được yêu cầu làm việc cùng.</li><li>Khi áp dụng mức phạt cho các phụ huynh đón con muộn sẽ càng khiến cho việc đón muộn càng trở lên phổ biến hơn. Vì khi đó quy chuẩn xã hội (đón con muộn sẽ ngại với các giáo viên) đã chuyển sangquy chuẩn thị trường (bị phạt tiền - họ nghĩ đã trả tiền cho sự chậm trễ nên sẽ không cần phải khẩn trương đến đón con). Và tệ hơn nữa khi nhà trường bỏ việc phạt tiền thì việc đón muộn còn tănglên nữa.</li><li>Quy chuẩn xã hội là cách tốt nhất để khiến nhân viên trung thành và hăng say làm việc.</li><li>Trong việc đối xử với các nhân viên của mình, các công ty phải hiểu cam kết dài hạn có ý nghĩa thế nào. Nếu các nhân viên hứa hẹn sẽ làm việc chăm chỉ hơn đểđảm bảo tiến độ (thậm chí hủy bỏ việc gia đình cho mục tiêu đó),… thì đáp lại, họ cũng phải nhận được sự giúp đỡ khi ốm đau, hoặc cơ hội giữ được công việccủa mình khi thị trường đe dọa lấy mất công việc của họ</li><li>Tặng quà cho nhân viên sẽ đem lại nhiều lợi ích (làm việc chăm chỉ hơn, trung thành với công ty hơn…) hơn việc tặng tiền. Dù việc tặng tiền được nhiều người thích hơn.</li><li>Dùng tiền thưởng là cách “đắt” nhất để khuyến khích mọi người. Các quy chuẩn xã hội không chỉ “rẻ” hơn mà còn hiệu quả hơn rất nhiều.</li><li>Không ai thấy bị xúc phạm vì món quà nhỏ, vì ngay cả món quà nhỏ cũng giữ chúng ta tránh khỏi các quy chuẩn thị trường</li><li>Mọi người thường làm việc vì một lý do nào đó hơn là vì tiền bạc. Chúng ta đều biết, chỉ vì đồng lương sẽ không thể tạo ra được động lực cho mọi người mạo hiểm cuộc sống,mà chính vì những tự hào nghề nghiệp, nâng cao xứ mệnh, ý thức trách nhiệm… Đây cũng chính là điểm trên cùng của tháp maslow</li></ul><h2 id="Chuong-5-Anh-huong-cua-su-hung-phan">Chương 5: Ảnh hưởng của sự hưng phấn.</h2><ul><li>Bình thường chúng ta tưởng là đã hiểu được chính mình. Nhưng trong trạng thái phấn khích mãnh liệt, bỗng nhiên có một sự chuyển đổi nội tại nào đó và mọi thứ thay đổi.</li><li>Chúng ta phải thận trọng với những tình huống mà ngày Hyde bên trong chúng ra kiểm soát. Khi sếp phê bình chúng ta trước mặt mọi người, có thể chúng ta sẽ đáp trả lại bằng một email với nhữnglời lẽ phản bác kịch liệt. Liệu sẽ tốt hơn chăng nếu chúng ta lưu bức thư đó vào mục thư nháp vài ngày?</li><li>Tránh khỏi sự cám dỗ sẽ dễ dàng hơn là vượt qua nó.</li><li>Không tồn tại con người nhất thể. Thực tế, chúng ta là tổng thể của rất nhiều cái tôi. Cần nhận thức được rằng chúng ta có nguy cơ đưa ra quyết định sai khi bị kiểm soát hoàn toàn bởicảm giác mãnh liệt có thể giúp chúng ta.</li></ul><h2 id="Chuong-6-Van-de-cua-su-tri-hoan-va-tu-kiem-soat">Chương 6: Vấn để của sự trì hoãn và tự kiểm soát.</h2><ul><li>Ở trạng thái bình thường ta nghĩ sẽ giảm cân, dành 5h mỗi ngày để học tập, nhưng đến khi phải thực hiện, sự thích thú của ngủ, facebook… khiến ngài Hyde thức dậy. và chúng ta trì hoãn.</li><li>Việc hạn chế nghiêm ngặt quyền tự do bản thân là phương pháp tốt để chữa trị bệnh trì hoãn. Nhưng nếu chỉ cần trao cho mọi người một công cụ để họ có thể cam kết trước các thời hạn sẽ giúp đạt được kết quả tốt hơn.</li><li>Tại sao chúng ta liên tục thất bại trong việc đạt được các mục tiêu lâu dài của mình. Lý do là, không có các cam kết từ trước.</li></ul><blockquote><p>Cách tốt nhất để tránh việc trì hoãn bản thân là hãy cho mọi người cơ hội cam kết hành động của mình (cơ chế cam kết trước: chuyển tiền tiết kiệm ngay khi nhận lương,trả tiền trước khi thi chứng chỉ…). Cách này có thể không hiệu quả bằng cách làm độc đoán áp đặt nhưng nó giúp chúng ta đi đúng hướng</p></blockquote><h2 id="Chuong-7-Cai-gia-cua-su-so-huu">Chương 7: Cái giá của sự sở hữu</h2><ul><li>Hiệu ứng hàng đã có. Khi chúng ta sở hữu một thứ gì đó thì chúng ta luôn coi trọng giá trị của nó hơn những người khác. (Có liên quan đến việc khi mất đi một thứ gì đó ta thường xót hơn những ng ngoài. Vìcon người luôn lo sợ sự mất mát.)</li><li>Phần lớn cuộc đời chúng ta là dành cho việc sở hữu, nhưng đa phần chúng ta làm việc này rất kém vì:<ul><li>Chúng ta thướng yêu quý những gì chúng ta có.</li><li>Chúng ta tập trung vào những gỉ chúng ta có thể mất hơn là chúng ta có thể có.</li><li>Chúng ta cho rằng người khác sẽ nhìn nhận sự giao dịch đó từ góc độ của chúng ta.</li></ul></li><li>Sở hữu cũng có các đặc tính:<ul><li>Bạn càng bỏ nhiều công sức cho một việc gì đó, bạn càng cảm thấy sự sở hữu dành cho nó tăng lên. (Hiệu ứng Ikea)</li><li>Chúng ta có thể ảo tưởng về quyền sở hữu ngay cả trước khi chúng ta sở hữu một cái gì đó.</li><li>Không giới hạn ở việc sở hưu đồ vật, nó cũng đúng với các quan điểm.</li></ul></li></ul><blockquote><p>Cách giải quyết sự sở hữu là nhìn nhận các giao dịch (đặc biệt là giao dịch lớn) như thể mình không phải là người sở hữu chúng, đặt ra một khoảng cách nhất định giữa bản thân và món đồ đang quan tâm</p></blockquote><h2 id="Chuong-8-Luon-de-ngo-cac-lua-chon">Chương 8: Luôn để ngỏ các lựa chọn</h2><ul><li>Chúng ta rất sợ cảm giác mất mát, và chúng ta thường làm bất cứ điều gì để cứu vớt tình hình.</li><li>Con người luôn lo lắng không phải bởi vì họ thiếu cơ hội mà là vì họ có quá nhiều cơ hội.</li><li>Chúng ta luôn mong muốn biết nhiều, biết rộng. Nhưng khi nảy sinh ra vấn đề liệu sự trải nghiệm của chúng ta có quá mỏng manh không?</li><li>Lạ lùng hơn chúng ra còn ham muốn theo đuổi những cánh cửa mà không mang lại cho chúng ta lợi ích gì.</li></ul><blockquote><p>Thật ngốc nghếch nếu chúng ta cứ chạy loạn xạ để ngăn tất cả các cánh cửa không bị đóng lại. Điều mà ta cần làm là chủ động đóng lại một số cánh cửa. Nhưng khi các cánh cửa tương đương nhau,chúng ta phân vân không biết nên chọn cánh cửa nào, thì điều tiếp theo chúng ta phải làm là quyết định thật nhanh cánh cửa nào ta sẽ đi tiếp, vì hậu quả của việc không quyết định (quyết định chậm) có thểsẽ là rất lớn</p></blockquote><h2 id="Chuong-9-Hieu-ung-cua-su-mong-doi">Chương 9: Hiệu ứng của sự mong đợi</h2><ul><li>Tại sao chúng ta lại cảm nhận theo những gì chúng ta cảm nhận. Khi chúng ta tin rằng một cái gì đó tốt thì nó sẽ tốt và khi chúng ta nghĩ nó tệ thì nó sẽ tệ.</li><li>Cùng một tình huống bóng trên vạch vôi. Nhưng luôn có 2 ý kiến trái chiều nhau giữa những cổ động viên 2 bênkhông bao giờ biết rằng trong loại bia mà họ uống có pha thêm giấm thơm.</li><li>Nếu được đọc bản miêu tả món ăn, thực khách sẽ rất thích thú món đó.</li><li>Những thứ làm nổi bật thương hiệu (ví dụ màu đỏ của coca…) tốt thường làm chúng ta thích những sản phẩm của họ hơn.</li><li>Nếu sản phẩm của bạn không có gì đặc biệt, hãy bán cái vỏ của nó.</li><li>Hành vi của chúng ta cũng có thể bị ảnh hưởng với các định kiến của chính mình, sự kích hoạt các định kiến phụ thuộc vào tình trạng tinh thần hiện tại và cách chúng ta nhìn nhận bản thân mình vàothời điểm đó. (Ví dụ: định kiến về người châu Á giỏi toán hơn =&gt; thì quốc tế sẽ tự tin hơn).</li><li>Việc nếm thử bia mà không biết gì về giấm thơm hoặc biết sau khi đã thử bia, sẽ giúp người thử cảm nhận được hương vị thật. Những người đó cũng thích nó hơn những người biết trước có giấm thơm trong bia(vì họ luôn muốn loại bia chuẩn, nhưng khi biết bia có giấm thơm họ nghĩ họ sẽ không thích)</li></ul><blockquote><p>Áp dụng khi tranh cãi: Quan điểm mỗi bên được trình bày mà không đưa ra quyết định cuối cùng là mình thuộc phe nào. Nó sẽ giúp nhận ra sự thật tốt hơn.</p></blockquote><h2 id="Chuong-10-Suc-manh-cua-gia-ca">Chương 10: Sức mạnh cùa giá cả.</h2><ul><li>Sự thật, giả dược hoạt động bằng sức mạnh của niềm tin, Chúng hiệu quả vì người ta tin tưởng chúng.</li><li>Sự quen thuộc chắc chắn tạo ra sự mong đợi</li><li>Những sản phẩm motivate (thuốc, thực phẩm chức năng, nước tăng lực…) có giá cao sẽ có tác dụng trấn an tốt hơn nếu nó có giá thấp.</li></ul><h2 id="Chuong-11-12-Tac-dong-cua-boi-canh-den-tinh-cach">Chương 11 + 12: Tác động của bối cảnh đến tính cách</h2><ul><li>Có hai kiểu không trung thực:<ul><li>Những kẻ trộm cắp, cướp bóc</li><li>Những người nghĩ mình là trung thực (Những người lấy những thứ nhỏ nhặt, khai tăng giá tiền của chiếc xe bị mất…)</li></ul></li><li>Khi có cơ hội, nhiều người “trung thực” sẽ gian lận. Nhưng họ sẽ không gian lận quá mức, và lạ thay, họ lại không nhìn thấy họ đang gian lận.</li><li>Gian lận sẽ dễ dàng hơn rất nhiều nếu nó không trực tiếp dính dáng đến tiền</li></ul><blockquote><p>Khi nghĩ về sự trung thực thì chúng ta sẽ ngừng hành vi gian lận ngay lập tức. Nên việc suy tưởng về một chuẩn mực dạo đức nào đó sẽ khuyến khích tính trung thực (10 điều răn của Chúa, lời tuyên thệ, đạo đức nghề nghiệp…)</p></blockquote><h2 id="Chuong-13-Bia-va-nhung-bua-an-mien-phi">Chương 13: Bia và những bữa ăn miễn phí</h2><ul><li>Khi gọi theo thứ tự (công khai) những người trong cùng một bàn sẽ gọi nhiều loại bia hơn - về bản chất là chọn sao cho phong phú. Có thể những loại đó họ không thực sự thích nhưng để thể hiệncá tính khác biệt của bản thân thì họ vẫn sẵn sàng.</li><li>Nên là người gọi đầu tiên, hoặc chọn anonymous…</li></ul><blockquote><p>Nếu tất cả chúng ta đều mắc lỗi có hệ thống trong các quyết định của mình thì tại sao không phát triển các chiến lược, công cụ và phương pháp giúp chúng ta đưa ra các quyết định sáng suốt hơn.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
            <tag> Dan Ariely </tag>
            
            <tag> Phi ly tri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memory Java</title>
      <link href="/Technology/Java/Scala/2020/12/12/java-memory-model/"/>
      <url>/Technology/Java/Scala/2020/12/12/java-memory-model/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java-Memory-model-co-nhung-gi">1. Java Memory model có những gì?</h2><p><img src="/images/java-memory/jvm-memory.png" alt="jvm-memory"></p><p>Java Memory model gồm 2 phần chính: các thread Stack và Heap.</p><ul><li>Mỗi thread chạy trong máy ảo JVM sẽ có 1 bộ nhớ thread Stack riêng và các thread khác nhau không thể truy cập giá trị thread stack của nhau.</li><li>Các thread stack này chứa thông tin về những method mà thread cần gọi và local variables của từng method đang thực thi. Mỗi thread stack sẽ có một bản clone local variables của method đó.</li><li>Bộ nhớ Heap thì chứa tất cả các Object được tạo trong chương trình. Mọi thread có thể dùng chung dữ liệu lưu trong Heap.</li><li>Sau khi các method kết thúc, các giá trị lưu trong thread stack sẽ được xóa, nhưng data trong Heap thì vẫn còn. Nó sẽ được GC dọn sau.</li><li>Nếu local variable là kiểu primitive =&gt; biến sẽ lưu trong thread stack.</li><li>Nếu trong Object có nhiều method và trong method có các biến local. thì các biến local đó cũng được lưu trong Thread stack.</li><li>Nếu local variable tham chiếu đến một Object =&gt; tham chiếu được lưu trong thread Stack, giá trị Object được lưu trong Heap</li><li>Các attributes của Object sẽ luôn luôn được lưu cùng Object đó trong Heap mà không cần quan tâm đến type of attribute.</li></ul><p><img src="/images/java-memory/jvm-memory-mapping.png" alt="jvm-memory-mapping"></p><p><strong>Giải thích diagram</strong></p><ul><li><code>local variable 1</code> ở cả 2 thread stack là biến primitive.</li><li><code>local variable 2</code> ở cả 2 thread stack đều tham chiếu đến <strong>Object 3</strong> được lưu trong Heap. <strong>Object 3</strong> lại có 2 biến local có giá trị là <strong>Object 2</strong> và <strong>Object 4</strong></li><li><code>local variable 1</code> ở methodTwo() trong 2 thread stack tham chiếu đến hai Object khác nhau lưu trong Heap là <strong>Object 1</strong> và <strong>Object 5</strong></li></ul><blockquote><pre><code>public class MyRunnable implements Runnable() &#123;  public void run() &#123;    methodOne();  &#125;  public void methodOne() &#123;    int localVariable1 = 45;    MySharedObject localVariable2 = MySharedObject.sharedInstance;    //... do more with local variables.    methodTwo();  &#125;  public void methodTwo() &#123;    //Mỗi thread sẽ tạo mới Object và lưu trong Heap.    Integer localVariable1 = new Integer(99);     //... do more with local variable.  &#125;&#125;public class MySharedObject &#123;  //Do được định nghĩa là static nên chỉ có duy nhất một instant được tạo ra và lưu trong Heap  public static final MySharedObject sharedInstance = new MySharedObject();  public Integer object2 = new Integer(22);  public Integer object4 = new Integer(44);  // Mặc dù member1 và member2 có kiểu là primitive nhưng vì nó là attribute của Object,  // nên nó vẫn được lưu vào trong Heap cùng với Object cha.  // chỉ có local variables như localVariable1 mới được lưu trong thread Stack.  public long member1 = 12345;  public long member2 = 67890;&#125;</code></pre></blockquote><h2 id="2-Cau-truc-bo-nho-phan-cung">2. Cấu trúc bộ nhớ phần cứng</h2><p><img src="/images/java-memory/hardware.png" alt="hardware"></p><ul><li>Một máy tính ngày nay thường có nhiều hơn 2 CPU. Mỗi CPU thường sẽ có 2 thread.</li><li>Mỗi CPU sẽ có một vài các thanh ghi để làm bộ nhớ trong của CPU. Tốc độ đọc ghi trên các thanh ghi này là cực kỳ nhanh. Nhanh hơn rất nhiều so với đọc trên RAM.</li><li>Mỗi CPU có thể sẽ có thêm 1 bộ nhớ cache, nhưng kích thước thường không được lớn lắm. Tốc độ đọc trên Cache cũng không nhanh bằng trên thanh ghi, nhưng vẫn là rất nhanh so với RAM.</li><li>Việc lưu trữ, trao đổi data sẽ được chuyển qua lại giữa các bộ nhớ CPU Registers, CPU Cache Memory, RAM. CPU sẽ load một phần data trong RAM vào Cache. và cũng có thể sẽ load một phầndata từ Cache vào CPU Registers để thực hiện các tính toán.</li><li>Khi cần lưu data lại vào RAM thì CPU sẽ truyền data từ CPU Registers ngược lại cho Cache. Nhưng Cache sẽ không truyền ngay data về RAM,mà sẽ chờ đến khi CPU cần phải lưu những thứ khác trong Cache thì khi đó nó sẽ gửi data xuống RAM.</li></ul><h2 id="3-Bo-nho-phan-cung-tuong-tac-voi-JVM-memory">3. Bộ nhớ phần cứng tương tác với JVM memory</h2><p><img src="/images/java-memory/hardware-mapping-jvm.png" alt="hardware-mapping-jvm"></p><p>Cấu trúc bộ nhớ của JVM và máy tính là khác nhau. Các data của Thread stack, Heap đều có thể được lưu mooth phần trong CPU Registers, CPU Cache Memory, RAM. Vì thế có 2 vấn đề thường gặp:</p><ul><li>Visibility of thread updates (writes) to shared variables.</li><li>Race conditions</li></ul><p>Xét ví dụ sau đây để làm rõ</p><p><img src="/images/java-memory/visibility-shared-object.png" alt="visibility-shared-object"></p><ul><li>Biến <strong>count</strong> trong RAM có giá trị là 1.</li><li>CPU A và CPU B load <strong>count</strong> lên Cache của chúng.</li><li>CPU A tăng giá trị count của thêm 1 để count trong Cache của CPU A là 2. nhưng vì Cache chưa gửi về RAM nên count trong RAM vẫn là 1.</li></ul><blockquote><p>Chú ý: Nếu muốn CPU A update lại <strong>count</strong> vào RAM ngay sau khi thay đổi <strong>count</strong> và các thread khác luôn luôn đọc biến <strong>count</strong> trực tiếp từ RAM thìchúng ta có thể khai báo biến với từ khóa <code>volatile</code>. Ví dụ:</p><pre><code>public volatile int count = 1;</code></pre><p>Tuy nhiên dùng <strong>volatile</strong> cũng chưa đủ an toàn. Vì khi CPU A đang tính toán và chuẩn bị update <strong>count</strong> = 2 về RAM thì CPU B đã load giá trị của <strong>count</strong> = 1 nên Cache. Khi đó vẫn làm sai lệchdữ liệu.</p></blockquote><ul><li>Lúc này Cache của CPU B count vẫn có giá trị là 1 vì thread của CPU B không thể truy cập được Cache của CPU A</li><li>CPU B tăng giá trị count của thêm 1 để count trong Cache của CPU A là 2. nhưng vì Cache chưa gửi về RAM nên count trong RAM vẫn là 1.</li></ul><blockquote><p>Chú ý:Khi có <strong>ÍT NHẤT 2 THREAD</strong> (thread trên CPU A và CPU B) muốn thay đổi giá trị của shared object (<strong>count</strong>) thì có thể sẽ xảy ra <strong>race conditon</strong>.<strong>Thread safe</strong> là không có <strong>race condition</strong></p></blockquote><p><img src="/images/java-memory/race-condition.png" alt="race-condition"></p><p>Để giải quyết tất cả vấn đề trên có thể dùng <code>block synchronized</code>. Block synchronized đảm bảo việc tất cả các biến được truy cập trong block này sẽ được đọc từ RAM,và khi thread rời khỏi block thì mọi thay đổi tới các biến sẽ được ghi vào RAM ngay lập tức. Sau đó những thread khác mới bắt đầu load data và tính toán</p><h2 id="4-Refer">4. Refer</h2><ul><li><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Scala </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Implicit in Scala</title>
      <link href="/Technology/scala/2020/11/02/implicit-scala/"/>
      <url>/Technology/scala/2020/11/02/implicit-scala/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/implicit-in-scala.png" alt="implicit-in-scala"></p><h2 id="1-Implicit-conversion">1. Implicit conversion</h2><p>Cách thức hoạt động:</p><ul><li>Đầu tiên compiler sẽ compile code, nhưng sẽ gặp lỗi type errors.</li><li>Trước khi kết thúc việc compile, compiler sẽ tìm các implicit conversion phù hợp đểrepair lỗi đó.</li><li>Nếu fix được thì nó sẽ tiếp tục việc compile còn không sẽ throw error.</li></ul><h2 id="2-Cac-Rule">2. Các Rule</h2><h3 id="a-Making-rule">a. Making rule</h3><p>Các variable, function, object phải được khai báo với từ khóa <code>implicit</code> thì compiler mới có thể sử dụng được.</p><blockquote><pre><code>   implicit def intToString(x: Int) = x.toString</code></pre></blockquote><h3 id="b-Scope-rule">b. Scope rule</h3><p>Một implicit conversion được sử dụng phải trong scope và nó phải là implicit duy nhất, hoặc được liên kết với source or target type của conversion.</p><p>Muốn sử dụng implicit có 2 cách:</p><blockquote><p>Import implicit mà bạn muốn dùng.</p><pre><code>import Preamble._</code></pre><p>Viết các implicit trong companion Object. vì các companion sẽ liên kết với các class, case class của nó nên compiler sẽ tự động sử dụng chúng khi cần.</p><pre><code>object Dollar &#123;    implicit def dollarToEuro(x: Dollar): Euro = ...&#125; class Dollar &#123; ... &#125;</code></pre></blockquote><h3 id="c-One-at-a-time-rule">c. One at a time rule</h3><p>Trong một thời điểm chỉ có một implicit được áp dụng. Compiler sẽ không bao giờ áp dụng thêm những implicit conversion khác khi đã có một implicit được sử dụng. Vì khi đó sẽ làm tăngcompile time khi gặp code lỗi. Đồng thời nó cũng có thể dẫn đến việc hiểu nhầm giữa code của developer với cái mà compiler tạo ra.</p><blockquote><pre><code>convert1(convert2(x)) + y // sẽ không bao giờ có trường hợp này</code></pre></blockquote><h3 id="d-Explicits-first-rule">d. Explicits first rule</h3><p>Bất cứ khi code đang hoạt động tốt, implicit sẽ không bao giờ được sử dụng. (Nó chỉ được sử dụng khi compiler phát hiện lỗi).</p><h2 id="3-Khi-nao-implicit-se-duoc-ap-dung">3. Khi nào implicit sẽ được áp dụng</h2><p>Có 3 cách mà implicit được sử dụng:</p><ul><li>Conversions to an expected type</li><li>Conversions of the receiver of a selection</li><li>Implicit parameters</li></ul><h3 id="a-Conversions-to-an-expected-type">a. Conversions to an expected type</h3><blockquote><p>Bất cứ khi nào compiler thấy một kiểu X nhưng lại cần một kiểu Y. Nó sẽ tìm một implicit method chuyển X sang Y.</p></blockquote><p>Lấy ví dụ để dễ hiểu:</p><blockquote><p>Nếu một số Double cần chuyển đổi thành số Int. Compiler sẽ tìm những implicit trong scope có thể chuyển Double thành Int để apply để tránh khỏi lỗi.</p><pre><code>  val age: Int  =  26.5 // got error</code></pre><p>Solution:</p><pre><code>  implicit def doubleToInt(x: Double): Int = x.toInt  val age: Int  =  26.5 // age = 26</code></pre></blockquote><p>Với ví dụ trên việc implicit conversion từ Double sang Int sẽ gây rất khó hiểu (Vì các số bị làm tròn). Nhưng nếu implicit conversion từ Int sang Double thì sẽ hợp lý hơn rất nhiều. Vì thế khi dùng implicit thìnên chuyển đổi từ một kiểu nhỏ sang một kiểu lớn hơn, bao quát hơn, tránh làm ngược lại.</p><p>Đoạn code trên nên được sửa lại thành:</p><blockquote><pre><code>  implicit def int2double(x: Int): Double = x.toDouble // chuyển từ Int sang Double thì các giá trị sẽ luôn đúng</code></pre></blockquote><h3 id="b-Conversions-of-the-receiver-of-a-selection">b. Conversions of the receiver of a selection</h3><p>Khi một <code>object</code> gọi một method mà nó không có, thì compiler sẽ chuyển đổi <code>object</code> đó thành <code>object</code> khác mà chứa method được gọi.</p><p>Nó được sử dụng chính trong 2 trường hợp:</p><ul><li>Tương tác với những types mới (Interoperating with new types). Dễ hiểu thì là: Khi viết <code>obj.doIt</code> mà <code>obj</code> lại không hề có <code>doIt</code>.Lúc này compiler sẽ tìm kiếm các implicit conversion có thể biến đổi từ <code>obj</code> sang 1 kiểu nào đó mà có chứa <code>doIt</code>.</li></ul><blockquote><pre><code>  class Rational(n: Int, d: Int) &#123;      def + (that: Rational): Rational = ...      def + (that: Int): Rational = ...  &#125;  val oneHalf = new Rational(1, 2)</code></pre><p>Khi viết như sau thì hoàn toàn hợp lệ:</p><pre><code>  oneHalf + 1 // res = 3/2</code></pre><p>Nhưng nếu viết như sau sẽ throw Exception:</p><pre><code>  1 + oneHalf // Exception</code></pre><p>Do <code>1</code> không có method <code>+</code> nào nhận giá trị có kiểu <code>Rational</code> làm parameter cả. Để giải quyết vấn đề này có thể viết thêm như sau:</p><pre><code>  implicit def intToRational(x: Int) = new Rational(x, 1)</code></pre></blockquote><ul><li>Mô phỏng systax mới (Simulating new syntax).</li></ul><blockquote><p>Bạn có thể quen thuộc khi khai báo Map như sau:</p><pre><code>  Map(1 -&gt; &quot;one&quot;, 2 -&gt; &quot;two&quot;, 3 -&gt; &quot;three&quot;)</code></pre><p>Ta có thể thấy <code>1</code> là số Int thì tại sao lại có method <code>-&gt;</code>. Vì muốn tạo ra systax mới (method <code>-&gt;</code>) cho một kiểu bất kỳ thì library đã tạo ra một <code>implicit def -&gt;</code> để convert các type sang <code>ArrowAssoc</code>Lúc này compiler sẽ apply <code>implicit def -&gt;</code> vào trong số <code>1</code>.</p><pre><code>  package scala  object Predef &#123;      class ArrowAssoc[A](x: A) &#123;      def -&gt; [B](y: B): Tuple2[A, B] = Tuple2(x, y)      &#125;      implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =      new ArrowAssoc(x)      ...  &#125;</code></pre><p>Trong Scala cũng sử dụng rất nhiều các class có tên kiểu <code>RichSomething</code> ví dụ như RichInt, RichBoolean… Thì khả năng nó sẽ thêm các systax mới để phục vụ cho kiểu <code>Something</code></p></blockquote><h3 id="c-Implicit-parameters">c. Implicit parameters</h3><p>Được áp dụng cho các parameters được parse vào method mà được khai báo là implicitNó được dùng chủ yếu để cung cấp thêm thông tin về type của một parameter được thêm vào trước đó trong method.</p><p>Chú ý: Chúng ta nên tạo ra các type mới cho các implicit parameter để có thể giúp người đọc hiểu hơn về giá trị implicit truyền vào có ý nghĩa gì. Như ví dụ bên dưới, thay vì để <code>promt</code> <code>hoặc</code> <code>drink</code>có type là String thì ta nên để type của chúng <code>PreferredPrompt</code> và <code>PreferredDrink</code>.</p><blockquote><pre><code>class PreferredPrompt(val preference: String)class PreferredDrink(val preference: String)object Greeter &#123;  implicit val prompt = new PreferredPrompt(&quot;Yes, master&gt; &quot;)  implicit val drink = new PreferredDrink(&quot;tea&quot;)  def greet(name: String)(implicit prompt: PreferredPrompt, drink: PreferredDrink) &#123;     println(&quot;Welcome, &quot;+ name +&quot;. The system is ready.&quot;)     print(&quot;But while you work, &quot;)     println(&quot;why not enjoy a cup of &quot;+ drink.preference +&quot;?&quot;)     println(prompt.preference)  &#125;&#125;Greeter.greet(&quot;Joe&quot;)// Welcome, Joe. The system is ready.// But while you work, why not enjoy a cup of tea?// Yes, master&gt;</code></pre></blockquote><h2 id="4-Trong-mot-scope-nhung-co-nhieu-conversion-co-the-ap-dung">4. Trong một scope nhưng có nhiều conversion có thể áp dụng</h2><ul><li><p>Với scala 2.7 trở về trước, khi gặp trường hợp này compiler sẽ throw ra lỗi <code>ambiguous</code>. Vì nó không biết chọn cái nào để aply. (Nó cũng tương tự overloading. khi có 2 method giống hệt nhau thì compiler sẽ báo lỗi.)</p></li><li><p>Với scala 2.8 trở đi thì compiler sẽ chọn ra một implicit mà nó rõ ràng hơn để sử dụng</p></li></ul><blockquote><p>Tuy nhiên dù thế nào đi nữa, chúng ta nên chỉ định rõ ràng implicit nào được sử dụng để tránh confuse.</p></blockquote><h2 id="5-Tong-ket">5. Tổng kết.</h2><p>Implicit rất mạnh mẽ và được sử dụng rất rộng rãi. Gần như trong tất cả libraries, 3rd đều sử dụng nó. Nó có các lợi ích sau:</p><ul><li>Có thể giúp bạn thêm các fields, method cho các class mà bạn muốn.</li><li>Giúp code ngắn gọn hơn</li><li>Reuse code tốt hơn.</li></ul><p>Bên cạnh nó nếu lạm dụng thì code sẽ trở lên khó hiểu, và khó debug. Vì thế <code>NẾU KHÔNG CÒN LỰA CHỌN NÀO KHÁC THÌ HÃY SỬ DỤNG IMPLICIT</code></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Encoding</title>
      <link href="/Technology/common/2019/07/14/encoding/"/>
      <url>/Technology/common/2019/07/14/encoding/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/unicode.png" alt="Unicode"></p><h2 id="1-Thuat-ngu">1. Thuật ngữ</h2><ul><li><p>encode: dùng 1 thứ gì đó để để thể hiện cho 1 thứ khác. VD: 01100010 là b</p></li><li><p>Encoding: là tập hợp các quy tắc để thực hiện việc chuyển đổi đó. VD: mã hóa ký tự sang bit</p></li><li><p>decode: từ bit giải mã sang ký tự</p></li><li><p>character set, charset: tập hợp các ký tự có thể được encode</p></li><li><p>code page: là bảng mapping bit với ký tự</p></li></ul><h2 id="2-Overview">2. Overview</h2><p>Máy tính chỉ có thể làm việc và hiểu được với bit.</p><p>Để biểu diễn bất cứ thứ gì thì ta cần phải có quy tắc để chuyển đổi chúng thành bit và ngược lại. Quy tắc đó chính là encoding scheme (lược đồ mã hóa) gọi tắt là encoding.</p><blockquote><p>VD: trong encoding ASCII thì:</p><pre><code>   1100010 là b   01101001 là i   01110100 là t</code></pre></blockquote><p>1 byte có 8 bits chứ không phải 7 hay 9 bits vì tổ hợp của 8 bits là 256 trường hợp khác nhau. Nó vừa đủ để để biểu diễn tất cả các ký tự trong tiếng Anh mà không thừa, không thiếu. Nhưng nó lạikhông đủ để mapping cho tất cả các ngôn ngữ trên thế giới (tiếng Trung, Nhật, Ấn Độ, Pháp…) nên người tađã tạo rất nhiều loại encoding phù hợp với ngôn ngữ của họ. Và họ đã nghĩ tới việc tăng 1 ký tự tương ứng với 2 bytes (16 bits) VD: BIG-5, GB18030</p><p>Con người có thể dùng hệ bát phân, thập phân và thập lục phân để viết cho gọn. Còn máy tính luôn luôn sử dụng hệ nhị phân. Quá trình đóng gói và truyền qua internet cũng là tổ hợp các gói tin và gửi đi.</p><h2 id="3-Unicode">3. Unicode</h2><p>Unicode ra đời để hợp nhất tất cả các chuẩn mã. Unicode là 1 encode schema nhưng không phải là 1 loại encoding. Nó tạo ra 1 code page chứa đến 1,114,112 ký tự. Nó có thể biểu diễn cho tất cả các ngôn ngữ, ký tự trên thế giới.</p><p>Bài toán đặt ra: để biểu diễn hết tất cả các ký tự trong unicode, nếu encoding dùng 2 bytes (2^16 ký tự) thì không đủ. còn 3 bytes (2^24) thì đủ nhưng ngta không dùng 3 bytes. nên 4 bytes đã được chọn.</p><p>Với encoding UTF-32 sẽ mã hóa mọi ký tự bằng 4 bytes. Nhưng như thế nó quá tốn kém trong việc lưu trữ (có thể file size lớn lên 4 lần).</p><p>UTF-16 và UTF-8 là 2 loại encoding đa chiều dài nên sẽ tối ưu hơn.</p><ul><li>Với UTF- 8: Nếu ký tự chỉ cần 1 byte thì nó sẽ mã hóa bằng 1 byte…Nếu cần 4 bytes nó sẽ mã hóa bằng 4 bytes. Khi giải mã thì byte đầu tiên trong chuỗi (bit có trọng số cao nhất – MSB) sẽ dùng để xác định số byte cấu thành ký tự.</li><li>UTF-16: Cũng tương tự như UTF-8 nhưng nó sẽ dùng ít nhất 2 bytes, và có thể tăng lên 4 bytes.</li></ul><h2 id="4-Chon-sai-encoding-khi-mo-1-van-ban">4. Chọn sai encoding khi mở 1 văn bản</h2><p>Việc biết 1 văn bản được encoding bằng encoding nào rất là khó. chỉ có thể dựa vào suy đoán.</p><p>Khi mở văn bản sai encoding có thể sẽ ảnh hưởng đến nội dung của văn bản. Vì khi mở văn bản. Có thể các editor có thể âm thầm thay thế những bytes mà nó không nhận diện ra được bằng ký tự ? hoặc � (thậm chí là loại bỏ bytes đó đi). Từ đó không thể khôi phục lại được dữ liệu ban đầu.</p><p>Nếu muốn convert từ encoding này sang encoding khác thì cần dùng các phần mềm chuyên dụng để mapping lại cái giá trị tương ứng trong code page của từng loại.</p><h2 id="5-UTF-8-va-ASCII">5. UTF-8 và ASCII</h2><p>UTF-8 tương thích hoàn toàn với ASCII.</p><p>Mọi ký tự trong ASCII đều tương đương với giá trị trong UTF-8. Những ký tự không có trong ASCII sẽ có từ 2 bytes trở lên.</p><p>Mọi String trong Javascript đều được encoding chỉ bởi UTF-16</p><p>Ngày nay, UTF-8 được coi là tiêu chuẩn. Vì nó mã hoá gần như mọi ký tự bạn cần, tương thích ngược với và khá hiệu quả về mặt bộ nhớ đối với hầu hết các trường hợp.</p><h2 id="6-Tong-ket">6. Tổng kết</h2><ul><li>Khi làm việc với CSV cũ thì nên mở với UTF16 LE để tránh lỗi encoding</li></ul><h2 id="7-Refer">7.Refer</h2><ul><li><a href="https://kunststube.net/encoding/">https://kunststube.net/encoding/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> common </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Scala </tag>
            
            <tag> JS </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Index trong MySQL</title>
      <link href="/Technology/MySQL/2019/03/27/index-in-mysql/"/>
      <url>/Technology/MySQL/2019/03/27/index-in-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Index-la-gi">1. Index là gì?</h2><blockquote><p>“Indexes are special lookup tables that the database search engine can use to speed up data retrieval. Simply put, an index is a pointer to data in a table. An index in a database is very similar to an index in the back of a book”</p></blockquote><p>Hay hiểu đơn giản là dùng với mục đích là tăng tốc độ tìm kiếm</p><h2 id="2-Khi-nao-nen-su-dung-index">2. Khi nào nên sử dụng index?</h2><ul><li>Table có nhiều dữ liệu</li><li>Lấy dữ liệu &lt; 5% tổng data</li><li>Bảng ít update, delete, insert data</li><li>Column ít giá trị null</li><li>Column thường được sử dụng làm điều kiện khi truy vấn</li><li>Nên đánh index trên khóa ngoại</li><li>Selectivity cao (= cardinality/(number of records) * 100% )=&gt; Những column Unique, Sorted</li></ul><blockquote><p>cardinality: là số lượng bản ghi duy nhất xuất hiện trong table cho column đó.Ví dụ: table Employee với column sex, cột này chỉ có thể có 2 giá trị là Male và Female, như vậy cardinality cho column sex sẽ là 2, vì ta chỉ có 2 giá trị duy nhất xuất hiện ở cột column</p></blockquote><h2 id="3-Cac-loai-index-thuong-dung">3. Các loại index thường dùng</h2><ul><li>Btree Index (default và phổ biến nhất)</li><li>Bitmap Index</li><li>Index-organized table</li><li>Hash clusters</li><li>Index clusters</li><li>Nested table</li><li>Reverse Key Index</li></ul><h2 id="4-B-Tree-index">4. B-Tree index</h2><p><img src="/images/b-tree-index.png" alt="B-tree-index"></p><ul><li>Là index mặc định trong Database</li><li>Index sẽ bị xóa khi table bị xóa</li><li>Gồm 3 phần: Root, Branch, Leaf</li></ul><blockquote><p>Leaf gồm:</p><ul><li>Index entry header: thông tin lưu trữ số column và thông tin khoá của các hàng trong bảng.</li><li>Key column length_value pair: chứa thông tin về kích thước column tham gia vào khoá và tiếp theo là kích thước của đó.</li><li>ROWID: là giá trị của ROWID chứa giá trị khoá của index</li></ul></blockquote><blockquote><p>Các lệnh DML(Data manipulation Language)</p><ul><li>Insert: Thêm index entry</li><li>Delete: Disable index entry</li><li>Update: Disable =&gt; insert new index entry</li></ul></blockquote><h3 id="a-Dac-diem">a. Đặc điểm</h3><ul><li>Giá trị khóa sẽ lặp đi lặp lại nếu có nhiều giá trị trùng nhau</li><li>Với composite index trên nhiều column, khi tìm kiếm nó sử dụng 2 column đầu tiên để tìm kiếm, tìm kiếm theo thứ tự đánh index=&gt; column unique, nhiều data thì nên đánh trước</li><li>Không lưu dữ liệu có giá trị null</li></ul><h3 id="b-Index-khong-duoc-ap-dung-khi">b. Index không được áp dụng khi</h3><ul><li>Dùng cho các toán tử &lt;&gt;, != và NOT IN, NOT LIKE</li><li>Kết hợp toán tử Like có ‘%’ ở đầu.</li><li>Kết hợp các thành phần khác (giá trị, biểu thức…)=&gt; function-base Index. VD: CREATE INDEX idx ON emp (UPPER(emp_name));</li><li>So sánh với giá trị khác kiểu</li></ul><h3 id="c-Rebuild">c. Rebuild</h3><p>Tại sao cần rebuild:</p><blockquote><ul><li>Height index càng nhỏ thì tìm càng nhanh. Nếu Height = 3 thì khi hoạt động index cần phải đọc ít nhất 3 block là root block, branch block và leaf block</li><li>Việc delete, update dữ liệu nhiều =&gt; deleted leaf nhiều =&gt; tree mất cân bằng</li></ul></blockquote><p>Khi nào nên rebuild</p><blockquote><ul><li>Height &gt; 4, deleted leaf &gt; 20%</li></ul></blockquote><p>Chú ý:</p><blockquote><ul><li>Nên run lại câu lệnh statistic để cập nhật lại thông tin statistic và EP sauANALYZE TABLE &lt;TBL_NAME&gt; COMPUTE STATISTICS</li></ul></blockquote><h3 id="d-Cac-cau-lenh-hay-dung">d. Các câu lệnh hay dùng</h3><blockquote><ul><li>Create Index: CREATE INDEX index_name ON table (column1, column2…) [ONLINE];</li><li>Rename: ALTER INDEX index RENAME TO &lt;new_index_name&gt;;</li><li>Drop Index: DROP INDEX index_name;</li><li>Rebuild Index: ALTER INDEX DEPT_LOCATION_IX REBUILD [ONLINE];</li></ul></blockquote><p>Note:</p><ul><li>Thông thường trong khi tạo index, các câu lệnh DML tác động lên cột dữ liệu có liên quan đều tạm thời không thực hiện được cho đến khi hoàn tất việc tạo index.</li><li>Để có thể cho phép thực hiện câu lệnh DML tác động lên các cột dữ liệu được index, Oracle có hỗ trợ Index online (Index trực tuyến) khi này, ta cần bổ sung thêm mệnh đề ONLINE vào trong câu lệnh.</li></ul><h2 id="5-Refer">5. Refer</h2><ul><li><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL statement processing</title>
      <link href="/Technology/Oracle/MySQL/2019/02/14/sql-statement-processing/"/>
      <url>/Technology/Oracle/MySQL/2019/02/14/sql-statement-processing/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Trinh-tu-xu-ly-cau-lenh-SQL">1. Trình tự xử lý câu lệnh SQL</h2><p><img src="/images/sql-state-process-phase.png" alt="sql-state-process-phase"></p><p>Parse Phase</p><ul><li>Check <code>Execute Plan(EP)</code> đã tồn tại trên <code>Shared Pool</code> chưa? Nếu có rồi thì sang bước <code>Bind</code></li><li>Phân tích, kiểm tra cú pháp, quyền truy cập</li><li>Tạo EPExecute Plan: Oracle Server sẽ lên kế hoạch để thực thi câu lệnh sao cho chi phí bỏ ra là thấp nhất thông qua Trình tối ưu câu lệnh (Optimizer)</li></ul><h2 id="2-Trinh-toi-uu-cau-lenh-Optimizer">2. Trình tối ưu câu lệnh(Optimizer)</h2><ul><li>Giúp tạo ra EP tốt nhất cho câu lệnh</li><li>Có 2 phương pháp:<ul><li>Rule Based Optimizer (RBO): Dùng lược đồ phân rank các phương thức truy cập. Rank càng thấp thì càng được ưu tiên.VD: single row by rowId có rank = 1; Full table scan có rank = 15</li><li>Cost Based Optimizer (CBO): Dựa vào các thông tin: CPU, IO… để tính Cost. sẽ chọn EP có Cost nhỏ nhất.</li></ul></li></ul><h2 id="3-Cac-cach-truy-cap-du-lieu">3. Các cách truy cập dữ liệu</h2><ul><li>Physical:</li></ul><blockquote><p>Truy cập DB theo DB_Block (disk read). Tốn nhiều thời gian và resources vì cần IO disk</p></blockquote><ul><li>Logical: Đọc block data từ Buffer Cache</li></ul><blockquote><ul><li>Table Access Full: duyệt tuần tự từng bản ghi. Dùng khi:<ul><li>Không có Index hoặc Index không dùng được</li><li>Dù có Index, nhưng tập data trả về lớn</li><li>Số lượng bản ghi ít</li></ul></li><li>Index scan: Chỉ đọc trên Index</li><li>Table Access by Index RowId: Duyệt Index =&gt; duyệt rowId</li></ul></blockquote><h2 id="4-Co-che-thuc-thi-lenh-Join">4. Cơ chế thực thi lệnh Join</h2><ul><li>Optimizer sẽ tự chọn các thuật toán để JOIN table sao cho chi phí là thấp nhất</li><li>Các loại:</li></ul><blockquote><ul><li>Nested Loop Join</li><li>Sort Merge Join</li><li>Hash Join</li></ul></blockquote><h4 id="a-Nested-Loop-Join">a. Nested Loop Join</h4><ul><li>Implement: Khi Join T1 - inner table với T2 - outer table. Từng row trong T1 sẽ so sánh với tất cả rows trên T2</li><li>Dùng khi: T1 nhỏ, và T2 được sort theo trường được Join</li><li>Thể hiện: Câu lệnh hiệu quả, chi phí thấp</li></ul><h4 id="b-Merge-Join">b. Merge Join</h4><ul><li>Implement: Cả 2 table T1 vs T2 phải sort theo trường được Join. Sau đó cả 2 bảng sẽ đọc từ đầu và cùng tiến lên song song. Có thể sẽ kết thúc nếu quét hết data của table nhỏ.</li><li>Trong trường hợp 1 trong 2 table không được sắp xếp thì Optimizer sẽ sort table còn lại và dùng Merge Join hoặc có thể dùng Hash Join</li><li>Hiệu quả: Tập dữ liệu trả về lớn</li></ul><h4 id="c-Hash-Join">c. Hash Join</h4><p><img src="/images/hash-join-implement.png" alt="hash-join-implement"></p><ul><li>Hiệu quả: Tập dữ liệu trả về lớn và field Join không được sắp xếp</li><li>So với Merge Join:<ul><li>Hash Join sẽ nhanh hơn so với việc phải sắp xếp lại table.</li><li>Tốn CPU, Memory hơn do phải tạo bảng + hash</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Oracle </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Mysql </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>This in Javascript</title>
      <link href="/Technology/JS/2019/01/16/this-in-javascript/"/>
      <url>/Technology/JS/2019/01/16/this-in-javascript/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/this-in-js.png" alt="this-in-js"></p><h2 id="1-Call-site">1. Call-site</h2><ul><li><p><strong>call-site</strong> là vị trí đoạn code nơi mà function được gọi (không phải nơi được khai báo). Đây là thứ duy nhất mà <code>this</code> phụ thuộc vào.</p></li><li><p><strong>call-stack</strong>: là một stack chứa tên các functions được thực thi.</p></li></ul><blockquote><pre><code>  function baz() &#123;      // call-stack là: `baz`      // call-site sẽ là global scope      console.log( &quot;baz&quot; );      bar(); // call-site cho `bar`  &#125;  baz(); // call-site cho `baz`  function bar() &#123;      // call-stack lúc này là: `baz` -&gt; `bar`.      // Do `baz` được gọi trước và call đến `bar` trong nó      // call-site là trong `baz`      console.log( &quot;bar&quot; );      foo(); // call-site cho `foo`  &#125;  function foo() &#123;      // call-stack là: `baz` -&gt; `bar` -&gt; `foo`      // call-site là trong `bar`      console.log( &quot;foo&quot; );  &#125;</code></pre></blockquote><p>Để dễ dàng xác định call-stack, có thể sử dụng <code>debugger</code> hoặc <code>breakpoint</code> để xem call-stack. Dựa vào call-stack ta dễ dàng xác định được call-site</p><h2 id="2-Rules">2. Rules</h2><h3 id="a-Default-Binding">a. Default Binding</h3><p>Khi function được gọi một cách độc lập <strong>default binding</strong> sẽ được áp dụng.</p><p>Xét ví dụ:</p><blockquote><pre><code>  function foo() &#123;      // call-site sẽ là global scope      let a = 1;      console.log( this.a ); //this chính là global object  &#125;  var a = 2; // a là một property của global object  // call-site cho foo  foo(); // 2 </code></pre></blockquote><p>Do <code>foo()</code> có call-site là trong global scope. Và default binding được áp dụng nên <code>this.a</code> sẽ trỏ đến biến <code>a</code> của global object.</p><p>Chú ý: Nếu sử dụng <code>strict mode</code> ở trong <code>foo()</code> (còn các nơi khác thì không liên quan) thì <code>this</code> sẽ là <code>undefined</code></p><blockquote><pre><code>  function foo() &#123;     &quot;use strict&quot;;      console.log( this.a );  &#125;  var a = 2;  function bar() &#123;      console.log( this.a );  &#125;    (function()&#123;      &quot;use strict&quot;; // strict mode không ảnh hưởng đến `this` trong `bar`      bar(); // 2  &#125;)();    foo(); // TypeError: `this` is `undefined`</code></pre></blockquote><h3 id="b-Implicit-Binding">b. Implicit Binding</h3><p>Call-site có context là object. Hay nói cách khác, functions được tạo hoặc chứa trong object thì <strong>implicit binding</strong> sẽ được áp dụng</p><p>Xét ví dụ:</p><blockquote><pre><code>  function foo() &#123;      console.log( this.a ); // this.a chính là obj2.a  &#125;  var obj2 = &#123;      a: 42,      foo: foo  &#125;;  var obj1 = &#123;      a: 2,      obj2: obj2  &#125;;  obj1.obj2.foo(); // 42</code></pre></blockquote><p>Ta thấy <code>foo()</code> được chứa trong object <code>obj2</code>, nên <strong>implicit binding</strong> sẽ được áp dụng. Vì thế <code>this.a</code> cũng chính là <code>obj2.a</code>.</p><p>Chú ý là chỉ có object cuối cùng trong call-stack mới ảnh hưởng đến call-site nên <code>obj1.a</code> sẽ không được tham chiếu trong trường hợp trên.</p><h4 id="Implicit-Lost">Implicit Lost</h4><p>Cũng có trường hợp <strong>Implicit binding</strong> không được áp dụng mặc dù functions được tạo hoặc chứa trong object. Khi này <strong>Default Binding</strong> sẽ được áp dụng</p><p>Như ví dụ bên dưới, mặc dù<code>foo()</code> được chứa trong <code>obj</code> nhưng <code>bar</code> lại được gán bằng function <code>obj.foo</code>. Nên khi gọi <code>bar()</code> thì call-site của <code>foo()</code> lúc này sẽ là global</p><blockquote><pre><code>  function foo() &#123;      console.log( this.a );  &#125;  var obj = &#123;      a: 2,      foo: foo  &#125;;  var bar = obj.foo;  var a = &quot;oops, global&quot;; // `a` also property on global object  bar(); // &quot;oops, global&quot;</code></pre></blockquote><p>Ngay cả khi truyền hàm như một biến trong call back function thì <strong>implicit binding</strong> cũng không được áp dụng</p><blockquote><pre><code>  function foo() &#123;      console.log( this.a );  &#125;  var obj = &#123;      a: 2,      foo: foo  &#125;;  var a = &quot;oops, global&quot;; // `a` also property on global object  setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</code></pre></blockquote><h3 id="c-Explicit-Binding">c. Explicit Binding</h3><p><strong>explicit binding</strong> giúp chúng ta ép <code>this</code> có call-site của object cụ thể theo ý mình thông qua 3 methods:<a href="/Technology/JS/2019/01/03/call-bind-apply-in-js/" title="compare call, apply, bind">call(), apply() và bind().</a></p><p>** explicit binding** sẽ có độ ưu tiên cao hơn <strong>Implicit binding</strong>, và dĩ nhiên là cả <strong>default binding</strong></p><h3 id="d-New-Binding">d. New Binding</h3><p>Khi call một function với <code>new</code> operator thì JS sẽ tự động thực hiện:</p><ul><li>Tạo mới một object mới từ function được gọi.</li><li>Object mới này sẽ được binding <code>this</code> cho function đó</li><li>Trừ khi function đó return về một function thay thế nếu không sẽ luôn tự động trả về object mới.</li></ul><p>Ví dụ:</p><blockquote><pre><code>  function foo(a) &#123;      this.a = a;  &#125;  // một function object mới được tạo ra và gán vào `bar`  var bar = new foo( 2 );   console.log( bar.a ); // 2</code></pre></blockquote><p><strong>New binding</strong> có khả năng override <code>bind()</code> trong explicit (call() và apply() sẽ gọi function ngay lập tực nên không được xét).</p><h2 id="3-Note">3. Note</h2><p>Các functions bình thường sẽ tuân theo 4 rules kể trên. Nhưng trong ES6 có một function đặc biệt là <strong>arrow-fucntion</strong>.<strong>Arrow function</strong> sẽ có call-site của nơi bên ngoài gần nó nhất (function hoặc global).</p><blockquote><pre><code>  function foo() &#123;      // return an arrow function      return (a) =&gt; &#123;          // `this` ở đây sẽ được binding với `this` của `foo()`          console.log( this.a );      &#125;;  &#125;  var obj1 = &#123; a: 2 &#125;;  var obj2 = &#123; a: 3 &#125;;  // `this` của foo() được `binding` với `obj1`.  // nên arrow function cũng sẽ có this binding là `obj1`  // mặc dù đã binding lại `bar` với `obj2` nhưng cũng sẽ không có tác dụng.  // vì bar là một arrow-function  var bar = foo.call( obj1 );  bar.call( obj2 ); // 2, not 3!</code></pre></blockquote><h2 id="4-Refer">4. Refer</h2><p><a href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/ch2.md">https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this %26 object prototypes/ch2.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Technology </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Call, Apply, Bind trong JS</title>
      <link href="/Technology/JS/2019/01/03/call-bind-apply-in-js/"/>
      <url>/Technology/JS/2019/01/03/call-bind-apply-in-js/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/call-apply-bind-in-js.png" alt="call-apply-bind-in-js"></p><p>Mọi functions trong JS đều là Object. Và object Function sẽ gồm các thành phần:</p><ul><li>name: Là tên của function. Nếu không có name thì function sẽ là anonymous function</li><li>code: Là những dòng lệnh khi function được invoke.</li><li>3 utilities function: call(), apply(), bind()</li></ul><h2 id="1-Cach-su-dung-call">1. Cách sử dụng call()</h2><blockquote><p><strong>The call() method calls a function with a given <code>this</code> value and arguments provided individually.</strong></p><p>Nghĩa là: call() sẽ gọi một function ngay lập tức và truyền một tham số đại diện cho <code>this</code> và có thể có hoặc không arguments</p><pre><code>  call(thisArg, arg1, ... , argN)</code></pre></blockquote><p>Ví dụ:</p><blockquote><pre><code>  function print(address, gender) &#123;      console.log(`name: $&#123;this.name&#125;`);      console.log(`address: $&#123;address&#125;`);      console.log(`gender: $&#123;gender&#125;`);  &#125;  var person = &#123;      name: &quot;Jun&quot;  &#125;;  print.call( person,  &quot;VN&quot;, &quot;M&quot;);</code></pre></blockquote><h2 id="2-Cach-su-dung-apply">2. Cách sử dụng apply()</h2><blockquote><p><strong>The apply() method calls a function with a given <code>this</code> value, and arguments provided as an array.</strong></p><p>Nghĩa là: apply() sẽ gọi một function và truyền một tham số đại diện cho <code>this</code> và các arguments là một Array.</p><pre><code>  apply(thisArg, argsArray)</code></pre></blockquote><p>Nhìn chung <code>apply()</code> và <code>call()</code> gần giống nhau. Chúng chỉ khác nhau ở cách truyền các tham số.</p><p>Ví dụ:</p><blockquote><pre><code>  function print(address, gender) &#123;      console.log(`name: $&#123;this.name&#125;`);      console.log(`address: $&#123;address&#125;`);      console.log(`gender: $&#123;gender&#125;`);  &#125;  var person = &#123;      name: &quot;Jun&quot;  &#125;;  print.apply( person,  [&quot;VN&quot;, &quot;M&quot;]);</code></pre></blockquote><h2 id="3-Cach-su-dung-bind">3. Cách sử dụng bind()</h2><blockquote><p><strong>The bind() method creates a new function that, when called, has its this keyword set to the provided value,with a given sequence of arguments preceding any provided when the new function is called.</strong></p><p>Nghĩa là: Trả về một function mới sau khi gọi một function và truyền một tham số đại diện cho <code>this</code> và có thể có hoặc không arguments.</p><pre><code>  bind(thisArg, arg1, ... , argN)</code></pre></blockquote><ul><li><code>bind()</code> sẽ rất hữu hiệu khi sử dụng với các callback function.</li><li><code>bind()</code> có độ ưu tiên cao nhất trong 3 functions. Nếu dùng cả <code>bind()</code> và <code>call</code> thì <code>bind()</code> luôn được ưu tiên.VD: bind(obj1).call(obj2). obj1 sẽ được apply</li></ul><p>Ví dụ:</p><blockquote><pre><code>  function print(address, gender) &#123;      console.log(`name: $&#123;this.name&#125;`);      console.log(`address: $&#123;address&#125;`);      console.log(`gender: $&#123;gender&#125;`);  &#125;  var person = &#123;      name: &quot;Jun&quot;  &#125;;  // JS engine sẽ tạo một instance của `print` method  // và binding `person` vào biến `this` của function `print`  var printJun = print.bind( person,  &quot;VN&quot;, &quot;M&quot;);   printJun();</code></pre></blockquote><h2 id="4-Note">4. Note</h2><ul><li>Nếu pass một giá primitive(boolean, number…) vào để đại diện cho <code>this</code> thì nó sẽ được boxing và wrap bởi chính các object của nó (new Boolean(…), new Number(…))</li><li>Nếu truyền <code>null</code> hoặc <code>undefined</code> vào để biểu diễn cho <code>this</code> thì<a href="/Technology/JS/2019/01/16/this-in-javascript/#a-Default-Binding" title="default binding">default binding</a> sẽ được áp dụng.</li></ul><blockquote><pre><code>  function foo(a,b) &#123;      console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );  &#125;  // spreading out array as parameters  foo.apply( null, [2, 3] ); // a:2, b:3  // currying with `bind(..)`  var bar = foo.bind( null, 2 );  bar( 3 ); // a:2, b:3</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Technology </tag>
            
            <tag> call </tag>
            
            <tag> apply </tag>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookies</title>
      <link href="/Technology/JS/2018/05/12/cookies/"/>
      <url>/Technology/JS/2018/05/12/cookies/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cookies.png" alt="Cookies"></p><h2 id="1-Cookies-la-gi">1. Cookies là gì?</h2><p>Là 1 file dữ liệu nhỏ (tối đa là 4093kb) được server trả về và lưu trong trình browser của người dùng.</p><p>Mỗi khi request lên server thì cookie (chỉ key và value, còn những data khác: httpOnly, sameSite… sẽ không được gửi lên) của server đó cũng sẽ được gửi lên cùng.</p><p>Vì thế, nên ưu tiên save thông tin mà server không cần dùng vào localstorage, sessionstorage, indexeddb để tránh việc gửi data thừa lên server.</p><p>Có 3 mục đích chính khi dùng cookies:</p><ul><li>Quản lý phiên làm việc: thông tin đăng nhập, giỏ hàng…</li><li>Thông tin về cá nhân: tùy chọn giao diện, cài đặt…</li><li>Theo dõi, phân tích hành vi của người dùng</li></ul><h2 id="2-Cac-loai-cookies">2. Các loại cookies.</h2><p>Có 2 loại cookies:</p><ul><li>Session Cookies: Cookies sẽ bị xóa khi trình duyệt bị đóng.</li><li>Persistent Cookies: Cookies sẽ bị xóa khi bị hết hạn hoặc bị xóa thủ công</li></ul><p>Khi tạo cookies nếu không set expire date hoặc max-age thì đó là session cookies, còn ngược lại là Persistent cookies</p><h2 id="3-Cac-thanh-phan-co-trong-Cookie">3. Các thành phần có trong Cookie</h2><blockquote><ul><li>name : String</li><li>value : String</li><li>httpOnly : Boolean</li><li>Secure : Boolean</li><li>maxAge : Option[Int]</li><li>sameSite : Option[SameSite]</li><li>domain : Option[String]</li><li>path : String</li></ul></blockquote><p><code>name</code> và <code>value</code> là giá trị thông tin cookie cần lưu.</p><blockquote><pre><code>  name = access_token  value = Bearer MTIzNDU2Nzphc2RmZw==</code></pre></blockquote><p><code>httpOnly</code>: Đảm bảo Cookie chỉ được sử dụng trong 1 HTTP. Sẽ không thể dùng Javascript để lấy được thông tin cookies (document.cookie). Với httpOnly có thể prevent tấn công XSS từ hacker</p><p><code>Secure</code>: Đảm bảo Cookies luôn được mã hóa khi chuyển từ Client lên Server bằng cách chỉ gửi Cookies đi nếu kết nối SSL được sử dụng (Https), với Http Cookie sẽ không được gửi</p><p><code>maxAge</code>: thời gian tồn tại của Cookie. được tính bằng giây (s).</p><blockquote><pre><code>  maxAge = Some ( 1 * 60 * 60)</code></pre></blockquote><p>Chú ý: Nếu giá trị expires cũng được define thì maxAge sẽ được ưu tiên cao hơn =&gt; thời gian tồn tại sẽ tính theo maxAge</p><p><code>Samesite</code>: Giúp bảo vệ khỏi tấn công Cross-site request forgery attacks (CSRF). Có 3 giá trị: Strick, Lax, None</p><p><code>Domain</code>: Với thuộc tính này sẽ giúp define cho việc cookie sẽ được lưu cho những domain nào.</p><blockquote><p>VD: có 3 domain như bên dưới.</p><ul><li><a href="http://batdongsan.com">batdongsan.com</a></li><li><a href="http://aip-frontend-dev.batdongsan.com">aip-frontend-dev.batdongsan.com</a></li><li><a href="http://aip-cms-dev.batdongsan.com">aip-cms-dev.batdongsan.com</a></li></ul><p>Note 1 : Mặc định nếu thuộc tính domain để trống thì các cookie sẽ không được share cho nhau. Cookie chỉ được sử dụng với duy nhất domain mà tạo ra nó</p><p>Note 2: Nếu domain = Some(“.batdongsan.com”) hoặc Some(“<a href="http://batdongsan.com">batdongsan.com</a>”) thì cookie của cả 3 domain sẽ được dùng chung. chỉ cần 1 domain thay đổi cookie là những domain khác cũng nhận được sự thay đổi này</p><p>Path: Với thuộc tính này sẽ define những path nào mới được dùng cookie. Mặc định sẽ là “/”</p><p>VD: path=”/admin” thì chỉ khi nào request từ <a href="http://domain.com/admin">domain.com/admin</a> thì cookie mới được kèm theo, còn <a href="http://domain.com/user">domain.com/user</a> thì không</p></blockquote><h2 id="4-Cach-tao-Cookie">4. Cách tạo Cookie</h2><ul><li>Tạo bằng webserver: tomcat, nginx…</li><li>Tạo bằng framework: Play framework, spring…</li><li>Tạo bằng JS: document.cookie=”access_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9″</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Scala </tag>
            
            <tag> JS </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLID-principles</title>
      <link href="/Technology/Java/Scala/2017/12/09/SOLID-principles/"/>
      <url>/Technology/Java/Scala/2017/12/09/SOLID-principles/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SOLID-la-gi">1. SOLID là gì?</h2><ul><li>Là những nguyên lý thiết kế trong OOP. Nó giúp project dễ hiểu, dễ maintenance, dễ testing và linh hoạt hơn. Nên khi scale project cũng sẽ dễ dàng hơn</li><li>Nó là viết tắt của 5 nguyên lý sau:<ul><li>Single responsibility - Đơn chức năng</li><li>Open/closed</li><li>Liskov substitution (LSP) – thay thế</li><li>Interface segregation (ISP) – phân tách</li><li>Dependency Inversion</li></ul></li></ul><p><img src="/images/SOLID-principles.jpeg" alt="SOLID-principles"></p><h2 id="2-Single-responsibility-principle">2. Single responsibility principle</h2><blockquote><p><strong>A class should have one and only one reason to change, meaning that a class should have only one job.</strong></p><p>Nghĩa là: Một class chỉ nên giữ một trách nhiệm duy nhất. Chỉ có thể sửa đổi class với một lý do duy nhất</p></blockquote><p>Lợi ích:</p><ul><li>Testing: số test cases sẽ ít hơn</li><li>Lower coupling: các class ít phụ thuộc vào nhau.</li><li>Organization:<ul><li>Tổ chức các class nhỏ sẽ dễ dàng cho việc tìm kiếm hơn trong một class lớn.</li><li>Code bớt cồng kềnh hơn, khi thay đổi code sẽ bớt khó khăn và giảm impact đến features khác.</li></ul></li></ul><p>Ví dụ:</p><blockquote><pre><code>  public class Book &#123;      private String name;      private String content;      public boolean isWordInContent(String w)&#123;          return content.contains(w);      &#125;      // method này đã vi phạm nguyên tắc Single responsibility.      // Cách giải quyết là viết method này sang BookPrinter.java      // Ở BookPrinter chúng ta có thể thêm các phương thức khác như printContentToScreen,...      public void printContentToConsole() &#123;         // do something      &#125;  &#125;</code></pre></blockquote><p>Cách khắc phục là tạo ra class mới chỉ xử lý việc hiển thị nội dung qua các phương tiện khác</p><blockquote><pre><code>  public class BookPrinter &#123;      public void printContentToConsole(String text) &#123;          // do something      &#125;      public void printContentToScreen(String text) &#123;          // do something      &#125;  &#125;</code></pre></blockquote><h2 id="3-Open-closed-principle">3. Open/closed principle</h2><blockquote><p><strong>Objects or entities should be open for extension but closed for modification.</strong></p><p>Nghĩa là: Một class có thể mở rộng thoải mái, nhưng không sửa đổi nó.</p></blockquote><p>Lợi ích:</p><ul><li>Ngăn sửa đổi những code đã có để không phát sinh bugs cho những đoạn code đang sử dụng.</li></ul><p>Ví dụ:</p><p>Vẫn với class <code>Book</code> như phía trên, nhưng hôm nay chúng ta nhận được yêu cầu cần thêm một loại sách <code>ebook</code> vào trong program. Loại sách này sẽ có thêm attribute là <code>link</code> để thể hiện link của cuốn sách.Thay vì thêm trực tiếp <code>link</code> vào class <code>Book</code>, chúng ta nên tạo ra class <code>EBook</code> extend lại <code>Book</code>. Điều này giúp chúng ta không cần quan tâm đến những đoạn code mà <code>Book</code> được sử dụng</p><blockquote><pre><code>  public class EBook extends Book&#123;      private String link;  &#125;</code></pre></blockquote><h2 id="4-Liskov-substitution-principle-LSP">4. Liskov substitution principle (LSP)</h2><blockquote><p><strong>if class A is a subtype of class B, we should be able to replace B with A without disrupting the behavior of our program.</strong></p><p>Nghĩa là: Nếu class A là 1 subtype của class B, thì B có thể được thay thế bằng A mà không làm thay đổi tính đúng đắn của chương trình</p></blockquote><p>Lợi ích:</p><ul><li>Giúp đảm bảo class cha và class con luôn luôn nhất quán với nhau.</li></ul><p>Biểu hiện:</p><ul><li>class con <code>Override method</code> class cha nhưng thực hiện chức năng khác.</li><li>class con <code>Override method</code> class cha nhưng throw exception.</li><li>class con <code>Override method</code> class cha nhưng không làm gì cả.</li></ul><p>Ví dụ:</p><blockquote><pre><code>  public abstract class Book &#123;      protected String name;      protected String content;      public abstract String preview();vd  &#125;  public class EBook extends Book &#123;      private String link;      @Override      public String preview() &#123;          return this.content.substring(0, 200);      &#125;  &#125;</code></pre></blockquote><blockquote><pre><code>  public class PaperBook extends Book&#123;      // method này đã vi phạm LSP.      // vì mặc dù PaperBook là subtype của Book      // tuy nhiên method preview lại không thực hiện chức năng như class Book define      @Override      public String preview() &#123;          return null;      &#125;  &#125;</code></pre></blockquote><p>Cách khắc phục là ta để method <code>preview()</code>chỉ define ở trong class <code>Ebook</code></p><h2 id="5-Interface-segregation-principle-ISP">5. Interface segregation principle (ISP)</h2><blockquote><p><strong>Larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them</strong></p><p>Thay vì dùng 1 interface lớn, ta nên tách thành nhiều interface nhỏ</p></blockquote><p>Lợi ích:</p><ul><li>Có thể đảm bảo rằng việc implement các class chỉ cần quan tâm đến các method mà chúng quan tâm.</li></ul><p>Ví dụ:</p><blockquote><pre><code>  public interface Repository &#123;      public Book resolveBy(long id);      public List&lt;Book&gt; resolveAll();      public boolean resolveBy(Book book);  &#125;</code></pre></blockquote><p>Vì có thể có những class chỉ sử dụng đến các chức năng resolve mà không dùng đến chức năng update. Nên để không vi phạm ISP ta nên tách nhỏ <code>Repository</code> thành các interface nhỏ hơn.</p><blockquote><pre><code>  public interface ResolveFeatureRepository &#123;      public Book resolveBy(long id);  &#125;  public interface ResolveAllFeatureRepository &#123;      public List&lt;Book&gt; resolveAll();  &#125;  public interface UpdateFeatureRepository &#123;      public boolean update(Book book);  &#125;  public interface BookRepository extends ResolveFeatureRepository, UpdateFeatureRepository &#123;&#125;  public class BookRepositoryImpl implements BookRepository &#123;      @Override      public Book resolveBy(long id) &#123;          // do something      &#125;      @Override      public boolean update(Book book) &#123;          // do something      &#125;  &#125;</code></pre></blockquote><h2 id="6-Dependency-Inversion-Principle">6. Dependency Inversion Principle</h2><blockquote><p><strong>High-level modules should not depend on low-level modules. Both should depend on abstractions.</strong></p><p>Nghĩa là: Các module cấp cao không nên phụ thuộc vào các modules cấp thấp. Cả 2 nên phụ thuộc vào abstraction.</p><p><strong>Abstractions should not depend upon details. Details should depend upon abstractions.</strong></p><p>Nghĩa là: Interface (abstraction) không nên phụ thuộc vào chi tiết, mà ngược lại. (Các class giao tiếp với nhau thông qua interface, không phải thông qua implementation.)</p></blockquote><p>Để tránh sự phụ thuộc vào nhau, các module cấp cao nên tạo ra interface, các module cấp thấp sẽ implements các interface đó.</p><p>Ví dụ:</p><p>Chúng ta có class <code>Windows98Machine</code> với <code>StandardKeyboard</code> và <code>monitor</code>.</p><blockquote><pre><code>  public class Windows98Machine &#123;      private final StandardKeyboard keyboard;      private final Monitor monitor;      public Windows98Machine() &#123;          monitor = new Monitor();          keyboard = new StandardKeyboard();      &#125;  &#125;</code></pre></blockquote><p>Tuy nhiên đoạn code trên có vấn đề trong việc khởi tạo <code>monitor</code> và <code>keyboard</code> cố định với từ khóa <code>new</code>. Nó làm đoạn cả <code>Windows98Machine, StandardKeyboard, Monitor</code> dính chặt với nhau.Nếu muốn thay keyboard hay monitor thành một loại khác sẽ khiến chúng ta phải thay đổi code nhiều nơi. Chúng ta có thế sửa thành</p><blockquote><pre><code>  public interface Keyboard &#123; &#125;  public class Windows98Machine&#123;      private final Keyboard keyboard;      private final Monitor monitor;      public Windows98Machine(Keyboard keyboard, Monitor monitor) &#123;          this.keyboard = keyboard;          this.monitor = monitor;      &#125;  &#125;  public class StandardKeyboard implements Keyboard &#123; &#125;</code></pre></blockquote><p>Việc này làm giúp code của chúng ta lower coupling, dễ thay đổi, ít bugs hơn.</p><h2 id="7-Refer">7. Refer</h2><p><a href="https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/solid">https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/solid</a></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Scala </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String vs StringBuilder vs StringBuffer in Java</title>
      <link href="/Technology/Java/Scala/2017/11/01/string-vs-stringbuilder-stringbuffer/"/>
      <url>/Technology/Java/Scala/2017/11/01/string-vs-stringbuilder-stringbuffer/</url>
      
        <content type="html"><![CDATA[<p>Khi làm việc với chuỗi trong Java chúng ta có 3 options: String, StringBuilder, StringBuffer.</p><ul><li><p>Với String là immutable. Khi một chuỗi String được tạo ra sẽ không thể thay đổi được giá trịcủa nó.</p></li><li><p>Với StringBuilder và StringBuffer là mutable. Nó được tạo ra để giúp cho việc thay đổi giá trịcủa chuỗi. Nhưng StringBuffer thread safe còn String Builder thì không.</p></li></ul><p><img src="/images/string-stringbuilder-stringbuffer.jpeg" alt="string-stringbuilder-stringbuffer.jpeg">Để làm rõ hơn chúng ta cùng tìm hiểu chi tiết về chúng.</p><h2 id="1-String-Concatenation">1. String Concatenation</h2><p>Ta xét ví dụ sau:</p><blockquote><pre><code>  String query = &quot;SELECT username FROM&quot; + &quot; Users &quot; + &quot; WHERE 1 = 1&quot;;  query += &quot; AND age &gt; 20&quot;;  query += &quot; AND gender = 1&quot;;  query = query.concat(&quot; AND is_delete = 0&quot;);</code></pre></blockquote><h3 id="a-String-Concatenation-voi-operator">a. String Concatenation với <code>+</code> operator</h3><blockquote><pre><code>  String query = &quot;SELECT username FROM&quot; + &quot; Users &quot; + &quot; WHERE 1 = 1&quot;;</code></pre></blockquote><p>Với câu lệnh này thì Java compiler sẽ convert chúng thành:</p><blockquote><pre><code>  String query = (new StringBuilder()).append(&quot;SELECT username FROM&quot;)      .append(&quot; Users&quot;)      .append(&quot; WHERE 1 = 1&quot;).toString();  </code></pre></blockquote><p>Thay vì việc tạo ra nhiều ô chỉ nhớ khác nhau để lưu các String và sau đó cộng chúng lại với nhau. Compiler của Java đã làm việcrất hiệu quả để tối ưu được bộ nhớ.</p><blockquote><p>Note:Có thể dùng <code>+</code> để concat các giá trị primitive khác với String. Compiler cũng sẽ convert chúng như trên.</p><pre><code>  String info = &quot;I am &quot; + 25 + &quot;years old&quot;;</code></pre></blockquote><h3 id="b-String-Concatenation-bang-operator">b. String Concatenation bằng <code>+=</code> operator</h3><blockquote><pre><code>  query += &quot; AND age &gt; 20&quot;;  query += &quot; AND gender = 1&quot;;</code></pre></blockquote><p>Java compiler sẽ convert chúng thành:</p><blockquote><pre><code>  String query = &quot;SELECT username FROM&quot; + &quot; Users &quot; + &quot; WHERE 1 = 1&quot;;  StringBuilder tmp;  tmp = new StringBuilder();  tmp.append(query);  tmp.append(&quot; AND age &gt; 20&quot;);  query = tmp.toString();  tmp = new StringBuilder();  tmp.append(query);  tmp.append(&quot; AND gender = 1&quot;);  query = tmp.toString();</code></pre></blockquote><p>Như vậy sẽ tạo ra rất nhiều instant của StringBuilder. Khi số lượng chuỗi cộng ít thì có thể không vấn đề.Nhưng khi số lượng lớn nên sẽ rất ảnh hưởng đến performance. (Xem kết quả thực nghiệm phía dưới)</p><h3 id="c-String-Concatenation-bang-concat-operator">c. String Concatenation bằng concat() operator</h3><blockquote><pre><code>  query = query.concat(&quot; AND is_delete = 0&quot;);</code></pre></blockquote><p>Vì concat() của String trong Java được thực hiện bằng cách:</p><ul><li>Tạo ra một <code>char Arrays</code> mới có size bằng số ký tự của 2 chuỗi.</li><li>Copy giá trị của chuỗi 1 và chuỗi 2 vào <code>char Arrays</code> mới vừa được tạo.</li><li>Trỏ lại biến vào String mới vừa được tạo ra.</li></ul><blockquote><p>Note:Với cách dùng concat() gây tốn bộ nhớ và performance khi phải tạo 1 ô nhớ mới.</p></blockquote><h2 id="2-StringBuilder-va-StringBuffer">2. StringBuilder và StringBuffer</h2><ul><li>StringBuilder/StringBuffer sử dụng <code>char Array</code> là mutable khác với <code>char Array</code> của String là immutable.</li><li>Khi cộng chuỗi, StringBuilder/StringBuffer sẽ thực hiện việc thay đổi giá trị của <code>char Array</code> thay vì tạo ra liên tục các instant mới.</li></ul><p>=&gt; Chính vì thế khi cộng chuỗi được thực hiện nhiều lần StringBuilder/StringBuffer cho hiệu năng vượt trội hơn hẳn String.</p><h2 id="3-Ket-luan">3. Kết luận</h2><ul><li>Nếu có thể hãy sử dụng concat by <code>+</code> operator của String để có được hiệu năng và clean code tốt nhất.</li><li>Nếu việc cộng chuỗi được lặp lại nhiều lần, ưu tiên hàng đầu là StringBuilder (/StringBuffer nếu cần thread-safe).</li><li>Hạn chế tối đa việc sử dụng <code>+=</code> operator của String</li></ul><h2 id="4-Thu-nghiem">4. Thử nghiệm</h2><blockquote><pre><code>  String c = &quot;&quot;;  // StringBuilder c = new StringBuilder(&quot;&quot;);  for (long i = 0; i &lt; 100000L; i++) &#123;      c = c.concat(b); // take 10s  //    c += b; // take 40s  //    c.append(b) // 15ms  &#125;</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Scala </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String pool</title>
      <link href="/Technology/Java/Scala/2017/08/08/string-pool/"/>
      <url>/Technology/Java/Scala/2017/08/08/string-pool/</url>
      
        <content type="html"><![CDATA[<h2 id="1-String-la-gi">1. String là gì?</h2><p>Chúng ta chắc hẳn đã rất quen thuộc với String khi code Java. Với định nghĩa <a href="https://docs.oracle.com/javase/tutorial/java/data/strings.html">String</a> từ Oracle như sau:</p><blockquote><p>Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects</p></blockquote><p>Có một vài chú ý với String như sau:</p><ul><li>String là 1 reference type</li><li>Là immutable (không thể thay đổi được giá trị, ô chỉ nhớ của n)</li><li>Có thể tạo mới 1 String theo 2 cách:<ul><li>String literal</li><li>new operator</li></ul></li></ul><p>Bài toán đặt ra: vì String là immutable, khi tạo quá nhiều String, liệu có dễ xảy ra tràn bộ nhớ Heap không?=&gt; Câu trả lời chính là String Pool</p><h2 id="2-String-pool-la-gi">2. String pool là gì?</h2><ul><li>String Pool là 1 phân vùng nhỏ nằm trong bộ nhớ Heap chứa các Strings.</li><li>Nó được tạo ra với mục đích tối ưu lưu trữ và dùng vùng nhớ khi khai báo String từ đó giúp hạn chế tình trạng tràn bộ nhớ Heap</li></ul><h2 id="3-Cach-hoat-dong-cua-String-pool">3. Cách hoạt động của String pool</h2><p><img src="/images/string-constant-pool-in-java.png" alt="string-constant-pool-in-java"></p><h3 id="a-Tao-String-moi-bang-String-literal">a. Tạo String mới bằng String literal</h3><p>JVM sẽ check trong String pool xem có ô nhớ nào có giá trị giống với giá trị cần tạo hay không? Nếu tồn tại trong pool rồi nó sẽ tham chiếu đến ô chỉ nhớ vừa tìm được, ngược lại, nếu không tìm thấy ô nhớ nào có giá trị giống giá trị cần tạo, JVM sẽ lưu giá trị mới vào trong pool và tiến hành trỏ vào ô chỉ nhớ mới tạo đó.</p><blockquote><p>Ví dụ:</p><pre><code>  String s1 = “java”;  String s2 = “java”;  s1 == s2 //true</code></pre><p>Khi khai báo s1, JVM tìm kiếm trong pool và không thấy có ô nhớ nào có giá trị là “java” cả. JMV sẽ tạo mới 1 ô nhớ trong pool có giá trị là “java”.</p><p>Khi khai báo s2, JVM tìm kiếm trong pool và thấy có 1 ô nhớ có giá trị là “java” được JVM tạo ra trước đó khi khai báo s1. Vì thế JVM sẽ trỏ s2 vào ô chỉ nhớ vừa tìm được thay vì tạo ra 1 ô nhớ mới</p></blockquote><h3 id="b-Tao-String-moi-bang-new-operator">b. Tạo String mới bằng new operator</h3><p>JVM sẽ luôn tạo ra 1 ô nhớ mới trong Heap memory (dù đã tồn tại những ô nhớ có cùng giá trị)</p><blockquote><p>Ví dụ:</p><pre><code>  String s3 = new String(“java”);  String s4 = new String(“java”);  s3 == s4 //false</code></pre><p>Khi khai báo s3 hay s4, JVM luôn luôn tạo ra 2 ô nhớ khác nhau trong Heap memory để tham chiếu đến.</p></blockquote><h3 id="c-Chung-ta-nen-tao-moi-1-String-bang-cach-nao">c. Chúng ta nên tạo mới 1 String bằng cách nào?</h3><p>Chúng ta nên tạo mới một String bằng String literal vì chúng dễ đọc, ngắn gọn, tăng khả năng optimize của JVM. (mặc dù tạo bằng new operator sẽ nhanh hơn vì không phải kiểm tra trong String Pool)</p><h2 id="4-Vay-tai-sao-String-la-immutable">4. Vậy tại sao String là immutable?</h2><ul><li>Với một Object là immutable sẽ giúp thread safe và khi làm việc multi-threading. Chúng sẽ không bị thay đổi bởi các thread dùng chung object.</li><li>Các String được reference chung vào ô chỉ nhớ trong String Pool, nên nếu String là mutable sẽ dẫn đến sai giá trị của những biến khác đang được trỏ vào ô nhớ chung đó.</li><li>Để sử dụng Hashcode caching. Khi tạo một String thì JDK sẽ tự động override lại hashCode() theo giá trị của String đó và lưu chúng vào bộ nhớ đệm và sử dụng lại trong những lần sau khi nó phải tính toán với giá trị tương tự.hashCode() sẽ được sử dụng với các Map implementation như HashMap, HashTable, HashSet… để so sánh giá trị của Object.</li><li>Vấn đề về bảo mật. Khi String được sử dụng để lưu giá trị cho username, url, path… Khi các bước validate với String đó verified hợp lệnhưng sau đó String được thay đổi thì rất nguy hiểm.</li></ul><blockquote><pre><code>  boolean deleteProductBy(String ownername)&#123;  if (!isAdmin(ownername)) &#123;      throw new PermissionException();  &#125;      //ownername được thay đổi trước khi deleteAllProduct được gọi      deleteAllProduct(ownername)  &#125;</code></pre></blockquote><h2 id="5-Chu-y-voi-String-trong-Scala">5. Chú ý với String trong Scala</h2><ul><li>String trong Scala sẽ tương tứng với String trong Java</li><li>Khi so sánh 2 String trong Scala sẽ dùng phương thức <code>==</code>. Phương thức này sẽ tiến hành check <code>null</code> trước sau đó sẽ gọi <code>equals</code> để so sánh.<br>Chính vì thế khi so sánh 1 String <code>== null</code> trong Scala sẽ không bị <code>NullPointerException</code>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Scala </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
