<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>String pool</title>
      <link href="/Technology/Java/Scala/2021/07/22/string-pool/"/>
      <url>/Technology/Java/Scala/2021/07/22/string-pool/</url>
      
        <content type="html"><![CDATA[<h1>1. String là gì?</h1><p>Chúng ta chắc hẳn đã rất quen thuộc với String khi code Java. Với định nghĩa <a href="https://docs.oracle.com/javase/tutorial/java/data/strings.html">String</a> từ Oracle như sau:</p><blockquote><p>Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects</p></blockquote><p>Có một vài chú ý với String như sau:</p><ul><li>String là 1 reference type</li><li>Là immutable (không thể thay đổi được giá trị, ô chỉ nhớ của n)</li><li>Có thể tạo mới 1 String theo 2 cách:<ul><li>String literal</li><li>new operator</li></ul></li></ul><p>Bài toán đặt ra: vì String là immutable, khi tạo quá nhiều String, liệu có dễ xảy ra tràn bộ nhớ Heap không?=&gt; Câu trả lời chính là String Pool</p><h1>2. String pool là gì?</h1><ul><li>String Pool là 1 phân vùng nhỏ nằm trong bộ nhớ Heap chứa các Strings.</li><li>Nó được tạo ra với mục đích tối ưu lưu trữ và dùng vùng nhớ khi khai báo String từ đó giúp hạn chế tình trạng tràn bộ nhớ Heap</li></ul><h1>3. Cách hoạt động của String pool</h1><p><img src="/images/string-constant-pool-in-java.png" alt="string-constant-pool-in-java"></p><h3 id="a-Tao-String-moi-bang-String-literal">a. Tạo String mới bằng String literal</h3><p>JVM sẽ check trong String pool xem có ô nhớ nào có giá trị giống với giá trị cần tạo hay không? Nếu tồn tại trong pool rồi nó sẽ tham chiếu đến ô chỉ nhớ vừa tìm được, ngược lại, nếu không tìm thấy ô nhớ nào có giá trị giống giá trị cần tạo, JVM sẽ lưu giá trị mới vào trong pool và tiến hành trỏ vào ô chỉ nhớ mới tạo đó.</p><blockquote><p>Ví dụ:</p><p>String s1 = “java”;</p><p>String s2 = “java”;</p><p>Khi khai báo s1, JVM tìm kiếm trong pool và không thấy có ô nhớ nào có giá trị là “java” cả. JMV sẽ tạo mới 1 ô nhớ trong pool có giá trị là “java”.</p><p>Khi khai báo s2, JVM tìm kiếm trong pool và thấy có 1 ô nhớ có giá trị là “java” được JVM tạo ra trước đó khi khai báo s1. Vì thế JVM sẽ trỏ s2 vào ô chỉ nhớ vừa tìm được thay vì tạo ra 1 ô nhớ mớiChính vì thế khi so sánh s1 == s2 //true</p></blockquote><h3 id="b-Tao-String-moi-bang-new-operator">b. Tạo String mới bằng new operator</h3><p>JVM sẽ luôn tạo ra 1 ô nhớ mới trong Heap memory (dù đã tồn tại những ô nhớ có cùng giá trị)</p><blockquote><p>Ví dụ:</p><p>String s3 = new String(“java”);</p><p>String s4 = new String(“java”);</p><p>Khi khai báo s3 hay s4, JVM luôn luôn tạo ra 2 ô nhớ khác nhau trong Heap memory để tham chiếu đến.Vì thế: s3 == s4 //false</p></blockquote><h3 id="c-Chung-ta-nen-tao-moi-1-String-bang-cach-nao">c. Chúng ta nên tạo mới 1 String bằng cách nào?</h3><p>Chúng ta nên tạo mới một String bằng String literal vì chúng dễ đọc, ngắn gọn, tăng khả năng optimize của JVM. (mặc dù tạo bằng new operator sẽ nhanh hơn vì không phải kiểm tra trong String Pool)</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Java </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Scala </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL statement processing</title>
      <link href="/Technology/Oracle/MySQL/2021/07/14/sql-statement-processing/"/>
      <url>/Technology/Oracle/MySQL/2021/07/14/sql-statement-processing/</url>
      
        <content type="html"><![CDATA[<h1>1. Trình tự xử lý câu lệnh SQL</h1><p><img src="/images/sql-state-process-phase.png" alt="sql-state-process-phase"></p><p>Parse Phase</p><ul><li>Check <code>Execute Plan(EP)</code> đã tồn tại trên <code>Shared Pool</code> chưa? Nếu có rồi thì sang bước <code>Bind</code></li><li>Phân tích, kiểm tra cú pháp, quyền truy cập</li><li>Tạo EPExecute Plan: Oracle Server sẽ lên kế hoạch để thực thi câu lệnh sao cho chi phí bỏ ra là thấp nhất thông qua Trình tối ưu câu lệnh (Optimizer)</li></ul><h1>2. Trình tối ưu câu lệnh(Optimizer)</h1><ul><li>Giúp tạo ra EP tốt nhất cho câu lệnh</li><li>Có 2 phương pháp:<ul><li>Rule Based Optimizer (RBO): Dùng lược đồ phân rank các phương thức truy cập. Rank càng thấp thì càng được ưu tiên.VD: single row by rowId có rank = 1; Full table scan có rank = 15</li><li>Cost Based Optimizer (CBO): Dựa vào các thông tin: CPU, IO… để tính Cost. sẽ chọn EP có Cost nhỏ nhất.</li></ul></li></ul><h1>3. Các cách truy cập dữ liệu</h1><ul><li>Physical:</li></ul><blockquote><p>Truy cập DB theo DB_Block (disk read). Tốn nhiều thời gian và resources vì cần IO disk</p></blockquote><ul><li>Logical: Đọc block data từ Buffer Cache</li></ul><blockquote><ul><li>Table Access Full: duyệt tuần tự từng bản ghi. Dùng khi:<ul><li>Không có Index hoặc Index không dùng được</li><li>Dù có Index, nhưng tập data trả về lớn</li><li>Số lượng bản ghi ít</li></ul></li><li>Index scan: Chỉ đọc trên Index</li><li>Table Access by Index RowId: Duyệt Index =&gt; duyệt rowId</li></ul></blockquote><h1>4. Cơ chế thực thi lệnh Join</h1><ul><li>Optimizer sẽ tự chọn các thuật toán để JOIN table sao cho chi phí là thấp nhất</li><li>Các loại:</li></ul><blockquote><ul><li>Nested Loop Join</li><li>Sort Merge Join</li><li>Hash Join</li></ul></blockquote><h3 id="a-Nested-Loop-Join">a. Nested Loop Join</h3><ul><li>Implement: Khi Join T1 - inner table với T2 - outer table. Từng row trong T1 sẽ so sánh với tất cả rows trên T2</li><li>Dùng khi: T1 nhỏ, và T2 được sort theo trường được Join</li><li>Thể hiện: Câu lệnh hiệu quả, chi phí thấp</li></ul><h3 id="b-Merge-Join">b. Merge Join</h3><ul><li>Implement: Cả 2 table T1 vs T2 phải sort theo trường được Join. Sau đó cả 2 bảng sẽ đọc từ đầu và cùng tiến lên song song. Có thể sẽ kết thúc nếu quét hết data của table nhỏ.</li><li>Trong trường hợp 1 trong 2 table không được sắp xếp thì Optimizer sẽ sort table còn lại và dùng Merge Join hoặc có thể dùng Hash Join</li><li>Hiệu quả: Tập dữ liệu trả về lớn</li></ul><h3 id="c-Hash-Join">c. Hash Join</h3><p><img src="/images/hash-join-implement.png" alt="hash-join-implement"></p><ul><li>Hiệu quả: Tập dữ liệu trả về lớn và field Join không được sắp xếp</li><li>So với Merge Join:<ul><li>Hash Join sẽ nhanh hơn so với việc phải sắp xếp lại table.</li><li>Tốn CPU, Memory hơn do phải tạo bảng + hash</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> Oracle </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Mysql </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Index trong MySQL</title>
      <link href="/Technology/MySQL/2021/07/14/index-in-mysql/"/>
      <url>/Technology/MySQL/2021/07/14/index-in-mysql/</url>
      
        <content type="html"><![CDATA[<h1>1. Index là gì?</h1><blockquote><p>“Indexes are special lookup tables that the database search engine can use to speed up data retrieval. Simply put, an index is a pointer to data in a table. An index in a database is very similar to an index in the back of a book”</p></blockquote><p>Hay hiểu đơn giản là dùng với mục đích là tăng tốc độ tìm kiếm</p><h1>2. Khi nào nên sử dụng index?</h1><ul><li>Table có nhiều dữ liệu</li><li>Lấy dữ liệu &lt; 5% tổng data</li><li>Bảng ít update, delete, insert data</li><li>Column ít giá trị null</li><li>Column thường được sử dụng làm điều kiện khi truy vấn</li><li>Nên đánh index trên khóa ngoại</li><li>Selectivity cao (= cardinality/(number of records) * 100% )=&gt; Những column Unique, Sorted</li></ul><blockquote><p>cardinality: là số lượng bản ghi duy nhất xuất hiện trong table cho column đó.Ví dụ: table Employee với column sex, cột này chỉ có thể có 2 giá trị là Male và Female, như vậy cardinality cho column sex sẽ là 2, vì ta chỉ có 2 giá trị duy nhất xuất hiện ở cột column</p></blockquote><h1>3. Các loại index thường dùng</h1><ul><li>Btree Index (default và phổ biến nhất)</li><li>Bitmap Index</li><li>Index-organized table</li><li>Hash clusters</li><li>Index clusters</li><li>Nested table</li><li>Reverse Key Index</li></ul><h1>4. B-Tree index</h1><p><img src="/images/b-tree-index.png" alt="B-tree-index"></p><ul><li>Là index mặc định trong Database</li><li>Index sẽ bị xóa khi table bị xóa</li><li>Gồm 3 phần: Root, Branch, Leaf</li></ul><blockquote><p>Leaf gồm:</p><ul><li>Index entry header: thông tin lưu trữ số column và thông tin khoá của các hàng trong bảng.</li><li>Key column length_value pair: chứa thông tin về kích thước column tham gia vào khoá và tiếp theo là kích thước của đó.</li><li>ROWID: là giá trị của ROWID chứa giá trị khoá của index</li></ul></blockquote><blockquote><p>Các lệnh DML(Data manipulation Language)</p><ul><li>Insert: Thêm index entry</li><li>Delete: Disable index entry</li><li>Update: Disable =&gt; insert new index entry</li></ul></blockquote><h3 id="a-Dac-diem">a. Đặc điểm</h3><ul><li>Giá trị khóa sẽ lặp đi lặp lại nếu có nhiều giá trị trùng nhau</li><li>Với composite index trên nhiều column, khi tìm kiếm nó sử dụng 2 column đầu tiên để tìm kiếm, tìm kiếm theo thứ tự đánh index=&gt; column unique, nhiều data thì nên đánh trước</li><li>Không lưu dữ liệu có giá trị null</li></ul><h3 id="b-Index-khong-duoc-ap-dung-khi">b. Index không được áp dụng khi</h3><ul><li>Dùng cho các toán tử &lt;&gt;, != và NOT IN, NOT LIKE</li><li>Kết hợp toán tử Like có ‘%’ ở đầu.</li><li>Kết hợp các thành phần khác (giá trị, biểu thức…)=&gt; function-base Index. VD: CREATE INDEX idx ON emp (UPPER(emp_name));</li><li>So sánh với giá trị khác kiểu</li></ul><h3 id="c-Rebuild">c. Rebuild</h3><p>Tại sao cần rebuild:</p><blockquote><ul><li>Height index càng nhỏ thì tìm càng nhanh. Nếu Height = 3 thì khi hoạt động index cần phải đọc ít nhất 3 block là root block, branch block và leaf block</li><li>Việc delete, update dữ liệu nhiều =&gt; deleted leaf nhiều =&gt; tree mất cân bằng</li></ul></blockquote><p>Khi nào nên rebuild</p><blockquote><ul><li>Height &gt; 4, deleted leaf &gt; 20%</li></ul></blockquote><p>Chú ý:</p><blockquote><ul><li>Nên run lại câu lệnh statistic để cập nhật lại thông tin statistic và EP sauANALYZE TABLE &lt;TBL_NAME&gt; COMPUTE STATISTICS</li></ul></blockquote><h3 id="d-Cac-cau-lenh-hay-dung">d. Các câu lệnh hay dùng</h3><blockquote><ul><li>Create Index: CREATE INDEX index_name ON table (column1, column2…) [ONLINE];</li><li>Rename: ALTER INDEX index RENAME TO &lt;new_index_name&gt;;</li><li>Drop Index: DROP INDEX index_name;</li><li>Rebuild Index: ALTER INDEX DEPT_LOCATION_IX REBUILD [ONLINE];</li></ul></blockquote><p>Note:</p><ul><li>Thông thường trong khi tạo index, các câu lệnh DML tác động lên cột dữ liệu có liên quan đều tạm thời không thực hiện được cho đến khi hoàn tất việc tạo index.</li><li>Để có thể cho phép thực hiện câu lệnh DML tác động lên các cột dữ liệu được index, Oracle có hỗ trợ Index online (Index trực tuyến) khi này, ta cần bổ sung thêm mệnh đề ONLINE vào trong câu lệnh.</li></ul><h1>5. Refer</h1><ul><li><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Encoding</title>
      <link href="/Technology/common/2021/07/14/encoding/"/>
      <url>/Technology/common/2021/07/14/encoding/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/unicode.png" alt="Unicode"></p><h1>1.Thuật ngữ</h1><ul><li><p>encode: dùng 1 thứ gì đó để để thể hiện cho 1 thứ khác. VD: 01100010 là b</p></li><li><p>Encoding: là tập hợp các quy tắc để thực hiện việc chuyển đổi đó. VD: mã hóa ký tự sang bit</p></li><li><p>decode: từ bit giải mã sang ký tự</p></li><li><p>character set, charset: tập hợp các ký tự có thể được encode</p></li><li><p>code page: là bảng mapping bit với ký tự</p></li></ul><h1>2.Overview</h1><p>Máy tính chỉ có thể làm việc và hiểu được với bit.</p><p>Để biểu diễn bất cứ thứ gì thì ta cần phải có quy tắc để chuyển đổi chúng thành bit và ngược lại. Quy tắc đó chính là encoding scheme (lược đồ mã hóa) gọi tắt là encoding.</p><blockquote><p>VD: trong encoding ASCII thì: 1100010 là b ; 01101001 là i ; 01110100 là t</p></blockquote><p>Vì 1 byte(8 bits) là không đủ để mapping cho tất cả các ngôn ngữ trên thế giới (tiếng Trung, Nhật, Ấn Độ, Pháp…) nên người ta đã tạo rất nhiều loại encoding phù hợp với ngôn ngữ của họ. Và họ đã nghĩ tới việc tăng 1 ký tự tương ứng với 2 bytes (16 bits) VD: BIG-5, GB18030</p><p>Con người có thể dùng hệ bát phân, thập phân và thập lục phân để viết cho gọn. Còn máy tính luôn luôn sử dụng hệ nhị phân. Quá trình đóng gói và truyền qua internet cũng là tổ hợp các gói tin và gửi đi.</p><h1>3.Unicode</h1><p>Unicode ra đời để hợp nhất tất cả các chuẩn mã. Unicode là 1 encode schema nhưng không phải là 1 loại encoding. Nó tạo ra 1 code page chứa đến 1,114,112 ký tự. Nó có thể biểu diễn cho tất cả các ngôn ngữ, ký tự trên thế giới.</p><p>Bài toán đặt ra: để biểu diễn hết tất cả các ký tự trong unicode, nếu encoding dùng 2 bytes (2^16 ký tự) thì không đủ. còn 3 bytes (2^24) thì đủ nhưng ngta không dùng 3 bytes. nên 4 bytes đã được chọn.</p><p>Với encoding UTF-32 sẽ mã hóa mọi ký tự bằng 4 bytes. Nhưng như thế nó quá tốn kém trong việc lưu trữ (có thể file size lớn lên 4 lần).</p><p>UTF-16 và UTF-8 là 2 loại encoding đa chiều dài nên sẽ tối ưu hơn.</p><ul><li>Với UTF- 8: Nếu ký tự chỉ cần 1 byte thì nó sẽ mã hóa bằng 1 byte…Nếu cần 4 bytes nó sẽ mã hóa bằng 4 bytes. Khi giải mã thì byte đầu tiên trong chuỗi (bit có trọng số cao nhất – MSB) sẽ dùng để xác định số byte cấu thành ký tự.</li><li>UTF-16: Cũng tương tự như UTF-8 nhưng nó sẽ dùng ít nhất 2 bytes, và có thể tăng lên 4 bytes.</li></ul><h1>4.Chọn sai encoding khi mở 1 văn bản</h1><p>Việc biết 1 văn bản được encoding bằng encoding nào rất là khó. chỉ có thể dựa vào suy đoán.</p><p>Khi mở văn bản sai encoding có thể sẽ ảnh hưởng đến nội dung của văn bản. Vì khi mở văn bản. Có thể các editor có thể âm thầm thay thế những bytes mà nó không nhận diện ra được bằng ký tự ? hoặc � (thậm chí là loại bỏ bytes đó đi). Từ đó không thể khôi phục lại được dữ liệu ban đầu.</p><p>Nếu muốn convert từ encoding này sang encoding khác thì cần dùng các phần mềm chuyên dụng để mapping lại cái giá trị tương ứng trong code page của từng loại.</p><h1>5.UTF-8 và ASCII</h1><p>UTF-8 tương thích hoàn toàn với ASCII.</p><p>Mọi ký tự trong ASCII đều tương đương với giá trị trong UTF-8. Những ký tự không có trong ASCII sẽ có từ 2 bytes trở lên.</p><p>Mọi String trong Javascript đều được encoding chỉ bởi UTF-16</p><p>Ngày nay, UTF-8 được coi là tiêu chuẩn. Vì nó mã hoá gần như mọi ký tự bạn cần, tương thích ngược với và khá hiệu quả về mặt bộ nhớ đối với hầu hết các trường hợp.</p><h1>6. Tổng kết</h1><ul><li>Khi làm việc với CSV cũ thì nên mở với UTF16 LE để tránh lỗi encoding</li></ul><h1>7.Refer</h1><ul><li><a href="https://kunststube.net/encoding/">https://kunststube.net/encoding/</a></li><li><a href="https://viblo.asia/p/nhung-kien-thuc-co-ban-nhat-ma-bat-cu-lap-trinh-vien-nao-cung-phai-biet-ve-encoding-va-character-set-phan-2-07LKXNg8lV4">https://viblo.asia/p/nhung-kien-thuc-co-ban-nhat-ma-bat-cu-lap-trinh-vien-nao-cung-phai-biet-ve-encoding-va-character-set-phan-2-07LKXNg8lV4</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> common </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Scala </tag>
            
            <tag> JS </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookies</title>
      <link href="/Technology/JS/2021/07/12/cookies/"/>
      <url>/Technology/JS/2021/07/12/cookies/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cookies.png" alt="Cookies"></p><h1>1. Cookies là gì?</h1><p>Là 1 file dữ liệu nhỏ (tối đa là 4093kb) được server trả về và lưu trong trình browser của người dùng.</p><p>Mỗi khi request lên server thì cookie (chỉ key và value, còn những data khác: httpOnly, sameSite… sẽ không được gửi lên) của server đó cũng sẽ được gửi lên cùng.</p><p>Vì thế, nên ưu tiên save thông tin mà server không cần dùng vào localstorage, sessionstorage, indexeddb để tránh việc gửi data thừa lên server.</p><p>Có 3 mục đích chính khi dùng cookies:</p><ul><li>Quản lý phiên làm việc: thông tin đăng nhập, giỏ hàng…</li><li>Thông tin về cá nhân: tùy chọn giao diện, cài đặt…</li><li>Theo dõi, phân tích hành vi của người dùng</li></ul><h1>2. Các loại cookies.</h1><p>Có 2 loại cookies:</p><ul><li>Session Cookies: Cookies sẽ bị xóa khi trình duyệt bị đóng.</li><li>Persistent Cookies: Cookies sẽ bị xóa khi bị hết hạn hoặc bị xóa thủ công</li></ul><p>Khi tạo cookies nếu không set expire date hoặc max-age thì đó là session cookies, còn ngược lại là Persistent cookies</p><h1>3. Các thành phần có trong Cookie</h1><blockquote><ul><li>name : String</li><li>value : String</li><li>httpOnly : Boolean</li><li>Secure : Boolean</li><li>maxAge : Option[Int]</li><li>sameSite : Option[SameSite]</li><li>domain : Option[String]</li><li>path : String</li></ul></blockquote><p><code>name</code> và <code>value</code> là giá trị thông tin cookie cần lưu.</p><blockquote><p>VD: name = access_tokenvalue = Bearer MTIzNDU2Nzphc2RmZw==</p></blockquote><p><code>httpOnly</code>: Đảm bảo Cookie chỉ được sử dụng trong 1 HTTP. Sẽ không thể dùng Javascript để lấy được thông tin cookies (document.cookie). Với httpOnly có thể prevent tấn công XSS từ hacker</p><p><code>Secure</code>: Đảm bảo Cookies luôn được mã hóa khi chuyển từ Client lên Server bằng cách chỉ gửi Cookies đi nếu kết nối SSL được sử dụng (Https), với Http Cookie sẽ không được gửi</p><p><code>maxAge</code>: thời gian tồn tại của Cookie. được tính bằng giây (s).</p><blockquote><p>VD: maxAge = Some ( 1 * 60 * 60)</p></blockquote><p>Chú ý: Nếu giá trị expires cũng được define thì maxAge sẽ được ưu tiên cao hơn =&gt; thời gian tồn tại sẽ tính theo maxAge</p><p><code>Samesite</code>: Giúp bảo vệ khỏi tấn công Cross-site request forgery attacks (CSRF). Có 3 giá trị: Strick, Lax, None</p><p><code>Domain</code>: Với thuộc tính này sẽ giúp define cho việc cookie sẽ được lưu cho những domain nào.</p><blockquote><p>VD: có 3 domain như bên dưới.</p><ul><li><a href="http://batdongsan.com">batdongsan.com</a></li><li><a href="http://aip-frontend-dev.batdongsan.com">aip-frontend-dev.batdongsan.com</a></li><li><a href="http://aip-cms-dev.batdongsan.com">aip-cms-dev.batdongsan.com</a></li></ul><p>Note 1 : Mặc định nếu thuộc tính domain để trống thì các cookie sẽ không được share cho nhau. Cookie chỉ được sử dụng với duy nhất domain mà tạo ra nó</p><p>Note 2: Nếu domain = Some(“.batdongsan.com”) hoặc Some(“<a href="http://batdongsan.com">batdongsan.com</a>”) thì cookie của cả 3 domain sẽ được dùng chung. chỉ cần 1 domain thay đổi cookie là những domain khác cũng nhận được sự thay đổi này</p><p>Path: Với thuộc tính này sẽ define những path nào mới được dùng cookie. Mặc định sẽ là “/”</p><p>VD: path=”/admin” thì chỉ khi nào request từ <a href="http://domain.com/admin">domain.com/admin</a> thì cookie mới được kèm theo, còn <a href="http://domain.com/user">domain.com/user</a> thì không</p></blockquote><h1>4. Cách tạo Cookie</h1><ul><li>Tạo bằng webserver: tomcat, nginx…</li><li>Tạo bằng framework: Play framework, spring…</li><li>Tạo bằng JS: document.cookie=”access_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9″</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Scala </tag>
            
            <tag> JS </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
