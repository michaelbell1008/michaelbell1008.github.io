<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>SOLID-principles</title><meta name="description"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="1. SOLID là gì?

Là những nguyên lý thiết kế trong OOP. Nó giúp project dễ hiểu, dễ maintenance và linh hoạt hơn. Nên khi scale project cũng sẽ dễ dàng hơn
Nó là viết tắt của 5 nguyên lý sau:

Single responsibility - Đơn chức năng
Open/closed
Liskov substitution (LSP) – thay thế
Interface segregation (ISP) – phân tách
Dependency Inversion




2. Single res.."><meta name="generator" content="Hexo 5.4.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Michael Bell's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">SOLID-principles</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SOLID-la-gi"><span class="toc-text">1. SOLID là gì?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Single-responsibility-principle"><span class="toc-text">2. Single responsibility principle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Open-closed-principle"><span class="toc-text">3. Open&#x2F;closed principle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Liskov-substitution-principle-LSP"><span class="toc-text">4. Liskov substitution principle (LSP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Interface-segregation-principle-ISP"><span class="toc-text">5. Interface segregation principle (ISP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Dependency-Inversion-Principle"><span class="toc-text">6. Dependency Inversion Principle</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Java"><i class="tag post-item-tag">Java</i></a><a href="/tags/Scala"><i class="tag post-item-tag">Scala</i></a><a href="/tags/Technology"><i class="tag post-item-tag">Technology</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">SOLID-principles</h1><time class="has-text-grey" datetime="2017-12-08T18:08:08.000Z">2017-12-09</time><article class="mt-2 post-content"><h2 id="1-SOLID-la-gi">1. SOLID là gì?</h2>
<ul>
<li>Là những nguyên lý thiết kế trong OOP. Nó giúp project dễ hiểu, dễ maintenance và linh hoạt hơn. Nên khi scale project cũng sẽ dễ dàng hơn</li>
<li>Nó là viết tắt của 5 nguyên lý sau:
<ul>
<li>Single responsibility - Đơn chức năng</li>
<li>Open/closed</li>
<li>Liskov substitution (LSP) – thay thế</li>
<li>Interface segregation (ISP) – phân tách</li>
<li>Dependency Inversion</li>
</ul>
</li>
</ul>
<p><img src="/images/SOLID-principles.jpeg" alt="SOLID-principles"></p>
<h2 id="2-Single-responsibility-principle">2. Single responsibility principle</h2>
<blockquote>
<p><strong>A class should have one and only one reason to change, meaning that a class should have only one job.</strong></p>
<p>Nghĩa là: Một class chỉ nên giữ một trách nhiệm duy nhất. Chỉ có thể sửa đổi class với một lý do duy nhất</p>
</blockquote>
<p>Nó giúp:</p>
<ul>
<li>Testing: số test cases sẽ ít hơn</li>
<li>Lower coupling: các class ít phụ thuộc vào nhau.</li>
<li>Organization:
<ul>
<li>Tổ chức các class nhỏ sẽ dễ dàng cho việc tìm kiếm hơn trong một class lớn.</li>
<li>Code bớt cồng kềnh hơn, khi thay đổi code sẽ bớt khó khăn và giảm impact đến features khác.</li>
</ul>
</li>
</ul>
<p>Ví dụ:</p>
<blockquote>
<pre><code>  public class Book &#123;
      private String name;
      private String author;
      private String text;
  &#125;

  public boolean isWordInText(String word)&#123;
      return text.contains(word);
  &#125;

  // method này đã vi phạm nguyên tắc trên.
  void printTextToConsole()&#123;
      // do something
  &#125;
</code></pre>
</blockquote>
<p>Cách khắc phục là tạo ra class mới chỉ xử lý việc hiển thị nội dung qua các phương tiện khác</p>
<blockquote>
<pre><code>  public class BookPrinter &#123;

      void printTextToConsole(String text)&#123;
          // do something
      &#125;

      void printTextToScreen(String text)&#123;
          // do something
      &#125;
  &#125;
</code></pre>
</blockquote>
<h2 id="3-Open-closed-principle">3. Open/closed principle</h2>
<blockquote>
<p><strong>Objects or entities should be open for extension but closed for modification.</strong></p>
<p>Nghĩa là: Một class có thể mở rộng thoải mái, nhưng không sửa đổi nó.</p>
</blockquote>
<p>Nó giúp:</p>
<ul>
<li>Ngăn sửa đổi những code đã có và có thể gây thêm các lỗi mới khi sửa đổi code.</li>
</ul>
<p>Ví dụ</p>
<p>Chúng ta có class Guitar đang hoạt động tốt như bên dưới</p>
<blockquote>
<pre><code>  public class Guitar &#123;
      private String make;
      private String model;
      private int volume;
  &#125;
</code></pre>
</blockquote>
<p>Nhưng hôm nay khách hàng yêu cầu thêm chức năng mới cho <code>Guitar</code>. Thay vì sửa code Guitar, chúng ta nên tạo một class mới <code>SuperCoolGuitarWithFlames</code> và
<code>extend</code> lại <code>Guitar</code>. Điều này sẽ giúp cho program sẽ không bị phát sinh lỗi ở những features đã chạy có trước đó.</p>
<blockquote>
<pre><code>  public class SuperCoolGuitarWithFlames extends Guitar &#123;
      private String flameColor;
  &#125;
</code></pre>
</blockquote>
<h2 id="4-Liskov-substitution-principle-LSP">4. Liskov substitution principle (LSP)</h2>
<blockquote>
<p><strong>if class A is a subtype of class B, we should be able to replace B with A without disrupting the behavior of our program.</strong></p>
<p>Nghĩa là: Nếu class A là 1 subtype của class B, thì B có thể được thay thế bằng A mà không làm thay đổi tính đúng đắn của chương trình</p>
</blockquote>
<p>Ví dụ:</p>
<blockquote>
<pre><code>  public interface Car &#123;

      void turnOnEngine();
  &#125;

  public class MotorCar implements Car &#123;

      private Engine engine;

      public void turnOnEngine() &#123;
          engine.on();  //turn on the engine!
      &#125;
  &#125;
</code></pre>
</blockquote>
<p>Với một interface Car cung cấp method bật năng lượng như xăng, dầu. Nhưng sau đó chúng ta phát triển một loại xe điện <code>ElectricCar</code>.</p>
<blockquote>
<pre><code>  public class ElectricCar implements Car &#123;

      public void turnOnEngine() &#123;
          throw new AssertionError(&quot;I don't have an engine!&quot;);
      &#125;
  &#125;
</code></pre>
</blockquote>
<p>Với cách viết như trên, nó đã vi phạm nguyên tắc LSP vì ElectricCar là subtype của Car nhưng không thể thay thế Car bằng ElectricCar được.
Cách khắc phục là viết lại Car, để Car có thể adapt được trường hợp xe không có động cơ.</p>
<h2 id="5-Interface-segregation-principle-ISP">5. Interface segregation principle (ISP)</h2>
<blockquote>
<p><strong>Larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them</strong></p>
<p>Thay vì dùng 1 interface lớn, ta nên tách thành nhiều interface nhỏ</p>
</blockquote>
<p>Lợi ích:</p>
<ul>
<li>Có thể đảm bảo rằng việc impliment các class chỉ cần quan tâm đến các method mà chúng quan tâm.</li>
</ul>
<blockquote>
<pre><code>  public interface BearKeeper &#123;
      void washTheBear();
      void feedTheBear();
      void petTheBear();
  &#125;
</code></pre>
</blockquote>
<p><code>BearKeeper</code> làm một lúc 3 việc nên rõ ràng đây là một cách viết không tốt. Bjo chúng ta cần một class <code>BearCarer</code> chỉ có 2 hành động là <code>washTheBear</code> và <code>feedTheBear</code>, chúng ta có thể viết như sau:</p>
<blockquote>
<pre><code>  public interface BearCleaner &#123;
      void washTheBear();
  &#125;

  public interface BearFeeder &#123;
      void feedTheBear();
  &#125;

  public interface BearPetter &#123;
      void petTheBear();
  &#125;

  public class BearCarer implements BearCleaner, BearFeeder &#123;

      public void washTheBear() &#123;
          // do something
      &#125;

      public void feedTheBear() &#123;
          // do something
      &#125;
  &#125;
</code></pre>
</blockquote>
<h2 id="6-Dependency-Inversion-Principle">6. Dependency Inversion Principle</h2>
<blockquote>
<p><strong>High-level modules should not depend on low-level modules. Both should depend on abstractions.</strong></p>
<p>Nghĩa là: Các module cấp cao không nên phụ thuộc vào các modules cấp thấp. Cả 2 nên phụ thuộc vào abstraction.</p>
<p><strong>Abstractions should not depend upon details. Details should depend upon abstractions.</strong></p>
<p>Nghĩa là: Interface (abstraction) không nên phụ thuộc vào chi tiết, mà ngược lại. (Các class giao tiếp với nhau thông qua interface, không phải thông qua implementation.)</p>
</blockquote>
<p>Ví dụ:</p>
<p>Chúng ta có class <code>Windows98Machine</code> với <code>StandardKeyboard</code> và <code>monitor</code>.</p>
<blockquote>
<pre><code>  public class Windows98Machine &#123;

      private final StandardKeyboard keyboard;
      private final Monitor monitor;

      public Windows98Machine() &#123;
          monitor = new Monitor();
          keyboard = new StandardKeyboard();
      &#125;
  &#125;
</code></pre>
</blockquote>
<p>Tuy nhiên đoạn code trên có vấn đề trong việc khởi tạo <code>monitor</code> và <code>keyboard</code> cố định với từ khóa <code>new</code>. Nó làm đoạn cả <code>Windows98Machine, StandardKeyboard, Monitor</code> dính chặt với nhau.
Nếu muốn thay keyboard hay monitor thành một loại khác sẽ khiến chúng ta phải thay đổi code nhiều nơi. Chúng ta có thế sửa thành</p>
<blockquote>
<pre><code>  public interface Keyboard &#123; &#125;

  public class Windows98Machine&#123;

      private final Keyboard keyboard;
      private final Monitor monitor;

      public Windows98Machine(Keyboard keyboard, Monitor monitor) &#123;
          this.keyboard = keyboard;
          this.monitor = monitor;
      &#125;
  &#125;

  public class StandardKeyboard implements Keyboard &#123; &#125;
</code></pre>
</blockquote>
<p>Việc này làm giúp code của chúng ta lower coupling, dễ thay đổi, ít bugs hơn.</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/Technology/JS/2018/05/12/cookies/" title="Cookies"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Cookies</span></a><a class="button is-default" href="/Technology/Java/Scala/2017/11/01/string-vs-stringbuilder-stringbuffer/" title="String vs StringBuilder vs StringBuffer in Java"><span class="has-text-weight-semibold">Next: String vs StringBuilder vs StringBuffer in Java</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/michaelbell1008"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in//nguyen-chuong-2768a5124/"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//ChuongNguyen1008"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Michael Bell 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p class="is-flex is-justify-content-center"></p><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>