<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>SOLID-principles</title><meta name="description"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="1. SOLID là gì?

Là những nguyên lý thiết kế trong OOP. Nó giúp project dễ hiểu, dễ maintenance, dễ testing và linh hoạt hơn. Nên khi scale project cũng sẽ dễ dàng hơn
Nó là viết tắt của 5 nguyên lý sau:

Single responsibility - Đơn chức năng
Open/closed
Liskov substitution (LSP) – thay thế
Interface segregation (ISP) – phân tách
Dependency Inversion




2.."><meta name="generator" content="Hexo 5.4.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Michael Bell's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">SOLID-principles</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SOLID-la-gi"><span class="toc-text">1. SOLID là gì?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Single-responsibility-principle"><span class="toc-text">2. Single responsibility principle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Open-closed-principle"><span class="toc-text">3. Open&#x2F;closed principle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Liskov-substitution-principle-LSP"><span class="toc-text">4. Liskov substitution principle (LSP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Interface-segregation-principle-ISP"><span class="toc-text">5. Interface segregation principle (ISP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Dependency-Inversion-Principle"><span class="toc-text">6. Dependency Inversion Principle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Refer"><span class="toc-text">7. Refer</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/scala"><i class="tag post-item-tag">scala</i></a><a href="/tags/technology"><i class="tag post-item-tag">technology</i></a><a href="/tags/java"><i class="tag post-item-tag">java</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">SOLID-principles</h1><time class="has-text-grey" datetime="2017-12-08T18:08:08.000Z">2017-12-09</time><article class="mt-2 post-content"><h2 id="1-SOLID-la-gi">1. SOLID là gì?</h2>
<ul>
<li>Là những nguyên lý thiết kế trong OOP. Nó giúp project dễ hiểu, dễ maintenance, dễ testing và linh hoạt hơn. Nên khi scale project cũng sẽ dễ dàng hơn</li>
<li>Nó là viết tắt của 5 nguyên lý sau:
<ul>
<li>Single responsibility - Đơn chức năng</li>
<li>Open/closed</li>
<li>Liskov substitution (LSP) – thay thế</li>
<li>Interface segregation (ISP) – phân tách</li>
<li>Dependency Inversion</li>
</ul>
</li>
</ul>
<p><img src="/images/SOLID-principles.jpeg" alt="SOLID-principles"></p>
<h2 id="2-Single-responsibility-principle">2. Single responsibility principle</h2>
<blockquote>
<p><strong>A class should have one and only one reason to change, meaning that a class should have only one job.</strong></p>
<p>Nghĩa là: Một class chỉ nên giữ một trách nhiệm duy nhất. Chỉ có thể sửa đổi class với một lý do duy nhất</p>
</blockquote>
<p>Lợi ích:</p>
<ul>
<li>Testing: số test cases sẽ ít hơn</li>
<li>Lower coupling: các class ít phụ thuộc vào nhau.</li>
<li>Organization:
<ul>
<li>Tổ chức các class nhỏ sẽ dễ dàng cho việc tìm kiếm hơn trong một class lớn.</li>
<li>Code bớt cồng kềnh hơn, khi thay đổi code sẽ bớt khó khăn và giảm impact đến features khác.</li>
</ul>
</li>
</ul>
<p>Ví dụ:</p>
<blockquote>
<pre><code>  public class Book &#123;
      private String name;
      private String content;

      public boolean isWordInContent(String w)&#123;
          return content.contains(w);
      &#125;

      // method này đã vi phạm nguyên tắc Single responsibility.
      // Cách giải quyết là viết method này sang BookPrinter.java
      // Ở BookPrinter chúng ta có thể thêm các phương thức khác như printContentToScreen,...
      public void printContentToConsole() &#123;
         // do something
      &#125;
  &#125;
</code></pre>
</blockquote>
<p>Cách khắc phục là tạo ra class mới chỉ xử lý việc hiển thị nội dung qua các phương tiện khác</p>
<blockquote>
<pre><code>  public class BookPrinter &#123;

      public void printContentToConsole(String text) &#123;
          // do something
      &#125;

      public void printContentToScreen(String text) &#123;
          // do something
      &#125;
  &#125;
</code></pre>
</blockquote>
<h2 id="3-Open-closed-principle">3. Open/closed principle</h2>
<blockquote>
<p><strong>Objects or entities should be open for extension but closed for modification.</strong></p>
<p>Nghĩa là: Một class có thể mở rộng thoải mái, nhưng không sửa đổi nó.</p>
</blockquote>
<p>Lợi ích:</p>
<ul>
<li>Ngăn sửa đổi những code đã có để không phát sinh bugs cho những đoạn code đang sử dụng.</li>
</ul>
<p>Ví dụ:</p>
<p>Vẫn với class <code>Book</code> như phía trên, nhưng hôm nay chúng ta nhận được yêu cầu cần thêm một loại sách <code>ebook</code> vào trong program. Loại sách này sẽ có thêm attribute là <code>link</code> để thể hiện link của cuốn sách.
Thay vì thêm trực tiếp <code>link</code> vào class <code>Book</code>, chúng ta nên tạo ra class <code>EBook</code> extend lại <code>Book</code>. Điều này giúp chúng ta không cần quan tâm đến những đoạn code mà <code>Book</code> được sử dụng</p>
<blockquote>
<pre><code>  public class EBook extends Book&#123;
      private String link;

  &#125;
</code></pre>
</blockquote>
<h2 id="4-Liskov-substitution-principle-LSP">4. Liskov substitution principle (LSP)</h2>
<blockquote>
<p><strong>if class A is a subtype of class B, we should be able to replace B with A without disrupting the behavior of our program.</strong></p>
<p>Nghĩa là: Nếu class A là 1 subtype của class B, thì B có thể được thay thế bằng A mà không làm thay đổi tính đúng đắn của chương trình</p>
</blockquote>
<p>Lợi ích:</p>
<ul>
<li>Giúp đảm bảo class cha và class con luôn luôn nhất quán với nhau.</li>
</ul>
<p>Biểu hiện:</p>
<ul>
<li>class con <code>Override method</code> class cha nhưng thực hiện chức năng khác.</li>
<li>class con <code>Override method</code> class cha nhưng throw exception.</li>
<li>class con <code>Override method</code> class cha nhưng không làm gì cả.</li>
</ul>
<p>Ví dụ:</p>
<blockquote>
<pre><code>  public abstract class Book &#123;
      protected String name;
      protected String content;

      public abstract String preview();vd
  &#125;

  public class EBook extends Book &#123;

      private String link;

      @Override
      public String preview() &#123;
          return this.content.substring(0, 200);
      &#125;
  &#125;
</code></pre>
</blockquote>
<blockquote>
<pre><code>  public class PaperBook extends Book&#123;

      // method này đã vi phạm LSP.
      // vì mặc dù PaperBook là subtype của Book
      // tuy nhiên method preview lại không thực hiện chức năng như class Book define
      @Override
      public String preview() &#123;
          return null;
      &#125;
  &#125;
</code></pre>
</blockquote>
<p>Cách khắc phục là ta để method <code>preview()</code>chỉ define ở trong class <code>Ebook</code></p>
<h2 id="5-Interface-segregation-principle-ISP">5. Interface segregation principle (ISP)</h2>
<blockquote>
<p><strong>Larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them</strong></p>
<p>Thay vì dùng 1 interface lớn, ta nên tách thành nhiều interface nhỏ</p>
</blockquote>
<p>Lợi ích:</p>
<ul>
<li>Có thể đảm bảo rằng việc implement các class chỉ cần quan tâm đến các method mà chúng quan tâm.</li>
</ul>
<p>Ví dụ:</p>
<blockquote>
<pre><code>  public interface Repository &#123;
      public Book resolveBy(long id);
      public List&lt;Book&gt; resolveAll();
      public boolean resolveBy(Book book);
  &#125;
</code></pre>
</blockquote>
<p>Vì có thể có những class chỉ sử dụng đến các chức năng resolve mà không dùng đến chức năng update. Nên để không vi phạm ISP ta nên tách nhỏ <code>Repository</code> thành các interface nhỏ hơn.</p>
<blockquote>
<pre><code>  public interface ResolveFeatureRepository &#123;
      public Book resolveBy(long id);
  &#125;

  public interface ResolveAllFeatureRepository &#123;
      public List&lt;Book&gt; resolveAll();
  &#125;

  public interface UpdateFeatureRepository &#123;
      public boolean update(Book book);
  &#125;

  public interface BookRepository extends ResolveFeatureRepository, UpdateFeatureRepository &#123;&#125;

  public class BookRepositoryImpl implements BookRepository &#123;

      @Override
      public Book resolveBy(long id) &#123;
          // do something
      &#125;

      @Override
      public boolean update(Book book) &#123;
          // do something
      &#125;
  &#125;
</code></pre>
</blockquote>
<h2 id="6-Dependency-Inversion-Principle">6. Dependency Inversion Principle</h2>
<blockquote>
<p><strong>High-level modules should not depend on low-level modules. Both should depend on abstractions.</strong></p>
<p>Nghĩa là: Các module cấp cao không nên phụ thuộc vào các modules cấp thấp. Cả 2 nên phụ thuộc vào abstraction.</p>
<p><strong>Abstractions should not depend upon details. Details should depend upon abstractions.</strong></p>
<p>Nghĩa là: Interface (abstraction) không nên phụ thuộc vào chi tiết, mà ngược lại. (Các class giao tiếp với nhau thông qua interface, không phải thông qua implementation.)</p>
</blockquote>
<p>Để tránh sự phụ thuộc vào nhau, các module cấp cao nên tạo ra interface, các module cấp thấp sẽ implements các interface đó.</p>
<p>Ví dụ:</p>
<p>Chúng ta có class <code>Windows98Machine</code> với <code>StandardKeyboard</code> và <code>monitor</code>.</p>
<blockquote>
<pre><code>  public class Windows98Machine &#123;

      private final StandardKeyboard keyboard;
      private final Monitor monitor;

      public Windows98Machine() &#123;
          monitor = new Monitor();
          keyboard = new StandardKeyboard();
      &#125;
  &#125;
</code></pre>
</blockquote>
<p>Tuy nhiên đoạn code trên có vấn đề trong việc khởi tạo <code>monitor</code> và <code>keyboard</code> cố định với từ khóa <code>new</code>. Nó làm đoạn cả <code>Windows98Machine, StandardKeyboard, Monitor</code> dính chặt với nhau.
Nếu muốn thay keyboard hay monitor thành một loại khác sẽ khiến chúng ta phải thay đổi code nhiều nơi. Chúng ta có thế sửa thành</p>
<blockquote>
<pre><code>  public interface Keyboard &#123; &#125;

  public class Windows98Machine&#123;

      private final Keyboard keyboard;
      private final Monitor monitor;

      public Windows98Machine(Keyboard keyboard, Monitor monitor) &#123;
          this.keyboard = keyboard;
          this.monitor = monitor;
      &#125;
  &#125;

  public class StandardKeyboard implements Keyboard &#123; &#125;
</code></pre>
</blockquote>
<p>Việc này làm giúp code của chúng ta lower coupling, dễ thay đổi, ít bugs hơn.</p>
<h2 id="7-Refer">7. Refer</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/solid">https://github.com/michaelbell1008/Tutorial/tree/master/src/main/java/tutorial/solid</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/Technology/Java/2018/01/05/design-pattern/" title="Design Pattern"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Design Pattern</span></a><a class="button is-default" href="/Technology/Java/Scala/2017/11/01/string-vs-stringbuilder-stringbuffer/" title="String vs StringBuilder vs StringBuffer in Java"><span class="has-text-weight-semibold">Next: String vs StringBuilder vs StringBuffer in Java</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/michaelbell1008"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in//nguyen-chuong-2768a5124/"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//ChuongNguyen1008"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Michael Bell 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p class="is-flex is-justify-content-center"></p><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>